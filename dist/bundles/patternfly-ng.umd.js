(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('lodash'), require('rxjs/add/operator/filter'), require('@angular/common'), require('@angular/forms'), require('c3'), require('d3'), require('rxjs/Observable'), require('rxjs/add/observable/timer'), require('angular-tree-component'), require('@angular/router'), require('ng2-dragula'), require('@swimlane/ngx-datatable')) :
    typeof define === 'function' && define.amd ? define(['exports', '@angular/core', 'lodash', 'rxjs/add/operator/filter', '@angular/common', '@angular/forms', 'c3', 'd3', 'rxjs/Observable', 'rxjs/add/observable/timer', 'angular-tree-component', '@angular/router', 'ng2-dragula', '@swimlane/ngx-datatable'], factory) :
    (factory((global['patternfly-ng'] = {}),global.core,global.lodash,null,global.common,global.forms,global.c3,global.d3,global.Observable,null,global.angularTreeComponent,global.router,global.ng2Dragula,global.ngxDatatable));
}(this, (function (exports,core,lodash,filter,common,forms,c3,d3,Observable,timer,angularTreeComponent,router,ng2Dragula,ngxDatatable) { 'use strict';

    /**
     * An action containing common properties for buttons, kebabs, etc.
     */
    var Action = /** @class */ (function () {
        function Action() {
        }
        return Action;
    }());

    /**
     * An action config containing properties for primary and secondary actions such as
     * multiple buttons and kebab menu options
     */
    var ActionConfig = /** @class */ (function () {
        function ActionConfig() {
        }
        return ActionConfig;
    }());

    var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = (undefined && undefined.__metadata) || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    /**
     * List actions component.
     *
     * By default, buttons and kebab have no padding so they may inherit stying from components such as list and toolbar.
     */
    var ActionComponent = /** @class */ (function () {
        /**
         * The default constructor
         *
         * @param el The element reference for this component
         */
        function ActionComponent(el) {
            this.el = el;
            /**
             * The event emitted when an action has been selected
             */
            this.onActionSelect = new core.EventEmitter();
            this.defaultConfig = {
                moreActionsDisabled: false,
                moreActionsVisible: true
            };
            this.isMoreActionsDropup = false;
        }
        // Initialization
        /**
         * Setup component configuration upon initialization
         */
        ActionComponent.prototype.ngOnInit = function () {
            this.setupConfig();
        };
        /**
         * Check if the component config has changed
         */
        ActionComponent.prototype.ngDoCheck = function () {
            // Do a deep compare on config
            if (!lodash.isEqual(this.config, this.prevConfig)) {
                this.setupConfig();
            }
        };
        /**
         * Set up default config
         */
        ActionComponent.prototype.setupConfig = function () {
            if (this.config !== undefined) {
                lodash.defaults(this.config, this.defaultConfig);
            }
            else {
                this.config = lodash.cloneDeep(this.defaultConfig);
            }
            // lodash has issues deep cloning templates -- best seen with list component
            this.prevConfig = lodash.clone(this.config);
        };
        // Private
        ActionComponent.prototype.handleAction = function (action) {
            if (action && action.disabled !== true) {
                this.onActionSelect.emit(action);
            }
        };
        /**
         * Set flag indicating if kebab should be shown as a dropdown or dropup
         *
         * @param $event The MouseEvent triggering this function
         */
        ActionComponent.prototype.initMoreActionsDropup = function ($event) {
            var _this = this;
            window.requestAnimationFrame(function () {
                var kebabContainer = _this.closest($event.target, '.dropdown-kebab-pf.open', 'pfng-list-actions');
                var listContainer = _this.closest(_this.el.nativeElement, '.list-pf', 'pfng-list');
                if (kebabContainer === null || listContainer === null) {
                    return;
                }
                var dropdownButton = kebabContainer.querySelector('.dropdown-toggle');
                var dropdownMenu = kebabContainer.querySelector('.dropdown-menu');
                var buttonRect = dropdownButton.getBoundingClientRect();
                var menuRect = dropdownMenu.getBoundingClientRect();
                var menuTop = buttonRect.top - menuRect.height;
                var menuBottom = buttonRect.top + buttonRect.height + menuRect.height;
                var parentRect = listContainer.getBoundingClientRect();
                if ((menuBottom <= parentRect.top + parentRect.height) || (menuTop < parentRect.top)) {
                    _this.isMoreActionsDropup = false;
                }
                else {
                    _this.isMoreActionsDropup = true;
                }
            });
        };
        // Utils
        /**
         * Get the closest ancestor based on given selector
         *
         * @param el The HTML element to start searching for matching ancestor
         * @param selector The selector to match
         * @param stopSelector If this selector is matched, the search is stopped
         * @returns {HTMLElement} The matching HTML element or null if not found
         */
        ActionComponent.prototype.closest = function (el, selector, stopSelector) {
            var retval = null;
            while (el) {
                if (el.matches(selector)) {
                    retval = el;
                    break;
                }
                else if (stopSelector && el.matches(stopSelector)) {
                    break;
                }
                el = el.parentElement;
            }
            return retval;
        };
        __decorate([
            core.Input(),
            __metadata("design:type", ActionConfig)
        ], ActionComponent.prototype, "config", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", core.TemplateRef)
        ], ActionComponent.prototype, "template", void 0);
        __decorate([
            core.Output('onActionSelect'),
            __metadata("design:type", Object)
        ], ActionComponent.prototype, "onActionSelect", void 0);
        ActionComponent = __decorate([
            core.Component({
                encapsulation: core.ViewEncapsulation.None,
                selector: 'pfng-action',
                template: "<button class=\"btn btn-default primary-action {{action.styleClass}}\" title=\"{{action.tooltip}}\" type=\"button\" *ngFor=\"let action of config.primaryActions\" [disabled]=\"action.disabled\" [ngClass]=\"{'invisible': action.visible === false}\" (click)=\"handleAction(action)\"><div *ngIf=\"action.template; then showButtonTemplate else showButton\"></div><ng-template #showButtonTemplate let-action=\"action\" [ngTemplateOutlet]=\"action.template\" [ngTemplateOutletContext]=\"{ action: action }\"></ng-template><ng-template #showButton>{{action.title}}</ng-template></button><ng-template *ngIf=\"template !== undefined\" let-action=\"action\" [ngTemplateOutlet]=\"template\" [ngTemplateOutletContext]=\"{ action: action }\"></ng-template><div class=\"dropdown-kebab-pf pull-right {{config.moreActionsStyleClass}}\" dropdown [ngClass]=\"{'dropdown': !isMoreActionsDropup, 'dropup': isMoreActionsDropup, 'invisible': config.moreActionsVisible === false}\" *ngIf=\"config.moreActions?.length > 0\"><button class=\"btn btn-link dropdown-toggle\" type=\"button\" dropdownToggle [ngClass]=\"{'disabled': config.moreActionsDisabled}\" (click)=\"initMoreActionsDropup($event)\"><span class=\"fa fa-ellipsis-v\"></span></button><ul class=\"dropdown-menu-right dropdown-menu\" aria-labelledby=\"dropdownKebab\" *dropdownMenu><li *ngFor=\"let action of config.moreActions\" class=\"{{action.styleClass}}\" [attr.role]=\"action.separator === true ? 'separator' : 'menuitem'\" [ngClass]=\"{'divider': action.separator === true, 'disabled': action.disabled === true, 'hidden': action.visible === false}\"><a *ngIf=\"action.disabled !== true && action.separator !== true\" class=\"dropdown-item secondary-action\" href=\"javascript:void(0)\" title=\"{{action.tooltip}}\" (click)=\"handleAction(action)\">{{action.title}}</a> <a *ngIf=\"action.disabled === true && action.separator !== true\" class=\"dropdown-item secondary-action\" href=\"javascript:void(0)\" title=\"{{action.tooltip}}\" onclick=\"return false;\">{{action.title}}</a></li></ul></div>"
            }),
            __metadata("design:paramtypes", [core.ElementRef])
        ], ActionComponent);
        return ActionComponent;
    }());

    /**
     * @copyright Valor Software
     * @copyright Angular ng-bootstrap team
     */
    var Trigger = (function () {
        function Trigger(open, close) {
            this.open = open;
            this.close = close || open;
        }
        Trigger.prototype.isManual = function () {
            return this.open === 'manual' || this.close === 'manual';
        };
        return Trigger;
    }());

    var DEFAULT_ALIASES = {
        hover: ['mouseover', 'mouseout'],
        focus: ['focusin', 'focusout']
    };
    function parseTriggers(triggers, aliases) {
        if (aliases === void 0) { aliases = DEFAULT_ALIASES; }
        var trimmedTriggers = (triggers || '').trim();
        if (trimmedTriggers.length === 0) {
            return [];
        }
        var parsedTriggers = trimmedTriggers
            .split(/\s+/)
            .map(function (trigger) { return trigger.split(':'); })
            .map(function (triggerPair) {
            var alias = aliases[triggerPair[0]] || triggerPair;
            return new Trigger(alias[0], alias[1]);
        });
        var manualTriggers = parsedTriggers.filter(function (triggerPair) {
            return triggerPair.isManual();
        });
        if (manualTriggers.length > 1) {
            throw new Error('Triggers parse error: only one manual trigger is allowed');
        }
        if (manualTriggers.length === 1 && parsedTriggers.length > 1) {
            throw new Error('Triggers parse error: manual trigger can\'t be mixed with other triggers');
        }
        return parsedTriggers;
    }
    function listenToTriggersV2(renderer, options) {
        var parsedTriggers = parseTriggers(options.triggers);
        var target = options.target;
        // do nothing
        if (parsedTriggers.length === 1 && parsedTriggers[0].isManual()) {
            return Function.prototype;
        }
        // all listeners
        var listeners = [];
        // lazy listeners registration
        var _registerHide = [];
        var registerHide = function () {
            // add hide listeners to unregister array
            _registerHide.forEach(function (fn) { return listeners.push(fn()); });
            // register hide events only once
            _registerHide.length = 0;
        };
        // register open\close\toggle listeners
        parsedTriggers.forEach(function (trigger) {
            var useToggle = trigger.open === trigger.close;
            var showFn = useToggle ? options.toggle : options.show;
            if (!useToggle) {
                _registerHide.push(function () {
                    return renderer.listen(target, trigger.close, options.hide);
                });
            }
            listeners.push(renderer.listen(target, trigger.open, function () { return showFn(registerHide); }));
        });
        return function () {
            listeners.forEach(function (unsubscribeFn) { return unsubscribeFn(); });
        };
    }
    function registerOutsideClick(renderer, options) {
        if (!options.outsideClick) {
            return Function.prototype;
        }
        return renderer.listen('document', 'click', function (event) {
            if (options.target && options.target.contains(event.target)) {
                return;
            }
            if (options.targets &&
                options.targets.some(function (target) { return target.contains(event.target); })) {
                return;
            }
            options.hide();
        });
    }

    /**
     * @copyright Valor Software
     * @copyright Angular ng-bootstrap team
     */
    var ContentRef = (function () {
        function ContentRef(nodes, viewRef, componentRef) {
            this.nodes = nodes;
            this.viewRef = viewRef;
            this.componentRef = componentRef;
        }
        return ContentRef;
    }());

    // tslint:disable:max-file-line-count
    var ComponentLoader = (function () {
        /**
         * Do not use this directly, it should be instanced via
         * `ComponentLoadFactory.attach`
         * @internal
         */
        // tslint:disable-next-line
        function ComponentLoader(_viewContainerRef, _renderer, _elementRef, _injector, _componentFactoryResolver, _ngZone, _applicationRef, _posService) {
            this._viewContainerRef = _viewContainerRef;
            this._renderer = _renderer;
            this._elementRef = _elementRef;
            this._injector = _injector;
            this._componentFactoryResolver = _componentFactoryResolver;
            this._ngZone = _ngZone;
            this._applicationRef = _applicationRef;
            this._posService = _posService;
            this.onBeforeShow = new core.EventEmitter();
            this.onShown = new core.EventEmitter();
            this.onBeforeHide = new core.EventEmitter();
            this.onHidden = new core.EventEmitter();
            this._providers = [];
            this._isHiding = false;
            this._listenOpts = {};
            this._globalListener = Function.prototype;
        }
        Object.defineProperty(ComponentLoader.prototype, "isShown", {
            get: function () {
                if (this._isHiding) {
                    return false;
                }
                return !!this._componentRef;
            },
            enumerable: true,
            configurable: true
        });
        ComponentLoader.prototype.attach = function (compType) {
            this._componentFactory = this._componentFactoryResolver
                .resolveComponentFactory(compType);
            return this;
        };
        // todo: add behaviour: to target element, `body`, custom element
        ComponentLoader.prototype.to = function (container) {
            this.container = container || this.container;
            return this;
        };
        ComponentLoader.prototype.position = function (opts) {
            this.attachment = opts.attachment || this.attachment;
            this._elementRef = opts.target || this._elementRef;
            return this;
        };
        ComponentLoader.prototype.provide = function (provider) {
            this._providers.push(provider);
            return this;
        };
        // todo: appendChild to element or document.querySelector(this.container)
        ComponentLoader.prototype.show = function (opts) {
            if (opts === void 0) { opts = {}; }
            this._subscribePositioning();
            this._innerComponent = null;
            if (!this._componentRef) {
                this.onBeforeShow.emit();
                this._contentRef = this._getContentRef(opts.content, opts.context, opts.initialState);
                var injector = core.ReflectiveInjector.resolveAndCreate(this._providers, this._injector);
                this._componentRef = this._componentFactory.create(injector, this._contentRef.nodes);
                this._applicationRef.attachView(this._componentRef.hostView);
                // this._componentRef = this._viewContainerRef
                //   .createComponent(this._componentFactory, 0, injector, this._contentRef.nodes);
                this.instance = this._componentRef.instance;
                Object.assign(this._componentRef.instance, opts);
                if (this.container instanceof core.ElementRef) {
                    this.container.nativeElement.appendChild(this._componentRef.location.nativeElement);
                }
                if (this.container === 'body' && typeof document !== 'undefined') {
                    document
                        .querySelector(this.container)
                        .appendChild(this._componentRef.location.nativeElement);
                }
                if (!this.container &&
                    this._elementRef &&
                    this._elementRef.nativeElement.parentElement) {
                    this._elementRef.nativeElement.parentElement.appendChild(this._componentRef.location.nativeElement);
                }
                // we need to manually invoke change detection since events registered
                // via
                // Renderer::listen() are not picked up by change detection with the
                // OnPush strategy
                if (this._contentRef.componentRef) {
                    this._innerComponent = this._contentRef.componentRef.instance;
                    this._contentRef.componentRef.changeDetectorRef.markForCheck();
                    this._contentRef.componentRef.changeDetectorRef.detectChanges();
                }
                this._componentRef.changeDetectorRef.markForCheck();
                this._componentRef.changeDetectorRef.detectChanges();
                this.onShown.emit(this._componentRef.instance);
            }
            this._registerOutsideClick();
            return this._componentRef;
        };
        ComponentLoader.prototype.hide = function () {
            if (!this._componentRef) {
                return this;
            }
            this.onBeforeHide.emit(this._componentRef.instance);
            var componentEl = this._componentRef.location.nativeElement;
            componentEl.parentNode.removeChild(componentEl);
            if (this._contentRef.componentRef) {
                this._contentRef.componentRef.destroy();
            }
            this._componentRef.destroy();
            if (this._viewContainerRef && this._contentRef.viewRef) {
                this._viewContainerRef.remove(this._viewContainerRef.indexOf(this._contentRef.viewRef));
            }
            if (this._contentRef.viewRef) {
                this._contentRef.viewRef.destroy();
            }
            // this._viewContainerRef.remove(this._viewContainerRef.indexOf(this._componentRef.hostView));
            //
            // if (this._contentRef.viewRef && this._viewContainerRef.indexOf(this._contentRef.viewRef) !== -1) {
            //   this._viewContainerRef.remove(this._viewContainerRef.indexOf(this._contentRef.viewRef));
            // }
            this._contentRef = null;
            this._componentRef = null;
            this._removeGlobalListener();
            this.onHidden.emit();
            return this;
        };
        ComponentLoader.prototype.toggle = function () {
            if (this.isShown) {
                this.hide();
                return;
            }
            this.show();
        };
        ComponentLoader.prototype.dispose = function () {
            if (this.isShown) {
                this.hide();
            }
            this._unsubscribePositioning();
            if (this._unregisterListenersFn) {
                this._unregisterListenersFn();
            }
        };
        ComponentLoader.prototype.listen = function (listenOpts) {
            var _this = this;
            this.triggers = listenOpts.triggers || this.triggers;
            this._listenOpts.outsideClick = listenOpts.outsideClick;
            listenOpts.target = listenOpts.target || this._elementRef.nativeElement;
            var hide = (this._listenOpts.hide = function () {
                return listenOpts.hide ? listenOpts.hide() : void _this.hide();
            });
            var show = (this._listenOpts.show = function (registerHide) {
                listenOpts.show ? listenOpts.show(registerHide) : _this.show(registerHide);
                registerHide();
            });
            var toggle = function (registerHide) {
                _this.isShown ? hide() : show(registerHide);
            };
            this._unregisterListenersFn = listenToTriggersV2(this._renderer, {
                target: listenOpts.target,
                triggers: listenOpts.triggers,
                show: show,
                hide: hide,
                toggle: toggle
            });
            return this;
        };
        ComponentLoader.prototype._removeGlobalListener = function () {
            if (this._globalListener) {
                this._globalListener();
                this._globalListener = null;
            }
        };
        ComponentLoader.prototype.attachInline = function (vRef, template) {
            this._inlineViewRef = vRef.createEmbeddedView(template);
            return this;
        };
        ComponentLoader.prototype._registerOutsideClick = function () {
            var _this = this;
            if (!this._componentRef || !this._componentRef.location) {
                return;
            }
            // why: should run after first event bubble
            if (this._listenOpts.outsideClick) {
                var target_1 = this._componentRef.location.nativeElement;
                setTimeout(function () {
                    _this._globalListener = registerOutsideClick(_this._renderer, {
                        targets: [target_1, _this._elementRef.nativeElement],
                        outsideClick: _this._listenOpts.outsideClick,
                        hide: function () { return _this._listenOpts.hide(); }
                    });
                });
            }
        };
        ComponentLoader.prototype.getInnerComponent = function () {
            return this._innerComponent;
        };
        ComponentLoader.prototype._subscribePositioning = function () {
            var _this = this;
            if (this._zoneSubscription || !this.attachment) {
                return;
            }
            this._zoneSubscription = this._ngZone.onStable.subscribe(function () {
                if (!_this._componentRef) {
                    return;
                }
                _this._posService.position({
                    element: _this._componentRef.location,
                    target: _this._elementRef,
                    attachment: _this.attachment,
                    appendToBody: _this.container === 'body'
                });
            });
        };
        ComponentLoader.prototype._unsubscribePositioning = function () {
            if (!this._zoneSubscription) {
                return;
            }
            this._zoneSubscription.unsubscribe();
            this._zoneSubscription = null;
        };
        ComponentLoader.prototype._getContentRef = function (content, context, initialState) {
            if (!content) {
                return new ContentRef([]);
            }
            if (content instanceof core.TemplateRef) {
                if (this._viewContainerRef) {
                    var _viewRef = this._viewContainerRef
                        .createEmbeddedView(content, context);
                    _viewRef.markForCheck();
                    return new ContentRef([_viewRef.rootNodes], _viewRef);
                }
                var viewRef = content.createEmbeddedView({});
                this._applicationRef.attachView(viewRef);
                return new ContentRef([viewRef.rootNodes], viewRef);
            }
            if (typeof content === 'function') {
                var contentCmptFactory = this._componentFactoryResolver.resolveComponentFactory(content);
                var modalContentInjector = core.ReflectiveInjector.resolveAndCreate(this._providers.slice(), this._injector);
                var componentRef = contentCmptFactory.create(modalContentInjector);
                Object.assign(componentRef.instance, initialState);
                this._applicationRef.attachView(componentRef.hostView);
                return new ContentRef([[componentRef.location.nativeElement]], componentRef.hostView, componentRef);
            }
            return new ContentRef([[this._renderer.createText("" + content)]]);
        };
        return ComponentLoader;
    }());

    /**
     * @copyright Valor Software
     * @copyright Angular ng-bootstrap team
     */
    // previous version:
    // https://github.com/angular-ui/bootstrap/blob/07c31d0731f7cb068a1932b8e01d2312b796b4ec/src/position/position.js
    // tslint:disable
    var Positioning = (function () {
        function Positioning() {
        }
        Positioning.prototype.position = function (element, round) {
            if (round === void 0) { round = true; }
            var elPosition;
            var parentOffset = {
                width: 0,
                height: 0,
                top: 0,
                bottom: 0,
                left: 0,
                right: 0
            };
            if (this.getStyle(element, 'position') === 'fixed') {
                var bcRect = element.getBoundingClientRect();
                elPosition = {
                    width: bcRect.width,
                    height: bcRect.height,
                    top: bcRect.top,
                    bottom: bcRect.bottom,
                    left: bcRect.left,
                    right: bcRect.right
                };
            }
            else {
                var offsetParentEl = this.offsetParent(element);
                elPosition = this.offset(element, false);
                if (offsetParentEl !== document.documentElement) {
                    parentOffset = this.offset(offsetParentEl, false);
                }
                parentOffset.top += offsetParentEl.clientTop;
                parentOffset.left += offsetParentEl.clientLeft;
            }
            elPosition.top -= parentOffset.top;
            elPosition.bottom -= parentOffset.top;
            elPosition.left -= parentOffset.left;
            elPosition.right -= parentOffset.left;
            if (round) {
                elPosition.top = Math.round(elPosition.top);
                elPosition.bottom = Math.round(elPosition.bottom);
                elPosition.left = Math.round(elPosition.left);
                elPosition.right = Math.round(elPosition.right);
            }
            return elPosition;
        };
        Positioning.prototype.offset = function (element, round) {
            if (round === void 0) { round = true; }
            var elBcr = element.getBoundingClientRect();
            var viewportOffset = {
                top: window.pageYOffset - document.documentElement.clientTop,
                left: window.pageXOffset - document.documentElement.clientLeft
            };
            var elOffset = {
                height: elBcr.height || element.offsetHeight,
                width: elBcr.width || element.offsetWidth,
                top: elBcr.top + viewportOffset.top,
                bottom: elBcr.bottom + viewportOffset.top,
                left: elBcr.left + viewportOffset.left,
                right: elBcr.right + viewportOffset.left
            };
            if (round) {
                elOffset.height = Math.round(elOffset.height);
                elOffset.width = Math.round(elOffset.width);
                elOffset.top = Math.round(elOffset.top);
                elOffset.bottom = Math.round(elOffset.bottom);
                elOffset.left = Math.round(elOffset.left);
                elOffset.right = Math.round(elOffset.right);
            }
            return elOffset;
        };
        Positioning.prototype.positionElements = function (hostElement, targetElement, placement, appendToBody) {
            var hostElPosition = appendToBody
                ? this.offset(hostElement, false)
                : this.position(hostElement, false);
            var targetElStyles = this.getAllStyles(targetElement);
            var shiftWidth = {
                left: hostElPosition.left,
                center: hostElPosition.left +
                    hostElPosition.width / 2 -
                    targetElement.offsetWidth / 2,
                right: hostElPosition.left + hostElPosition.width
            };
            var shiftHeight = {
                top: hostElPosition.top,
                center: hostElPosition.top +
                    hostElPosition.height / 2 -
                    targetElement.offsetHeight / 2,
                bottom: hostElPosition.top + hostElPosition.height
            };
            var targetElBCR = targetElement.getBoundingClientRect();
            var placementPrimary = placement.split(' ')[0] || 'top';
            var placementSecondary = placement.split(' ')[1] || 'center';
            var targetElPosition = {
                height: targetElBCR.height || targetElement.offsetHeight,
                width: targetElBCR.width || targetElement.offsetWidth,
                top: 0,
                bottom: targetElBCR.height || targetElement.offsetHeight,
                left: 0,
                right: targetElBCR.width || targetElement.offsetWidth
            };
            if (placementPrimary === 'auto') {
                var newPlacementPrimary = this.autoPosition(targetElPosition, hostElPosition, targetElement, placementSecondary);
                if (!newPlacementPrimary)
                    newPlacementPrimary = this.autoPosition(targetElPosition, hostElPosition, targetElement);
                if (newPlacementPrimary)
                    placementPrimary = newPlacementPrimary;
                targetElement.classList.add(placementPrimary);
            }
            switch (placementPrimary) {
                case 'top':
                    targetElPosition.top =
                        hostElPosition.top -
                            (targetElement.offsetHeight +
                                parseFloat(targetElStyles.marginBottom));
                    targetElPosition.bottom +=
                        hostElPosition.top - targetElement.offsetHeight;
                    targetElPosition.left = shiftWidth[placementSecondary];
                    targetElPosition.right += shiftWidth[placementSecondary];
                    break;
                case 'bottom':
                    targetElPosition.top = shiftHeight[placementPrimary];
                    targetElPosition.bottom += shiftHeight[placementPrimary];
                    targetElPosition.left = shiftWidth[placementSecondary];
                    targetElPosition.right += shiftWidth[placementSecondary];
                    break;
                case 'left':
                    targetElPosition.top = shiftHeight[placementSecondary];
                    targetElPosition.bottom += shiftHeight[placementSecondary];
                    targetElPosition.left =
                        hostElPosition.left -
                            (targetElement.offsetWidth + parseFloat(targetElStyles.marginRight));
                    targetElPosition.right +=
                        hostElPosition.left - targetElement.offsetWidth;
                    break;
                case 'right':
                    targetElPosition.top = shiftHeight[placementSecondary];
                    targetElPosition.bottom += shiftHeight[placementSecondary];
                    targetElPosition.left = shiftWidth[placementPrimary];
                    targetElPosition.right += shiftWidth[placementPrimary];
                    break;
            }
            targetElPosition.top = Math.round(targetElPosition.top);
            targetElPosition.bottom = Math.round(targetElPosition.bottom);
            targetElPosition.left = Math.round(targetElPosition.left);
            targetElPosition.right = Math.round(targetElPosition.right);
            return targetElPosition;
        };
        Positioning.prototype.autoPosition = function (targetElPosition, hostElPosition, targetElement, preferredPosition) {
            if ((!preferredPosition || preferredPosition === 'right') &&
                targetElPosition.left + hostElPosition.left - targetElement.offsetWidth <
                    0) {
                return 'right';
            }
            else if ((!preferredPosition || preferredPosition === 'top') &&
                targetElPosition.bottom +
                    hostElPosition.bottom +
                    targetElement.offsetHeight >
                    window.innerHeight) {
                return 'top';
            }
            else if ((!preferredPosition || preferredPosition === 'bottom') &&
                targetElPosition.top + hostElPosition.top - targetElement.offsetHeight < 0) {
                return 'bottom';
            }
            else if ((!preferredPosition || preferredPosition === 'left') &&
                targetElPosition.right +
                    hostElPosition.right +
                    targetElement.offsetWidth >
                    window.innerWidth) {
                return 'left';
            }
            return null;
        };
        Positioning.prototype.getAllStyles = function (element) {
            return window.getComputedStyle(element);
        };
        Positioning.prototype.getStyle = function (element, prop) {
            return this.getAllStyles(element)[prop];
        };
        Positioning.prototype.isStaticPositioned = function (element) {
            return (this.getStyle(element, 'position') || 'static') === 'static';
        };
        Positioning.prototype.offsetParent = function (element) {
            var offsetParentEl = element.offsetParent || document.documentElement;
            while (offsetParentEl &&
                offsetParentEl !== document.documentElement &&
                this.isStaticPositioned(offsetParentEl)) {
                offsetParentEl = offsetParentEl.offsetParent;
            }
            return offsetParentEl || document.documentElement;
        };
        return Positioning;
    }());
    var positionService = new Positioning();
    function positionElements(hostElement, targetElement, placement, appendToBody) {
        var pos = positionService.positionElements(hostElement, targetElement, placement, appendToBody);
        targetElement.style.top = pos.top + "px";
        targetElement.style.left = pos.left + "px";
    }

    var PositioningService = (function () {
        function PositioningService() {
        }
        PositioningService.prototype.position = function (options) {
            var element = options.element, target = options.target, attachment = options.attachment, appendToBody = options.appendToBody;
            positionElements(_getHtmlElement(target), _getHtmlElement(element), attachment, appendToBody);
        };
        PositioningService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        PositioningService.ctorParameters = function () { return []; };
        return PositioningService;
    }());
    function _getHtmlElement(element) {
        // it means that we got a selector
        if (typeof element === 'string') {
            return document.querySelector(element);
        }
        if (element instanceof core.ElementRef) {
            return element.nativeElement;
        }
        return element;
    }

    var ComponentLoaderFactory = (function () {
        function ComponentLoaderFactory(_componentFactoryResolver, _ngZone, _injector, _posService, _applicationRef) {
            this._componentFactoryResolver = _componentFactoryResolver;
            this._ngZone = _ngZone;
            this._injector = _injector;
            this._posService = _posService;
            this._applicationRef = _applicationRef;
        }
        /**
         *
         * @param _elementRef
         * @param _viewContainerRef
         * @param _renderer
         * @returns {ComponentLoader}
         */
        ComponentLoaderFactory.prototype.createLoader = function (_elementRef, _viewContainerRef, _renderer) {
            return new ComponentLoader(_viewContainerRef, _renderer, _elementRef, this._injector, this._componentFactoryResolver, this._ngZone, this._applicationRef, this._posService);
        };
        ComponentLoaderFactory.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        ComponentLoaderFactory.ctorParameters = function () { return [
            { type: core.ComponentFactoryResolver, },
            { type: core.NgZone, },
            { type: core.Injector, },
            { type: PositioningService, },
            { type: core.ApplicationRef, },
        ]; };
        return ComponentLoaderFactory;
    }());

    /** Default dropdown configuration */
    var BsDropdownConfig = (function () {
        function BsDropdownConfig() {
            /** default dropdown auto closing behavior */
            this.autoClose = true;
        }
        BsDropdownConfig.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        BsDropdownConfig.ctorParameters = function () { return []; };
        return BsDropdownConfig;
    }());

    var BsDropdownState = (function () {
        function BsDropdownState() {
            var _this = this;
            this.direction = 'down';
            this.isOpenChange = new core.EventEmitter();
            this.isDisabledChange = new core.EventEmitter();
            this.toggleClick = new core.EventEmitter();
            this.dropdownMenu = new Promise(function (resolve) {
                _this.resolveDropdownMenu = resolve;
            });
        }
        BsDropdownState.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        BsDropdownState.ctorParameters = function () { return []; };
        return BsDropdownState;
    }());

    /*tslint:disable */
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * JS version of browser APIs. This library can only run in the browser.
     */
    var win = (typeof window !== 'undefined' && window) || {};
    var document$1 = win.document;
    var location = win.location;
    var gc = win['gc'] ? function () { return win['gc'](); } : function () { return null; };
    var performance = win['performance'] ? win['performance'] : null;
    var Event$1 = win['Event'];
    var MouseEvent = win['MouseEvent'];
    var KeyboardEvent$1 = win['KeyboardEvent'];
    var EventTarget = win['EventTarget'];
    var History = win['History'];
    var Location = win['Location'];
    var EventListener = win['EventListener'];

    var guessedVersion;
    function _guessBsVersion() {
        if (typeof document === 'undefined') {
            return null;
        }
        var spanEl = document.createElement('span');
        spanEl.innerText = 'test bs version';
        document.body.appendChild(spanEl);
        spanEl.classList.add('d-none');
        var rect = spanEl.getBoundingClientRect();
        document.body.removeChild(spanEl);
        if (!rect) {
            return 'bs3';
        }
        return rect.top === 0 ? 'bs4' : 'bs3';
    }
    // todo: in ngx-bootstrap, bs4 will became a default one
    function isBs3() {
        if (typeof win === 'undefined') {
            return true;
        }
        if (typeof win.__theme === 'undefined') {
            if (guessedVersion) {
                return guessedVersion === 'bs3';
            }
            guessedVersion = _guessBsVersion();
            return guessedVersion === 'bs3';
        }
        return win.__theme !== 'bs4';
    }

    var BsDropdownContainerComponent = (function () {
        function BsDropdownContainerComponent(_state, cd, _renderer, _element) {
            var _this = this;
            this._state = _state;
            this.cd = cd;
            this._renderer = _renderer;
            this.isOpen = false;
            this._subscription = _state.isOpenChange.subscribe(function (value) {
                _this.isOpen = value;
                var dropdown = _element.nativeElement.querySelector('.dropdown-menu');
                if (dropdown && !isBs3()) {
                    _this._renderer.addClass(dropdown, 'show');
                    if (dropdown.classList.contains('dropdown-menu-right')) {
                        _this._renderer.setStyle(dropdown, 'left', 'auto');
                        _this._renderer.setStyle(dropdown, 'right', '0');
                    }
                    if (_this.direction === 'up') {
                        _this._renderer.setStyle(dropdown, 'top', 'auto');
                        _this._renderer.setStyle(dropdown, 'transform', 'translateY(-101%)');
                    }
                }
                _this.cd.markForCheck();
                _this.cd.detectChanges();
            });
        }
        Object.defineProperty(BsDropdownContainerComponent.prototype, "direction", {
            get: function () {
                return this._state.direction;
            },
            enumerable: true,
            configurable: true
        });
        BsDropdownContainerComponent.prototype.ngOnDestroy = function () {
            this._subscription.unsubscribe();
        };
        BsDropdownContainerComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'bs-dropdown-container',
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        host: {
                            style: 'display:block;position: absolute;'
                        },
                        template: "\n    <div [class.dropup]=\"direction === 'up'\"\n         [class.dropdown]=\"direction === 'down'\"\n         [class.show]=\"isOpen\"\n         [class.open]=\"isOpen\"><ng-content></ng-content></div>\n  "
                    },] },
        ];
        /** @nocollapse */
        BsDropdownContainerComponent.ctorParameters = function () { return [
            { type: BsDropdownState, },
            { type: core.ChangeDetectorRef, },
            { type: core.Renderer2, },
            { type: core.ElementRef, },
        ]; };
        return BsDropdownContainerComponent;
    }());

    // tslint:disable:max-file-line-count
    var BsDropdownDirective = (function () {
        function BsDropdownDirective(_elementRef, _renderer, _viewContainerRef, _cis, _config, _state) {
            this._elementRef = _elementRef;
            this._renderer = _renderer;
            this._viewContainerRef = _viewContainerRef;
            this._cis = _cis;
            this._config = _config;
            this._state = _state;
            // todo: move to component loader
            this._isInlineOpen = false;
            this._subscriptions = [];
            this._isInited = false;
            // set initial dropdown state from config
            this._state.autoClose = this._config.autoClose;
            // create dropdown component loader
            this._dropdown = this._cis
                .createLoader(this._elementRef, this._viewContainerRef, this._renderer)
                .provide({ provide: BsDropdownState, useValue: this._state });
            this.onShown = this._dropdown.onShown;
            this.onHidden = this._dropdown.onHidden;
            this.isOpenChange = this._state.isOpenChange;
        }
        Object.defineProperty(BsDropdownDirective.prototype, "autoClose", {
            get: function () {
                return this._state.autoClose;
            },
            /**
             * Indicates that dropdown will be closed on item or document click,
             * and after pressing ESC
             */
            set: function (value) {
                this._state.autoClose = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BsDropdownDirective.prototype, "isDisabled", {
            get: function () {
                return this._isDisabled;
            },
            /**
             * Disables dropdown toggle and hides dropdown menu if opened
             */
            set: function (value) {
                this._isDisabled = value;
                this._state.isDisabledChange.emit(value);
                if (value) {
                    this.hide();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BsDropdownDirective.prototype, "isOpen", {
            /**
             * Returns whether or not the popover is currently being shown
             */
            get: function () {
                if (this._showInline) {
                    return this._isInlineOpen;
                }
                return this._dropdown.isShown;
            },
            set: function (value) {
                if (value) {
                    this.show();
                }
                else {
                    this.hide();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BsDropdownDirective.prototype, "isBs4", {
            get: function () {
                return !isBs3();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BsDropdownDirective.prototype, "_showInline", {
            get: function () {
                return !this.container;
            },
            enumerable: true,
            configurable: true
        });
        BsDropdownDirective.prototype.ngOnInit = function () {
            var _this = this;
            // fix: seems there are an issue with `routerLinkActive`
            // which result in duplicated call ngOnInit without call to ngOnDestroy
            // read more: https://github.com/valor-software/ngx-bootstrap/issues/1885
            if (this._isInited) {
                return;
            }
            this._isInited = true;
            // attach DOM listeners
            this._dropdown.listen({
                // because of dropdown inline mode
                outsideClick: false,
                triggers: this.triggers,
                show: function () { return _this.show(); }
            });
            // toggle visibility on toggle element click
            this._subscriptions.push(this._state.toggleClick.subscribe(function (value) { return _this.toggle(value); }));
            // hide dropdown if set disabled while opened
            this._subscriptions.push(this._state.isDisabledChange
                .filter(function (value) { return value; })
                .subscribe(function (value) { return _this.hide(); }));
        };
        /**
         * Opens an element’s popover. This is considered a “manual” triggering of
         * the popover.
         */
        BsDropdownDirective.prototype.show = function () {
            var _this = this;
            if (this.isOpen || this.isDisabled) {
                return;
            }
            if (this._showInline) {
                if (!this._inlinedMenu) {
                    this._state.dropdownMenu.then(function (dropdownMenu) {
                        _this._dropdown.attachInline(dropdownMenu.viewContainer, dropdownMenu.templateRef);
                        _this._inlinedMenu = _this._dropdown._inlineViewRef;
                        _this.addBs4Polyfills();
                    })
                        .catch();
                }
                this.addBs4Polyfills();
                this._isInlineOpen = true;
                this.onShown.emit(true);
                this._state.isOpenChange.emit(true);
                return;
            }
            this._state.dropdownMenu.then(function (dropdownMenu) {
                // check direction in which dropdown should be opened
                var _dropup = _this.dropup ||
                    (typeof _this.dropup !== 'undefined' && _this.dropup);
                _this._state.direction = _dropup ? 'up' : 'down';
                var _placement = _this.placement || (_dropup ? 'top left' : 'bottom left');
                // show dropdown
                _this._dropdown
                    .attach(BsDropdownContainerComponent)
                    .to(_this.container)
                    .position({ attachment: _placement })
                    .show({
                    content: dropdownMenu.templateRef,
                    placement: _placement
                });
                _this._state.isOpenChange.emit(true);
            })
                .catch();
        };
        /**
         * Closes an element’s popover. This is considered a “manual” triggering of
         * the popover.
         */
        BsDropdownDirective.prototype.hide = function () {
            if (!this.isOpen) {
                return;
            }
            if (this._showInline) {
                this.removeShowClass();
                this.removeDropupStyles();
                this._isInlineOpen = false;
                this.onHidden.emit(true);
            }
            else {
                this._dropdown.hide();
            }
            this._state.isOpenChange.emit(false);
        };
        /**
         * Toggles an element’s popover. This is considered a “manual” triggering of
         * the popover. With parameter <code>true</code> allows toggling, with parameter <code>false</code>
         * only hides opened dropdown. Parameter usage will be removed in ngx-bootstrap v3
         */
        BsDropdownDirective.prototype.toggle = function (value) {
            if (this.isOpen || !value) {
                return this.hide();
            }
            return this.show();
        };
        BsDropdownDirective.prototype.ngOnDestroy = function () {
            // clean up subscriptions and destroy dropdown
            for (var _i = 0, _a = this._subscriptions; _i < _a.length; _i++) {
                var sub = _a[_i];
                sub.unsubscribe();
            }
            this._dropdown.dispose();
        };
        BsDropdownDirective.prototype.addBs4Polyfills = function () {
            if (!isBs3()) {
                this.addShowClass();
                this.checkRightAlignment();
                this.addDropupStyles();
            }
        };
        BsDropdownDirective.prototype.addShowClass = function () {
            if (this._inlinedMenu && this._inlinedMenu.rootNodes[0]) {
                this._renderer.addClass(this._inlinedMenu.rootNodes[0], 'show');
            }
        };
        BsDropdownDirective.prototype.removeShowClass = function () {
            if (this._inlinedMenu && this._inlinedMenu.rootNodes[0]) {
                this._renderer.removeClass(this._inlinedMenu.rootNodes[0], 'show');
            }
        };
        BsDropdownDirective.prototype.checkRightAlignment = function () {
            if (this._inlinedMenu && this._inlinedMenu.rootNodes[0]) {
                var isRightAligned = this._inlinedMenu.rootNodes[0].classList.contains('dropdown-menu-right');
                this._renderer.setStyle(this._inlinedMenu.rootNodes[0], 'left', isRightAligned ? 'auto' : '0');
                this._renderer.setStyle(this._inlinedMenu.rootNodes[0], 'right', isRightAligned ? '0' : 'auto');
            }
        };
        BsDropdownDirective.prototype.addDropupStyles = function () {
            if (this._inlinedMenu && this._inlinedMenu.rootNodes[0]) {
                // a little hack to not break support of bootstrap 4 beta
                this._renderer.setStyle(this._inlinedMenu.rootNodes[0], 'top', this.dropup ? 'auto' : '100%');
                this._renderer.setStyle(this._inlinedMenu.rootNodes[0], 'transform', this.dropup ? 'translateY(-101%)' : 'translateY(0)');
            }
        };
        BsDropdownDirective.prototype.removeDropupStyles = function () {
            if (this._inlinedMenu && this._inlinedMenu.rootNodes[0]) {
                this._renderer.removeStyle(this._inlinedMenu.rootNodes[0], 'top');
                this._renderer.removeStyle(this._inlinedMenu.rootNodes[0], 'transform');
            }
        };
        BsDropdownDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[bsDropdown],[dropdown]',
                        exportAs: 'bs-dropdown',
                        providers: [BsDropdownState],
                        host: {
                            '[class.dropup]': 'dropup',
                            '[class.open]': 'isOpen',
                            '[class.show]': 'isOpen && isBs4'
                        }
                    },] },
        ];
        /** @nocollapse */
        BsDropdownDirective.ctorParameters = function () { return [
            { type: core.ElementRef, },
            { type: core.Renderer2, },
            { type: core.ViewContainerRef, },
            { type: ComponentLoaderFactory, },
            { type: BsDropdownConfig, },
            { type: BsDropdownState, },
        ]; };
        BsDropdownDirective.propDecorators = {
            'placement': [{ type: core.Input },],
            'triggers': [{ type: core.Input },],
            'container': [{ type: core.Input },],
            'dropup': [{ type: core.Input },],
            'autoClose': [{ type: core.Input },],
            'isDisabled': [{ type: core.Input },],
            'isOpen': [{ type: core.Input },],
            'isOpenChange': [{ type: core.Output },],
            'onShown': [{ type: core.Output },],
            'onHidden': [{ type: core.Output },],
        };
        return BsDropdownDirective;
    }());

    var BsDropdownMenuDirective = (function () {
        function BsDropdownMenuDirective(_state, _viewContainer, _templateRef) {
            _state.resolveDropdownMenu({
                templateRef: _templateRef,
                viewContainer: _viewContainer
            });
        }
        BsDropdownMenuDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[bsDropdownMenu],[dropdownMenu]',
                        exportAs: 'bs-dropdown-menu'
                    },] },
        ];
        /** @nocollapse */
        BsDropdownMenuDirective.ctorParameters = function () { return [
            { type: BsDropdownState, },
            { type: core.ViewContainerRef, },
            { type: core.TemplateRef, },
        ]; };
        return BsDropdownMenuDirective;
    }());

    var BsDropdownToggleDirective = (function () {
        function BsDropdownToggleDirective(_state, _element) {
            var _this = this;
            this._state = _state;
            this._element = _element;
            this.isDisabled = null;
            this._subscriptions = [];
            // sync is open value with state
            this._subscriptions.push(this._state.isOpenChange.subscribe(function (value) { return (_this.isOpen = value); }));
            // populate disabled state
            this._subscriptions.push(this._state.isDisabledChange.subscribe(function (value) { return (_this.isDisabled = value || null); }));
        }
        BsDropdownToggleDirective.prototype.onClick = function () {
            if (this.isDisabled) {
                return;
            }
            this._state.toggleClick.emit(true);
        };
        BsDropdownToggleDirective.prototype.onDocumentClick = function (event) {
            if (this._state.autoClose &&
                event.button !== 2 &&
                !this._element.nativeElement.contains(event.target)) {
                this._state.toggleClick.emit(false);
            }
        };
        BsDropdownToggleDirective.prototype.onEsc = function () {
            if (this._state.autoClose) {
                this._state.toggleClick.emit(false);
            }
        };
        BsDropdownToggleDirective.prototype.ngOnDestroy = function () {
            for (var _i = 0, _a = this._subscriptions; _i < _a.length; _i++) {
                var sub = _a[_i];
                sub.unsubscribe();
            }
        };
        BsDropdownToggleDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[bsDropdownToggle],[dropdownToggle]',
                        exportAs: 'bs-dropdown-toggle',
                        host: {
                            '[attr.aria-haspopup]': 'true'
                        }
                    },] },
        ];
        /** @nocollapse */
        BsDropdownToggleDirective.ctorParameters = function () { return [
            { type: BsDropdownState, },
            { type: core.ElementRef, },
        ]; };
        BsDropdownToggleDirective.propDecorators = {
            'isDisabled': [{ type: core.HostBinding, args: ['attr.disabled',] },],
            'isOpen': [{ type: core.HostBinding, args: ['attr.aria-expanded',] },],
            'onClick': [{ type: core.HostListener, args: ['click', [],] },],
            'onDocumentClick': [{ type: core.HostListener, args: ['document:click', ['$event'],] },],
            'onEsc': [{ type: core.HostListener, args: ['keyup.esc',] },],
        };
        return BsDropdownToggleDirective;
    }());

    var BsDropdownModule = (function () {
        function BsDropdownModule() {
        }
        BsDropdownModule.forRoot = function (config) {
            return {
                ngModule: BsDropdownModule,
                providers: [
                    ComponentLoaderFactory,
                    PositioningService,
                    BsDropdownState,
                    {
                        provide: BsDropdownConfig,
                        useValue: config ? config : { autoClose: true }
                    }
                ]
            };
        };
        BsDropdownModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            BsDropdownMenuDirective,
                            BsDropdownToggleDirective,
                            BsDropdownContainerComponent,
                            BsDropdownDirective
                        ],
                        exports: [
                            BsDropdownMenuDirective,
                            BsDropdownToggleDirective,
                            BsDropdownDirective
                        ],
                        entryComponents: [BsDropdownContainerComponent]
                    },] },
        ];
        /** @nocollapse */
        BsDropdownModule.ctorParameters = function () { return []; };
        return BsDropdownModule;
    }());

    var __decorate$1 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    /**
     * A module containing objects associated with action components
     */
    var ActionModule = /** @class */ (function () {
        function ActionModule() {
        }
        ActionModule = __decorate$1([
            core.NgModule({
                imports: [
                    BsDropdownModule.forRoot(),
                    common.CommonModule,
                    forms.FormsModule
                ],
                declarations: [ActionComponent],
                exports: [ActionComponent],
                providers: [BsDropdownConfig]
            })
        ], ActionModule);
        return ActionModule;
    }());

    var __decorate$2 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata$1 = (undefined && undefined.__metadata) || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    /**
     * Card base component
     *
     * For customization, use the templates named headerTemplate and footerTemplate.
     */
    var CardBase = /** @class */ (function () {
        /**
         * The default constructor
         */
        function CardBase() {
        }
        __decorate$2([
            core.Input(),
            __metadata$1("design:type", core.TemplateRef)
        ], CardBase.prototype, "footerTemplate", void 0);
        __decorate$2([
            core.Input(),
            __metadata$1("design:type", core.TemplateRef)
        ], CardBase.prototype, "headerTemplate", void 0);
        return CardBase;
    }());

    /**
     * A config containing properties for cards
     */
    var CardConfigBase = /** @class */ (function () {
        function CardConfigBase() {
        }
        return CardConfigBase;
    }());

    /**
     * An object containing card action properties
     */
    var CardAction = /** @class */ (function () {
        function CardAction() {
        }
        return CardAction;
    }());

    var __extends = (undefined && undefined.__extends) || (function () {
        var extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * A config containing properties for card
     */
    var CardConfig = /** @class */ (function (_super) {
        __extends(CardConfig, _super);
        function CardConfig() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return CardConfig;
    }(CardConfigBase));

    /*
     * An object containing filter positions
     */
    var CardFilterPosition = /** @class */ (function () {
        function CardFilterPosition() {
        }
        /**
         * Footer position
         */
        CardFilterPosition.FOOTER = 'footer';
        /**
         * Header position
         */
        CardFilterPosition.HEADER = 'header';
        return CardFilterPosition;
    }());

    var __extends$1 = (undefined && undefined.__extends) || (function () {
        var extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var __decorate$3 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata$2 = (undefined && undefined.__metadata) || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    /**
     * Card component
     *
     * For customization, use the templates named headerTemplate and footerTemplate.
     *
     * Usage:
     * <br/><code>import { BasicCardModule } from 'patternfly-ng/card';</code>
     *
     * Or:
     * <br/><code>import { BasicCardModule } from 'patternfly-ng';</code>
     */
    var CardComponent = /** @class */ (function (_super) {
        __extends$1(CardComponent, _super);
        /**
         * The default constructor
         */
        function CardComponent() {
            var _this = _super.call(this) || this;
            /**
             * The event emitted when an action is selected
             */
            _this.onActionSelect = new core.EventEmitter();
            /**
             * The event emitted when a filter is selected
             */
            _this.onFilterSelect = new core.EventEmitter();
            _this.defaultConfig = {
                filterPosition: CardFilterPosition.FOOTER,
                noPadding: false,
                titleBorder: true,
                topBorder: true
            };
            return _this;
        }
        // Initialization
        /**
         * Setup component configuration upon initialization
         */
        CardComponent.prototype.ngOnInit = function () {
            this.setupConfig();
        };
        /**
         * Check if the component config has changed
         */
        CardComponent.prototype.ngDoCheck = function () {
            // Do a deep compare on config
            if (!lodash.isEqual(this.config, this.prevConfig)) {
                this.setupConfig();
            }
        };
        /**
         * Set up default config
         */
        CardComponent.prototype.setupConfig = function () {
            if (this.config !== undefined) {
                lodash.defaults(this.config, this.defaultConfig);
            }
            else {
                this.config = lodash.cloneDeep(this.defaultConfig);
            }
            this.prevConfig = lodash.cloneDeep(this.config);
        };
        // Actions
        /**
         * Handle the event emitted when an action is selected
         *
         * @param {CardAction} $event The emitted CardAction object
         */
        CardComponent.prototype.handleActionSelect = function ($event) {
            this.onActionSelect.emit($event);
        };
        /**
         * Handle the event emitted when a filter is selected
         *
         * @param {CardFilter} $event The emitted CardFilter object
         */
        CardComponent.prototype.handleFilterSelect = function ($event) {
            this.onFilterSelect.emit($event);
        };
        Object.defineProperty(CardComponent.prototype, "showFilterInFooter", {
            // Accessors
            /**
             * Indicates that the footer should be shown in the footer
             *
             * @returns {boolean} True if the footer should be shown in the footer
             */
            get: function () {
                return (this.config.filters && this.config.filterPosition
                    && this.config.filterPosition === CardFilterPosition.FOOTER);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CardComponent.prototype, "showFilterInHeader", {
            /**
             * Indicates that the footer should be shown in the header
             *
             * @returns {boolean} True if the footer should be shown in the header
             */
            get: function () {
                return (this.config.filters && this.config.filterPosition
                    && this.config.filterPosition === CardFilterPosition.HEADER);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CardComponent.prototype, "showFooter", {
            /**
             * Indicates that the footer should be shown
             *
             * @returns {boolean} True if the footer should be shown
             */
            get: function () {
                return (this.footerTemplate !== undefined || this.showFilterInFooter || this.config.action !== undefined);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CardComponent.prototype, "showHeader", {
            /**
             * Indicates that the header should be shown
             *
             * @returns {boolean} True if the header should be shown
             */
            get: function () {
                return (this.headerTemplate !== undefined || this.showFilterInHeader || this.config.title !== undefined);
            },
            enumerable: true,
            configurable: true
        });
        __decorate$3([
            core.Input(),
            __metadata$2("design:type", CardConfig)
        ], CardComponent.prototype, "config", void 0);
        __decorate$3([
            core.Output('onActionSelect'),
            __metadata$2("design:type", Object)
        ], CardComponent.prototype, "onActionSelect", void 0);
        __decorate$3([
            core.Output('onFilterSelect'),
            __metadata$2("design:type", Object)
        ], CardComponent.prototype, "onFilterSelect", void 0);
        CardComponent = __decorate$3([
            core.Component({
                encapsulation: core.ViewEncapsulation.None,
                selector: 'pfng-card',
                template: "<div class=\"pfng-card card-pf\" [ngClass]=\"{'card-pf-accented': config?.topBorder, 'pfng-card-no-padding': config.noPadding}\"><div [ngClass]=\"config?.titleBorder ? 'card-pf-heading' : 'pfng-card-heading-no-bottom'\" *ngIf=\"showHeader\"><div *ngIf=\"headerTemplate; then showHeaderTemplate else showHeader\"></div><ng-template #showHeaderTemplate><ng-template [ngTemplateOutlet]=\"headerTemplate\"></ng-template></ng-template><ng-template #showHeader><div *ngIf=\"showFilterInHeader\"><pfng-card-filter [filters]=\"config?.filters\" (onFilterSelect)=\"handleFilterSelect($event)\"></pfng-card-filter></div><h2 class=\"card-pf-title\">{{config?.title}}</h2></ng-template></div><span *ngIf=\"config?.subTitle\" class=\"card-pf-subtitle\">{{config?.subTitle}}</span><div class=\"card-pf-body\"><ng-content></ng-content></div><div class=\"card-pf-footer\" *ngIf=\"showFooter\"><div *ngIf=\"footerTemplate; then showFooterTemplate else showFooter\"></div><ng-template #showFooterTemplate><ng-template [ngTemplateOutlet]=\"footerTemplate\"></ng-template></ng-template><ng-template #showFooter><div *ngIf=\"showFilterInFooter\"><pfng-card-filter [filters]=\"config?.filters\" (onFilterSelect)=\"handleFilterSelect($event)\"></pfng-card-filter></div><p><pfng-card-action [action]=\"config?.action\" (onActionSelect)=\"handleActionSelect($event)\"></pfng-card-action></p></ng-template></div></div>"
            }),
            __metadata$2("design:paramtypes", [])
        ], CardComponent);
        return CardComponent;
    }(CardBase));

    /**
     * An object containing card filter properties
     */
    var CardFilter = /** @class */ (function () {
        function CardFilter() {
        }
        return CardFilter;
    }());

    var __decorate$4 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata$3 = (undefined && undefined.__metadata) || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    /**
     * Card filter component
     *
     * Usage:
     * <br/><code>import { CardFilterModule } from 'patternfly-ng/card';</code>
     *
     * Or:
     * <br/><code>import { CardFilterModule } from 'patternfly-ng';</code>
     */
    var CardFilterComponent = /** @class */ (function () {
        /**
         * The default constructor
         */
        function CardFilterComponent() {
            /**
             * The event emitted when a filter is selected
             */
            this.onSelect = new core.EventEmitter();
        }
        // Initialization
        /**
         * Setup component configuration upon initialization
         */
        CardFilterComponent.prototype.ngOnInit = function () {
            var _this = this;
            if (this.filters !== undefined && this.filters.length > 0) {
                this.currentFilter = this.filters[0];
                this.filters.forEach(function (filter$$1) {
                    if (filter$$1.default === true) {
                        _this.currentFilter = filter$$1;
                        return;
                    }
                });
            }
        };
        // Actions
        CardFilterComponent.prototype.select = function ($event) {
            this.currentFilter = $event;
            this.onSelect.emit($event);
        };
        Object.defineProperty(CardFilterComponent.prototype, "currentFilter", {
            // Accessors
            /**
             * Returns the current filter
             *
             * @returns {CardFilter} The current filter
             */
            get: function () {
                return this._currentFilter;
            },
            /**
             * Sets the current filter
             *
             * @param {CardFilter} filter The current filter
             */
            set: function (filter$$1) {
                this._currentFilter = filter$$1;
            },
            enumerable: true,
            configurable: true
        });
        __decorate$4([
            core.Input(),
            __metadata$3("design:type", Array)
        ], CardFilterComponent.prototype, "filters", void 0);
        __decorate$4([
            core.Output('onFilterSelect'),
            __metadata$3("design:type", Object)
        ], CardFilterComponent.prototype, "onSelect", void 0);
        CardFilterComponent = __decorate$4([
            core.Component({
                encapsulation: core.ViewEncapsulation.None,
                selector: 'pfng-card-filter',
                template: "<div class=\"card-pf-time-frame-filter\"><div class=\"dropdown primary-action\" dropdown><button class=\"btn btn-default dropdown-toggle\" type=\"button\" dropdownToggle>{{currentFilter?.title}}<span class=\"caret\"></span></button><ul class=\"dropdown-menu dropdown-menu-right\" role=\"menu\" *dropdownMenu><li role=\"menuitem\" *ngFor=\"let filter of filters\" [ngClass]=\"{'selected': filter === currentFilter}\"><a class=\"dropdown-item\" role=\"menuitem\" tabindex=\"-1\" (click)=\"select(filter)\">{{filter?.title}}</a></li></ul></div></div>"
            }),
            __metadata$3("design:paramtypes", [])
        ], CardFilterComponent);
        return CardFilterComponent;
    }());

    /**
     * A config containing properties for the info status card
     */
    var InfoStatusCardConfig = /** @class */ (function () {
        function InfoStatusCardConfig() {
        }
        return InfoStatusCardConfig;
    }());

    var __decorate$5 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata$4 = (undefined && undefined.__metadata) || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    /**
     * Info Status Card Component
     *
     * Usage:
     * <br/><code>import { InfoStatusCardModule } from 'patternfly-ng/card';</code>
     *
     * Or:
     * <br/><code>import { InfoStatusCardModule } from 'patternfly-ng';</code>
     */
    var InfoStatusCardComponent = /** @class */ (function () {
        /**
         * The default constructor
         */
        function InfoStatusCardComponent() {
            this.defaultConfig = {
                showTopBorder: false,
                htmlContent: true
            };
        }
        /**
         * Setup component configuration upon initialization
         */
        InfoStatusCardComponent.prototype.ngOnInit = function () {
            this.setupConfig();
        };
        /**
         * Check if any component config props have changed
         */
        InfoStatusCardComponent.prototype.ngDoCheck = function () {
            if (!lodash.isEqual(this.config, this.prevConfig)) {
                this.setupConfig();
            }
        };
        /**
         * Set up default config
         */
        InfoStatusCardComponent.prototype.setupConfig = function () {
            if (this.config !== undefined) {
                lodash.defaults(this.config, this.defaultConfig);
            }
            else {
                this.config = lodash.cloneDeep(this.defaultConfig);
            }
            this.prevConfig = lodash.cloneDeep(this.config);
        };
        __decorate$5([
            core.Input('config'),
            __metadata$4("design:type", InfoStatusCardConfig)
        ], InfoStatusCardComponent.prototype, "config", void 0);
        InfoStatusCardComponent = __decorate$5([
            core.Component({
                encapsulation: core.ViewEncapsulation.None,
                selector: 'pfng-info-status-card',
                template: "<div class=\"card-pf pfng-card-info-status\" [class.card-pf-accented]=\"config.showTopBorder\"><div class=\"pfng-card-info-image\"><img *ngIf=\"config.iconImageSrc\" src=\"{{config.iconImageSrc}}\" alt=\"\" class=\"info-img\"> <span class=\"info-icon {{config.iconStyleClass}}\"></span></div><div class=\"pfng-card-info-content\"><h2 *ngIf=\"config.title\" class=\"pfng-card-title\"><a *ngIf=\"config.href\" href=\"{{config.href}}\"><span>{{config.title}}</span> </a><span *ngIf=\"!config.href\"><span>{{config.title}}</span></span></h2><ng-container *ngIf=\"config.htmlContent !== undefined\"><div *ngIf=\"config.htmlContent; then showHtmlContent else showPlainTextContent\"></div><ng-template #showHtmlContent><div [innerHTML]=\"item\" class=\"pfng-card-info-item\" *ngFor=\"let item of config.info\"></div></ng-template><ng-template #showPlainTextContent><div class=\"pfng-card-info-item\" *ngFor=\"let item of config.info\">{{item}}</div></ng-template></ng-container></div></div>"
            }),
            __metadata$4("design:paramtypes", [])
        ], InfoStatusCardComponent);
        return InfoStatusCardComponent;
    }());

    var __decorate$6 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    /**
     * A module containing objects associated with info status card components
     */
    var InfoStatusCardModule = /** @class */ (function () {
        function InfoStatusCardModule() {
        }
        InfoStatusCardModule = __decorate$6([
            core.NgModule({
                imports: [
                    common.CommonModule,
                    forms.FormsModule
                ],
                declarations: [InfoStatusCardComponent],
                exports: [InfoStatusCardComponent]
            })
        ], InfoStatusCardModule);
        return InfoStatusCardModule;
    }());

    var __decorate$7 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata$5 = (undefined && undefined.__metadata) || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    /**
     * Card action component
     *
     * Usage:
     * <br/><code>import { CardActionModule } from 'patternfly-ng/card';</code>
     *
     * Or:
     * <br/><code>import { CardActionModule } from 'patternfly-ng';</code>
     */
    var CardActionComponent = /** @class */ (function () {
        /**
         * The default constructor
         */
        function CardActionComponent() {
            /**
             * The event emitted when a filter is selected
             */
            this.onActionSelect = new core.EventEmitter();
        }
        // Initialization
        /**
         * Setup component configuration upon initialization
         */
        CardActionComponent.prototype.ngOnInit = function () {
        };
        // Actions
        CardActionComponent.prototype.select = function ($event) {
            this.onActionSelect.emit(this.action);
        };
        __decorate$7([
            core.Input(),
            __metadata$5("design:type", CardAction)
        ], CardActionComponent.prototype, "action", void 0);
        __decorate$7([
            core.Output('onActionSelect'),
            __metadata$5("design:type", Object)
        ], CardActionComponent.prototype, "onActionSelect", void 0);
        CardActionComponent = __decorate$7([
            core.Component({
                encapsulation: core.ViewEncapsulation.None,
                selector: 'pfng-card-action',
                template: "<div *ngIf=\"action === undefined || action?.disabled; then showDisabled else showEnabled\"></div><ng-template #showDisabled><span class=\"{{action?.iconStyleClass}} card-pf-footer-text\" *ngIf=\"action?.iconStyleClass\" [ngClass]=\"{'card-pf-link-with-icon': action?.iconStyleClass, 'card-pf-link': !action?.iconStyleClass}\"></span> <span class=\"card-pf-footer-text\" *ngIf=\"action?.hypertext\">{{action?.hypertext}}</span></ng-template><ng-template #showEnabled><a href=\"{{action?.url}}\" *ngIf=\"action?.url\" [ngClass]=\"{'card-pf-link-with-icon': action?.iconStyleClass, 'card-pf-link': !action?.iconStyleClass}\"><span class=\"{{action?.iconStyleClass}} card-pf-footer-text\" *ngIf=\"action?.iconStyleClass\"></span> <span class=\"card-pf-footer-text\" *ngIf=\"action?.hypertext\">{{action?.hypertext}}</span> </a><a *ngIf=\"!action?.url\" [ngClass]=\"{'card-pf-link-with-icon': action?.iconStyleClass, 'card-pf-link': !action?.iconStyleClass}\" (click)=\"select($event)\"><span class=\"{{action?.iconStyleClass}} card-pf-footer-text\" *ngIf=\"action?.iconStyleClass\"></span> <span class=\"card-pf-footer-text\" *ngIf=\"action?.hypertext\">{{action?.hypertext}}</span></a></ng-template>"
            }),
            __metadata$5("design:paramtypes", [])
        ], CardActionComponent);
        return CardActionComponent;
    }());

    var __decorate$8 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    /**
     * A module containing objects associated with card action components
     */
    var CardActionModule = /** @class */ (function () {
        function CardActionModule() {
        }
        CardActionModule = __decorate$8([
            core.NgModule({
                imports: [
                    common.CommonModule,
                    forms.FormsModule
                ],
                declarations: [CardActionComponent],
                exports: [CardActionComponent]
            })
        ], CardActionModule);
        return CardActionModule;
    }());

    var __decorate$9 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    /**
     * A module containing objects associated with card filter components
     */
    var CardFilterModule = /** @class */ (function () {
        function CardFilterModule() {
        }
        CardFilterModule = __decorate$9([
            core.NgModule({
                imports: [
                    BsDropdownModule.forRoot(),
                    common.CommonModule,
                    forms.FormsModule
                ],
                declarations: [CardFilterComponent],
                exports: [CardFilterComponent],
                providers: [BsDropdownConfig]
            })
        ], CardFilterModule);
        return CardFilterModule;
    }());

    var __decorate$a = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    /**
     * A module containing objects associated with basic card components
     */
    var CardModule = /** @class */ (function () {
        function CardModule() {
        }
        CardModule = __decorate$a([
            core.NgModule({
                imports: [
                    CardActionModule,
                    CardFilterModule,
                    common.CommonModule,
                    forms.FormsModule
                ],
                declarations: [CardComponent],
                exports: [CardComponent]
            })
        ], CardModule);
        return CardModule;
    }());

    var __decorate$b = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata$6 = (undefined && undefined.__metadata) || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    /**
     * A module containing objects associated with card components
     *
     * @deprecated Use individual module imports
     *
     * import {
     *   CardModule, // basic card only
     *   InfoStatusCardModule
     * } from 'patternfy/card';
     */
    var CardModule$1 = /** @class */ (function () {
        function CardModule$$1() {
            console.log('patternfly-ng: CardModule is deprecated; use InfoStatusCardModule or CardModule for basic card only');
        }
        CardModule$$1 = __decorate$b([
            core.NgModule({
                imports: [
                    CardModule,
                    CardActionModule,
                    CardFilterModule,
                    common.CommonModule,
                    forms.FormsModule,
                    InfoStatusCardModule
                ],
                exports: [CardComponent, CardFilterComponent, InfoStatusCardComponent]
            }),
            __metadata$6("design:paramtypes", [])
        ], CardModule$$1);
        return CardModule$$1;
    }());

    var __decorate$c = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata$7 = (undefined && undefined.__metadata) || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    /**
     * Chart base
     *
     * Note: In order to use charts, please include the following JavaScript file from patternfly. For example:
     * <code>require('patternfly/dist/js/patternfly-settings');</code>
     */
    var ChartBase = /** @class */ (function () {
        /**
         * Default constructor
         */
        function ChartBase() {
            /**
             * Event emitted with the chart reference after load is complete
             * @type {EventEmitter}
             */
            this.chartLoaded = new core.EventEmitter();
        }
        /**
         * Protected method called when configuration or data changes by any class that inherits from this
         *
         * @param config The config for the c3 chart
         * @param reload True to reload
         */
        ChartBase.prototype.generateChart = function (config, reload) {
            var _this = this;
            setTimeout(function () {
                var c3Config = lodash.cloneDeep(config);
                c3Config.bindto = '#' + config.chartId;
                // Note: Always re-generate donut pct chart because it's colors change based on data and thresholds
                if (_this.chart === undefined || reload === true) {
                    _this.chart = c3.generate(c3Config);
                }
                else {
                    // if chart is already created, then we only need to re-load data
                    _this.chart.load(c3Config.data);
                }
                _this.chartLoaded.emit(_this.chart);
            });
        };
        __decorate$c([
            core.Output(),
            __metadata$7("design:type", core.EventEmitter)
        ], ChartBase.prototype, "chartLoaded", void 0);
        return ChartBase;
    }());

    var __extends$2 = (undefined && undefined.__extends) || (function () {
        var extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * A base config containing properties for charts
     */
    var ChartConfigBase = /** @class */ (function () {
        function ChartConfigBase() {
        }
        return ChartConfigBase;
    }());
    /**
     * @deprecated Use ChartConfigBase
     */
    var ChartConfig = /** @class */ (function (_super) {
        __extends$2(ChartConfig, _super);
        function ChartConfig() {
            var _this = _super.call(this) || this;
            console.log('patternfly-ng: ChartConfig is deprecated; use ChartConfigBase');
            return _this;
        }
        return ChartConfig;
    }(ChartConfigBase));

    var __decorate$d = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata$8 = (undefined && undefined.__metadata) || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    var ChartDefaults = /** @class */ (function () {
        function ChartDefaults() {
            this.patternflyDefaults = window.patternfly.c3ChartDefaults();
            this.getDefaultColors = this.patternflyDefaults.getDefaultColors;
            this.getDefaultDonut = this.patternflyDefaults.getDefaultDonut;
            this.getDefaultDonutSize = this.patternflyDefaults.getDefaultDonutSize;
            this.getDefaultDonutColors = this.patternflyDefaults.getDefaultDonutColors;
            this.getDefaultRelationshipDonutColors = this.patternflyDefaults.getDefaultRelationshipDonutColors;
            this.getDefaultDonutLegend = this.patternflyDefaults.getDefaultDonutLegend;
            this.getDefaultDonutTooltip = this.patternflyDefaults.getDefaultDonutTooltip;
            this.getDefaultDonutConfig = this.patternflyDefaults.getDefaultDonutConfig;
            this.getDefaultSparklineArea = this.patternflyDefaults.getDefaultSparklineArea;
            this.getDefaultSparklineSize = this.patternflyDefaults.getDefaultSparklineSize;
            this.getDefaultSparklineAxis = this.patternflyDefaults.getDefaultSparklineAxis;
            this.getDefaultSparklineColor = this.patternflyDefaults.getDefaultColors;
            this.getDefaultSparklineLegend = this.patternflyDefaults.getDefaultSparklineLegend;
            this.getDefaultSparklinePoint = this.patternflyDefaults.getDefaultSparklinePoint;
            this.getDefaultSparklineTooltip = this.patternflyDefaults.getDefaultSparklineTooltip;
            this.getDefaultSparklineConfig = this.patternflyDefaults.getDefaultSparklineConfig;
            this.getDefaultLineConfig = this.patternflyDefaults.getDefaultLineConfig;
        }
        ChartDefaults = __decorate$d([
            core.Injectable(),
            __metadata$8("design:paramtypes", [])
        ], ChartDefaults);
        return ChartDefaults;
    }());

    var __extends$3 = (undefined && undefined.__extends) || (function () {
        var extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * A config containing properties for the sparkline chart
     */
    var DonutChartBaseConfig = /** @class */ (function (_super) {
        __extends$3(DonutChartBaseConfig, _super);
        function DonutChartBaseConfig() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return DonutChartBaseConfig;
    }(ChartConfigBase));

    var __extends$4 = (undefined && undefined.__extends) || (function () {
        var extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var __decorate$e = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata$9 = (undefined && undefined.__metadata) || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    /**
     * Donut base
     */
    var DonutChartBaseComponent = /** @class */ (function (_super) {
        __extends$4(DonutChartBaseComponent, _super);
        /**
         * Default constructor
         * @param chartDefaults
         */
        function DonutChartBaseComponent(chartDefaults, windowRef) {
            var _this = _super.call(this) || this;
            _this.chartDefaults = chartDefaults;
            _this.windowRef = windowRef;
            _this.subscriptions = [];
            _this.subscriptions.push(_this.chartLoaded.subscribe({
                next: function (chart) {
                    _this.chartAvailable(chart);
                }
            }));
            return _this;
        }
        /**
         * Setup component configuration upon initialization
         */
        DonutChartBaseComponent.prototype.ngOnInit = function () {
            this.setupConfigDefaults();
            this.setupConfig();
            this.generateChart(this.config);
        };
        /**
         * Check if the component config has changed
         */
        DonutChartBaseComponent.prototype.ngDoCheck = function () {
            var dataChanged = !lodash.isEqual(this.chartData, this.prevChartData);
            if (dataChanged || !lodash.isEqual(this.config, this.prevConfig)) {
                this.setupConfig();
                this.generateChart(this.config, !dataChanged);
            }
        };
        /**
         * Clean up subscriptions
         */
        DonutChartBaseComponent.prototype.ngOnDestroy = function () {
            this.subscriptions.forEach(function (sub) { return sub.unsubscribe; });
        };
        /**
         * Set up default config
         */
        DonutChartBaseComponent.prototype.setupConfig = function () {
            if (this.config !== undefined) {
                lodash.defaultsDeep(this.config, this.defaultConfig);
            }
            else {
                this.config = lodash.cloneDeep(this.defaultConfig);
            }
            if (this.config.chartHeight !== undefined) {
                this.config.size.height = this.config.chartHeight;
            }
            this.config.data = lodash.merge(this.config.data, this.getChartData());
            this.prevConfig = lodash.cloneDeep(this.config);
            this.prevChartData = lodash.cloneDeep(this.chartData);
        };
        /**
         * Set up default config
         */
        DonutChartBaseComponent.prototype.setupConfigDefaults = function () {
            this.defaultConfig = this.chartDefaults.getDefaultDonutConfig();
            this.defaultConfig.chartId = lodash.uniqueId();
            this.defaultConfig.data = {
                type: 'donut',
                order: null
            };
            this.defaultConfig.donut = this.chartDefaults.getDefaultDonut();
            this.defaultConfig.tooltip = { contents: (this.windowRef.nativeWindow).patternfly.pfDonutTooltipContents };
        };
        /**
         * Convert chartData to C3 data property
         */
        DonutChartBaseComponent.prototype.getChartData = function () {
            return {
                columns: this.chartData,
                colors: this.config.colors
            };
        };
        /**
         * Returns an object containing center label properties
         * @returns {any}
         */
        DonutChartBaseComponent.prototype.getCenterLabelText = function () {
            // Public for testing
            var centerLabelText = {
                title: this.getTotal(),
                subTitle: this.config.donut.title
            };
            if (this.config.centerLabel) {
                centerLabelText.title = this.config.centerLabel;
                centerLabelText.subTitle = '';
            }
            return centerLabelText;
        };
        // Private
        DonutChartBaseComponent.prototype.chartAvailable = function (chart) {
            this.setupDonutChartTitle(chart);
        };
        DonutChartBaseComponent.prototype.getTotal = function () {
            var total = 0;
            if (this.config.data !== undefined && this.config.data.columns !== undefined) {
                this.config.data.columns.forEach(function (element) {
                    if (!isNaN(element[1])) {
                        total += Number(element[1]);
                    }
                });
            }
            return total;
        };
        DonutChartBaseComponent.prototype.setupDonutChartTitle = function (chart) {
            var donutChartTitle, centerLabelText;
            if (chart === undefined) {
                return;
            }
            donutChartTitle = d3.select(chart.element).select('text.c3-chart-arcs-title');
            if (donutChartTitle === undefined) {
                return;
            }
            centerLabelText = this.getCenterLabelText();
            donutChartTitle.text('');
            if (centerLabelText.title && !centerLabelText.subTitle) {
                donutChartTitle.text(centerLabelText.title);
            }
            else {
                donutChartTitle.insert('tspan', null).text(centerLabelText.title)
                    .classed('donut-title-big-pf', true).attr('dy', 0).attr('x', 0);
                donutChartTitle.insert('tspan', null).text(centerLabelText.subTitle).
                    classed('donut-title-small-pf', true).attr('dy', 20).attr('x', 0);
            }
        };
        __decorate$e([
            core.Input(),
            __metadata$9("design:type", Array)
        ], DonutChartBaseComponent.prototype, "chartData", void 0);
        __decorate$e([
            core.Input(),
            __metadata$9("design:type", DonutChartBaseConfig)
        ], DonutChartBaseComponent.prototype, "config", void 0);
        return DonutChartBaseComponent;
    }(ChartBase));

    var __decorate$f = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    function _window() {
        // return the global native browser window object
        return window;
    }
    var WindowReference = /** @class */ (function () {
        function WindowReference() {
        }
        Object.defineProperty(WindowReference.prototype, "nativeWindow", {
            get: function () {
                return _window();
            },
            enumerable: true,
            configurable: true
        });
        WindowReference = __decorate$f([
            core.Injectable()
        ], WindowReference);
        return WindowReference;
    }());

    var __extends$5 = (undefined && undefined.__extends) || (function () {
        var extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var __decorate$g = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata$a = (undefined && undefined.__metadata) || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    /**
     * Donut chart component.
     *
     * Note: In order to use charts, please include the following JavaScript file from patternfly. For example:
     * <br/><code>require('patternfly/dist/js/patternfly-settings');</code>
     *
     * Usage:
     * <br/><code>import { DonutChartModule } from 'patternfly-ng/chart';</code>
     *
     * Or:
     * <br/><code>import { DonutChartModule } from 'patternfly-ng';</code>
     */
    var DonutChartComponent = /** @class */ (function (_super) {
        __extends$5(DonutChartComponent, _super);
        /**
         * Default constructor
         */
        function DonutChartComponent(chartDefaults, windowRef) {
            var _this = _super.call(this, chartDefaults, windowRef) || this;
            _this.chartDefaults = chartDefaults;
            _this.windowRef = windowRef;
            return _this;
        }
        DonutChartComponent = __decorate$g([
            core.Component({
                encapsulation: core.ViewEncapsulation.None,
                selector: 'pfng-donut-chart',
                template: "<div #chartElement id=\"{{config.chartId}}\"></div>"
            }),
            __metadata$a("design:paramtypes", [ChartDefaults, WindowReference])
        ], DonutChartComponent);
        return DonutChartComponent;
    }(DonutChartBaseComponent));
    /**
     * @deprecated Use DonutChartComponent
     */
    var DonutComponent = /** @class */ (function (_super) {
        __extends$5(DonutComponent, _super);
        function DonutComponent(chartDefaults, windowRef) {
            var _this = _super.call(this, chartDefaults, windowRef) || this;
            _this.chartDefaults = chartDefaults;
            _this.windowRef = windowRef;
            console.log('patternfly-ng: DonutComponent is deprecated; use DonutChartComponent');
            return _this;
        }
        DonutComponent = __decorate$g([
            core.Component({
                encapsulation: core.ViewEncapsulation.None,
                selector: 'pfng-chart-donut',
                template: "<div #chartElement id=\"{{config.chartId}}\"></div>"
            }),
            __metadata$a("design:paramtypes", [ChartDefaults, WindowReference])
        ], DonutComponent);
        return DonutComponent;
    }(DonutChartComponent));

    var __extends$6 = (undefined && undefined.__extends) || (function () {
        var extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * A config containing properties for the sparkline chart
     */
    var DonutChartConfig = /** @class */ (function (_super) {
        __extends$6(DonutChartConfig, _super);
        function DonutChartConfig() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return DonutChartConfig;
    }(DonutChartBaseConfig));
    /**
     * @deprecated Use DonutChartConfig
     */
    var DonutConfig = /** @class */ (function (_super) {
        __extends$6(DonutConfig, _super);
        function DonutConfig() {
            var _this = _super.call(this) || this;
            console.log('patternfly-ng: DonutConfig is deprecated; use DonutChartConfig or UtilizationDonutChartConfig');
            return _this;
        }
        return DonutConfig;
    }(DonutChartConfig));

    var __decorate$h = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var DonutChartModule = /** @class */ (function () {
        function DonutChartModule() {
        }
        DonutChartModule = __decorate$h([
            core.NgModule({
                imports: [
                    common.CommonModule,
                    forms.FormsModule,
                ],
                declarations: [DonutChartComponent, DonutComponent],
                exports: [DonutChartComponent, DonutComponent],
                providers: [ChartDefaults, WindowReference]
            })
        ], DonutChartModule);
        return DonutChartModule;
    }());

    var __extends$7 = (undefined && undefined.__extends) || (function () {
        var extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * A config containing properties for the utilization donut chart
     */
    var UtilizationDonutChartConfig = /** @class */ (function (_super) {
        __extends$7(UtilizationDonutChartConfig, _super);
        function UtilizationDonutChartConfig() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return UtilizationDonutChartConfig;
    }(DonutChartBaseConfig));

    var __extends$8 = (undefined && undefined.__extends) || (function () {
        var extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var __decorate$i = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata$b = (undefined && undefined.__metadata) || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    /**
     * Donut Utilization chart component.
     *
     * Note: In order to use charts, please include the following JavaScript file from patternfly. For example:
     * <br/><code>require('patternfly/dist/js/patternfly-settings');</code>
     *
     * Usage:
     * <br/><code>import { UtilizationDonutChartModule } from 'patternfly-ng/chart';</code>
     *
     * Or:
     * <br/><code>import { UtilizationDonutChartModule } from 'patternfly-ng';</code>
     */
    var UtilizationDonutChartComponent = /** @class */ (function (_super) {
        __extends$8(UtilizationDonutChartComponent, _super);
        /**
         * Default constructor
         */
        function UtilizationDonutChartComponent(chartDefaults, windowRef) {
            var _this = _super.call(this, chartDefaults, windowRef) || this;
            _this.chartDefaults = chartDefaults;
            _this.windowRef = windowRef;
            /**
             * Event emitted when the Used amount passes a user defined threshold
             * @type {EventEmitter}
             */
            _this.thresholdChanged = new core.EventEmitter();
            return _this;
        }
        /**
         * Returns an object containing center label properties
         * @returns {any}
         */
        UtilizationDonutChartComponent.prototype.getCenterLabelText = function () {
            // Public for testing
            this.updateMetrics();
            var units = this.config.units;
            var available = this.config.available;
            var total = this.config.total;
            var percent = this.config.percent;
            var used = this.config.used;
            var labelFormat = this.config.centerLabelFormat;
            var centerLabelText = {};
            if (this.config.centerLabelFn) {
                var labelText = this.config.centerLabelFn();
                centerLabelText.title = labelText.title;
                centerLabelText.subTitle = labelText.subTitle;
            }
            else {
                switch (labelFormat) {
                    case 'none':
                        centerLabelText.title = '';
                        centerLabelText.subTitle = '';
                        break;
                    case 'available':
                        centerLabelText.title = available;
                        centerLabelText.subTitle = units + ' Available';
                        break;
                    case 'percent':
                        centerLabelText.title = percent + '%';
                        centerLabelText.subTitle = 'of ' + total + ' ' + units;
                        break;
                    default:
                        centerLabelText.title = used;
                        centerLabelText.subTitle = units + ' Used';
                }
            }
            return centerLabelText;
        };
        /**
         * get C3 chart data from config properties
         */
        UtilizationDonutChartComponent.prototype.getChartData = function () {
            this.updateMetrics();
            return {
                columns: [
                    ['Used', this.config.used],
                    ['Available', this.config.available]
                ],
                colors: this.getUtilizationColors(),
                groups: [
                    ['used', 'available']
                ]
            };
        };
        UtilizationDonutChartComponent.prototype.updateMetrics = function () {
            this.config.available = this.config.total - this.config.used;
            this.config.percent = Math.round(this.config.used / this.config.total * 100.0);
        };
        UtilizationDonutChartComponent.prototype.getUtilizationColors = function () {
            return {
                Used: this.getUtilizationUsedColor(this.config.percent, this.config.thresholds),
                Available: this.chartDefaults.getDefaultDonutColors().pattern[1] // grey
            };
        };
        UtilizationDonutChartComponent.prototype.getUtilizationUsedColor = function (used, thresholds) {
            var threshold = 'none';
            var thresholdColors = this.chartDefaults.getDefaultRelationshipDonutColors().pattern;
            var color = thresholdColors[0]; // default blue
            var errorColor = thresholdColors[1]; // red
            var warnColor = thresholdColors[2]; // orange
            var okColor = thresholdColors[3]; // green
            if (thresholds) {
                threshold = 'ok';
                color = okColor;
                if (used >= thresholds.error) {
                    threshold = 'error';
                    color = errorColor;
                }
                else if (used >= thresholds.warning) {
                    threshold = 'warning';
                    color = warnColor;
                }
            }
            if (!this.threshold || this.threshold !== threshold) {
                this.threshold = threshold;
                this.thresholdChanged.emit(this.threshold);
            }
            return color;
        };
        __decorate$i([
            core.Input(),
            __metadata$b("design:type", UtilizationDonutChartConfig)
        ], UtilizationDonutChartComponent.prototype, "config", void 0);
        __decorate$i([
            core.Output(),
            __metadata$b("design:type", core.EventEmitter)
        ], UtilizationDonutChartComponent.prototype, "thresholdChanged", void 0);
        UtilizationDonutChartComponent = __decorate$i([
            core.Component({
                encapsulation: core.ViewEncapsulation.None,
                selector: 'pfng-utilization-donut-chart',
                template: "<div class=\"pct-donut-chart-pf\"><span [ngClass]=\"{'pct-donut-chart-pf-left': config.outerLabelAlignment === 'left',\n                   'pct-donut-chart-pf-right': config.outerLabelAlignment === 'right'}\"><span class=\"pct-donut-chart-pf-chart\"><div #chartElement id=\"{{config.chartId}}\"></div></span><span [ngClass]=\"{'text-right': config.outerLabelAlignment === 'left',\n                      'text-left': config.outerLabelAlignment === 'right',\n                      'text-center': config.outerLabelAlignment !== 'left' && config.outerLabelAlignment !== 'right'}\"><ng-content></ng-content></span></span></div>"
            }),
            __metadata$b("design:paramtypes", [ChartDefaults, WindowReference])
        ], UtilizationDonutChartComponent);
        return UtilizationDonutChartComponent;
    }(DonutChartBaseComponent));

    var __decorate$j = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var UtilizationDonutChartModule = /** @class */ (function () {
        function UtilizationDonutChartModule() {
        }
        UtilizationDonutChartModule = __decorate$j([
            core.NgModule({
                imports: [
                    common.CommonModule,
                    forms.FormsModule,
                ],
                declarations: [UtilizationDonutChartComponent],
                exports: [UtilizationDonutChartComponent],
                providers: [ChartDefaults, WindowReference]
            })
        ], UtilizationDonutChartModule);
        return UtilizationDonutChartModule;
    }());

    var __extends$9 = (undefined && undefined.__extends) || (function () {
        var extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * A config containing properties for the sparkline chart
     */
    var SparklineChartConfig = /** @class */ (function (_super) {
        __extends$9(SparklineChartConfig, _super);
        function SparklineChartConfig() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return SparklineChartConfig;
    }(ChartConfigBase));
    /**
     * @deprecated Use SparklineChartConfig
     */
    var SparklineConfig = /** @class */ (function (_super) {
        __extends$9(SparklineConfig, _super);
        function SparklineConfig() {
            var _this = _super.call(this) || this;
            console.log('patternfly-ng: SparklineConfig is deprecated; use SparklineChartConfig');
            return _this;
        }
        return SparklineConfig;
    }(SparklineChartConfig));

    var __extends$a = (undefined && undefined.__extends) || (function () {
        var extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * A base config containing properties for chart data
     */
    var SparklineChartData = /** @class */ (function () {
        function SparklineChartData() {
        }
        return SparklineChartData;
    }());
    /**
     * @deprecated Use SparklineChartData
     */
    var SparklineData = /** @class */ (function (_super) {
        __extends$a(SparklineData, _super);
        function SparklineData() {
            var _this = _super.call(this) || this;
            console.log('patternfly-ng: SparklineData is deprecated; use SparklineChartData');
            return _this;
        }
        return SparklineData;
    }(SparklineChartData));

    var __extends$b = (undefined && undefined.__extends) || (function () {
        var extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var __decorate$k = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata$c = (undefined && undefined.__metadata) || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    /**
     * Sparkline chart component
     *
     * Note: In order to use charts, please include the following JavaScript file from patternfly. For example:
     * <br/><code>require('patternfly/dist/js/patternfly-settings');</code>
     *
     * Usage:
     * <br/><code>import { SparklineChartModule } from 'patternfly-ng/chart';</code>
     *
     * Or:
     * <br/><code>import { SparklineChartModule } from 'patternfly-ng';</code>
     */
    var SparklineChartComponent = /** @class */ (function (_super) {
        __extends$b(SparklineChartComponent, _super);
        /**
         * Default constructor
         * @param chartDefaults
         */
        function SparklineChartComponent(chartDefaults) {
            var _this = _super.call(this) || this;
            _this.chartDefaults = chartDefaults;
            return _this;
        }
        /**
         * Setup component configuration upon initialization
         */
        SparklineChartComponent.prototype.ngOnInit = function () {
            this.setupConfigDefaults();
            this.setupConfig();
            this.generateChart(this.config, true);
        };
        /**
         * Check if the component config has changed
         */
        SparklineChartComponent.prototype.ngDoCheck = function () {
            var dataChanged = !lodash.isEqual(this.chartData, this.prevChartData);
            if (dataChanged || !lodash.isEqual(this.config, this.prevConfig)) {
                this.setupConfig();
                this.generateChart(this.config, !dataChanged);
            }
        };
        /**
         * Set up default config
         */
        SparklineChartComponent.prototype.setupConfig = function () {
            if (this.config !== undefined) {
                lodash.defaultsDeep(this.config, this.defaultConfig);
            }
            else {
                this.config = lodash.cloneDeep(this.defaultConfig);
            }
            /*
             * Setup Axis options. Default is to not show either axis. This can be overridden in two ways:
             *   1) in the config, setting showAxis to true will show both axes
             *   2) in the attributes showXAxis and showYAxis will override the config if set
             *
             * By default only line and the tick marks are shown, no labels. This is a sparkline and should be used
             * only to show a brief idea of trending. This can be overridden by setting the config.axis options per C3
             */
            if (this.config.axis !== undefined) {
                this.config.axis.x.show = this.config.showXAxis === true;
                this.config.axis.y.show = this.config.showYAxis === true;
            }
            if (this.config.chartHeight !== undefined) {
                this.config.size.height = this.config.chartHeight;
            }
            this.config.data = lodash.merge(this.config.data, this.getChartData());
            this.prevConfig = lodash.cloneDeep(this.config);
            this.prevChartData = lodash.cloneDeep(this.chartData);
        };
        /**
         * Set up config defaults
         */
        SparklineChartComponent.prototype.setupConfigDefaults = function () {
            this.defaultConfig = this.chartDefaults.getDefaultSparklineConfig();
            this.defaultConfig.axis = {
                x: {
                    show: this.config.showXAxis === true,
                    type: 'timeseries',
                    tick: {
                        format: function () {
                            return ''; // change to lambda ?
                        }
                    }
                },
                y: {
                    show: this.config.showYAxis === true,
                    tick: {
                        format: function () {
                            return ''; // change to lambda ?
                        }
                    }
                }
            };
            this.defaultConfig.chartId = lodash.uniqueId(this.config.chartId);
            this.defaultConfig.data = { type: 'area' };
            this.defaultConfig.tooltip = this.tooltip();
            this.defaultConfig.units = '';
        };
        // Chart
        /**
         * Convert chartData to C3 data property
         */
        SparklineChartComponent.prototype.getChartData = function () {
            var data = {};
            if (this.chartData && this.chartData.dataAvailable !== false && this.chartData.xData && this.chartData.yData) {
                data.x = this.chartData.xData[0];
                data.columns = [
                    this.chartData.xData,
                    this.chartData.yData
                ];
            }
            return data;
        };
        /**
         * Tooltip function for sparklines
         *
         * @returns {{contents: ((d:any)=>string), position: ((data:any, width:number,
         *            height:number, element:any)=>{top: number, left: number})}}
         */
        SparklineChartComponent.prototype.tooltip = function () {
            var _this = this;
            return {
                contents: function (d) {
                    var tipRows;
                    var percentUsed = 0;
                    switch (_this.config.tooltipType) {
                        case 'usagePerDay':
                            if (_this.chartData.dataAvailable !== false && _this.chartData.total > 0) {
                                percentUsed = Math.round(d[0].value / _this.chartData.total * 100.0);
                            }
                            tipRows =
                                '<tr>' +
                                    '  <th colspan="2">' + d[0].x.toLocaleDateString() + '</th>' +
                                    '</tr>' +
                                    '<tr>' +
                                    '  <td class="name">' + percentUsed + '%:' + '</td>' +
                                    '  <td class="value text-nowrap">' + d[0].value + ' '
                                    + (_this.config.units ? _this.config.units + ' ' : '') + d[0].name + '</td>' +
                                    '</tr>';
                            break;
                        case 'valuePerDay':
                            tipRows =
                                '<tr>' +
                                    '  <td class="value">' + d[0].x.toLocaleDateString() + '</td>' +
                                    '  <td class="value text-nowrap">' + d[0].value + ' ' + d[0].name + '</td>' +
                                    '</tr>';
                            break;
                        case 'percentage':
                            percentUsed = Math.round(d[0].value / _this.chartData.total * 100.0);
                            tipRows =
                                '<tr>' +
                                    '  <td class="name">' + percentUsed + '%' + '</td>' +
                                    '</tr>';
                            break;
                        default:
                            tipRows = _this.chartDefaults.getDefaultSparklineTooltip().contents(d);
                    }
                    return _this.getTooltipTableHTML(tipRows);
                },
                position: function (data, width, height, element) {
                    var center;
                    var top;
                    var chartBox;
                    var graphOffsetX;
                    var x;
                    try {
                        center = parseInt(element.getAttribute('x'), 10);
                        top = parseInt(element.getAttribute('y'), 10);
                        chartBox = document.querySelector('#' + _this.config.chartId).getBoundingClientRect();
                        graphOffsetX = document.querySelector('#' + _this.config.chartId + ' g.c3-axis-y')
                            .getBoundingClientRect().right;
                        x = Math.max(0, center + graphOffsetX - chartBox.left - Math.floor(width / 2));
                        return {
                            top: top - height,
                            left: Math.min(x, chartBox.width - width)
                        };
                    }
                    catch (e) {
                    }
                }
            };
        };
        // Private
        SparklineChartComponent.prototype.getTooltipTableHTML = function (tipRows) {
            return '<div class="module-triangle-bottom">' +
                '  <table class="c3-tooltip">' +
                '    <tbody>' +
                tipRows +
                '    </tbody>' +
                '  </table>' +
                '</div>';
        };
        __decorate$k([
            core.Input(),
            __metadata$c("design:type", SparklineChartData)
        ], SparklineChartComponent.prototype, "chartData", void 0);
        __decorate$k([
            core.Input(),
            __metadata$c("design:type", SparklineChartConfig)
        ], SparklineChartComponent.prototype, "config", void 0);
        SparklineChartComponent = __decorate$k([
            core.Component({
                encapsulation: core.ViewEncapsulation.None,
                selector: 'pfng-sparkline-chart',
                template: "<div #chartElement id=\"{{config.chartId}}\"></div>"
            }),
            __metadata$c("design:paramtypes", [ChartDefaults])
        ], SparklineChartComponent);
        return SparklineChartComponent;
    }(ChartBase));
    /**
     * @deprecated Use SparklineChartComponent
     */
    var SparklineComponent = /** @class */ (function (_super) {
        __extends$b(SparklineComponent, _super);
        function SparklineComponent(chartDefaults) {
            var _this = _super.call(this, chartDefaults) || this;
            _this.chartDefaults = chartDefaults;
            console.log('patternfly-ng: SparklineComponent is deprecated; use SparklineChartComponent');
            return _this;
        }
        SparklineComponent = __decorate$k([
            core.Component({
                encapsulation: core.ViewEncapsulation.None,
                selector: 'pfng-chart-sparkline',
                template: "<div #chartElement id=\"{{config.chartId}}\"></div>"
            }),
            __metadata$c("design:paramtypes", [ChartDefaults])
        ], SparklineComponent);
        return SparklineComponent;
    }(SparklineChartComponent));

    var __decorate$l = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var SparklineChartModule = /** @class */ (function () {
        function SparklineChartModule() {
        }
        SparklineChartModule = __decorate$l([
            core.NgModule({
                imports: [
                    common.CommonModule,
                    forms.FormsModule
                ],
                declarations: [SparklineChartComponent, SparklineComponent],
                exports: [SparklineChartComponent, SparklineComponent],
                providers: [ChartDefaults, WindowReference]
            })
        ], SparklineChartModule);
        return SparklineChartModule;
    }());

    var __decorate$m = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata$d = (undefined && undefined.__metadata) || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    /**
     * A module containing objects associated with chart components
     *
     * @deprecated Use individual module imports
     *
     * import {
     *   DonutChartModule,
     *   SparklineChartModule
     * } from 'patterfnly/chart';
     */
    var ChartModule = /** @class */ (function () {
        function ChartModule() {
            console.log('patternfly-ng: ChartModule is deprecated; use DonutChartModule or SparklineChartModule');
        }
        ChartModule = __decorate$m([
            core.NgModule({
                imports: [
                    common.CommonModule,
                    DonutChartModule,
                    forms.FormsModule,
                    SparklineChartModule
                ],
                exports: [DonutComponent, SparklineComponent],
                providers: [ChartDefaults, WindowReference]
            }),
            __metadata$d("design:paramtypes", [])
        ], ChartModule);
        return ChartModule;
    }());

    var __decorate$n = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata$e = (undefined && undefined.__metadata) || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    /**
     * A config containing properties for copy components
     */
    var CopyBase = /** @class */ (function () {
        /**
         * Default constructor
         */
        function CopyBase(copyService) {
            this.copyService = copyService;
            /**
             * The text node to be copied to the users clipboard
             * @type {string}
             */
            this.copyValue = 'Missing \'copyValue\' @Input property';
            /**
             * Placement for the tooltip that further describes the copyValue
             * @type {string}
             */
            this.tooltipPlacement = 'top';
            /**
             * Event emitted with the chart reference after load is complete
             * @type {EventEmitter}
             */
            this.copiedToClipboard = new core.EventEmitter();
            this._recentlyCopied = false;
        }
        Object.defineProperty(CopyBase.prototype, "recentlyCopied", {
            /**
             * Returns the flag indicating copy action has just happened
             *
             * @returns {boolean} True if copy action has been triggered
             */
            get: function () {
                return this._recentlyCopied;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Copy value to the user's system clipboard
         * @param {string} accessibleName An accessible name used to describe the component
         */
        CopyBase.prototype.copyValueToClipboard = function (accessibleName) {
            var _this = this;
            var result = this.copyService.copy(this.copyValue);
            if (result) {
                this.copiedToClipboard.emit({
                    name: accessibleName,
                    msg: accessibleName + " copied"
                });
                this._recentlyCopied = true;
                setTimeout(function () {
                    _this._recentlyCopied = false;
                }, 3000);
            }
        };
        __decorate$n([
            core.Input('copyBtnAriaLabel'),
            __metadata$e("design:type", String)
        ], CopyBase.prototype, "copyBtnAriaLabel", void 0);
        __decorate$n([
            core.Input('copyValue'),
            __metadata$e("design:type", String)
        ], CopyBase.prototype, "copyValue", void 0);
        __decorate$n([
            core.Input('tooltip'),
            __metadata$e("design:type", String)
        ], CopyBase.prototype, "tooltip", void 0);
        __decorate$n([
            core.Input('tooltipPlacement'),
            __metadata$e("design:type", String)
        ], CopyBase.prototype, "tooltipPlacement", void 0);
        __decorate$n([
            core.Output('copiedToClipboard'),
            __metadata$e("design:type", core.EventEmitter)
        ], CopyBase.prototype, "copiedToClipboard", void 0);
        return CopyBase;
    }());

    var __decorate$o = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata$f = (undefined && undefined.__metadata) || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    };
    /**
     * A generic service for copying text to clipboard
     */
    var CopyService = /** @class */ (function () {
        /**
         * The default constructor
         */
        function CopyService(dom) {
            this.verbose = false;
            this.dom = dom;
        }
        /**
         * Copy a value to the user's system clipboard
         */
        CopyService.prototype.copy = function (value) {
            var result = false;
            var textarea = this.dom.createElement('textarea');
            var triggerElement = document.activeElement;
            textarea.style.width = '0px';
            textarea.style.height = '0px';
            textarea.style.position = 'fixed';
            textarea.style.top = '-100px';
            textarea.style.left = '-100px';
            textarea.style.opacity = '0';
            textarea.value = value;
            this.dom.body.appendChild(textarea);
            textarea.select();
            if (!!triggerElement) {
                triggerElement.focus();
            }
            try {
                result = this.dom.execCommand('copy');
            }
            catch (error) {
                this.handleError(error);
            }
            finally {
                if (textarea.parentNode !== undefined) {
                    textarea.parentNode.removeChild(textarea);
                }
            }
            return result;
        };
        /**
         * Set the verbose mode to on or off (default). During the verbose mode, each unsuccessful copy operation
         * will be printed to the console.
         * @param verbose Set to true for verbose mode
         */
        CopyService.prototype.setVerbose = function (verbose) {
            this.verbose = verbose;
        };
        /**
         * Handles an unsuccessful copy operation.
         * @param error The error message to display in the console.
         */
        CopyService.prototype.handleError = function (error) {
            if (this.verbose) {
                console.error(error);
            }
        };
        CopyService = __decorate$o([
            core.Injectable(),
            __param(0, core.Inject(common.DOCUMENT)),
            __metadata$f("design:paramtypes", [Document])
        ], CopyService);
        return CopyService;
    }());

    var __decorate$p = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var CopyServiceModule = /** @class */ (function () {
        function CopyServiceModule() {
        }
        CopyServiceModule = __decorate$p([
            core.NgModule({
                imports: [
                    common.CommonModule
                ],
                providers: [CopyService]
            })
        ], CopyServiceModule);
        return CopyServiceModule;
    }());

    var __extends$c = (undefined && undefined.__extends) || (function () {
        var extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var __decorate$q = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata$g = (undefined && undefined.__metadata) || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    var InlineCopyComponent = /** @class */ (function (_super) {
        __extends$c(InlineCopyComponent, _super);
        /**
         * The default constructor
         */
        function InlineCopyComponent(copyService) {
            var _this = _super.call(this, copyService) || this;
            _this.copyService = copyService;
            return _this;
        }
        /**
         * Copies the copyBtnAriaLabel value to the users clipboard
         */
        InlineCopyComponent.prototype.copyToClipboard = function () {
            this.copyValueToClipboard(this.copyBtnAriaLabel);
        };
        InlineCopyComponent = __decorate$q([
            core.Component({
                encapsulation: core.ViewEncapsulation.None,
                selector: 'pfng-inline-copy',
                template: "<span class=\"pfng-inline-copy\"><span class=\"pfng-inline-copy-txt-cont\" placement=\"{{tooltipPlacement ? tooltipPlacement : null}}\" tooltip=\"{{tooltip ? tooltip : null}}\">{{copyValue}} </span><button class=\"pfng-inline-copy-btn\" [attr.aria-label]=\"copyBtnAriaLabel\" (click)=\"copyToClipboard()\"><i class=\"fa\" [ngClass]=\"{'fa-check': recentlyCopied, 'fa-clipboard': !recentlyCopied}\" aria-hidden=\"true\"></i></button></span>",
                styleUrls: ['./inline-copy.component.less']
            }),
            __metadata$g("design:paramtypes", [CopyService])
        ], InlineCopyComponent);
        return InlineCopyComponent;
    }(CopyBase));

    /** Default values provider for tooltip */
    var TooltipConfig = (function () {
        function TooltipConfig() {
            /** tooltip placement, supported positions: 'top', 'bottom', 'left', 'right' */
            this.placement = 'top';
            /** array of event names which triggers tooltip opening */
            this.triggers = 'hover focus';
        }
        TooltipConfig.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        TooltipConfig.ctorParameters = function () { return []; };
        return TooltipConfig;
    }());

    var TooltipContainerComponent = (function () {
        function TooltipContainerComponent(config) {
            Object.assign(this, config);
        }
        Object.defineProperty(TooltipContainerComponent.prototype, "isBs3", {
            get: function () {
                return isBs3();
            },
            enumerable: true,
            configurable: true
        });
        TooltipContainerComponent.prototype.ngAfterViewInit = function () {
            this.classMap = { in: false, fade: false };
            this.classMap[this.placement] = true;
            this.classMap["tooltip-" + this.placement] = true;
            this.classMap.in = true;
            if (this.animation) {
                this.classMap.fade = true;
            }
            if (this.containerClass) {
                this.classMap[this.containerClass] = true;
            }
        };
        TooltipContainerComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'bs-tooltip-container',
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        // tslint:disable-next-line
                        host: {
                            '[class]': '"tooltip in tooltip-" + placement + " " + "bs-tooltip-" + placement + " " + placement + " " + containerClass',
                            '[class.show]': '!isBs3',
                            role: 'tooltip'
                        },
                        styles: [
                            "\n    :host.tooltip {\n      display: block;\n    }\n    :host.bs-tooltip-top .arrow, :host.bs-tooltip-bottom .arrow {\n      left: 50%;\n      margin-left: -6px;\n    }\n    :host.bs-tooltip-left .arrow, :host.bs-tooltip-right .arrow {\n      top: 50%;\n      margin-top: -6px;\n    }\n  "
                        ],
                        template: "\n    <div class=\"tooltip-arrow arrow\"></div>\n    <div class=\"tooltip-inner\"><ng-content></ng-content></div>\n    "
                    },] },
        ];
        /** @nocollapse */
        TooltipContainerComponent.ctorParameters = function () { return [
            { type: TooltipConfig, },
        ]; };
        return TooltipContainerComponent;
    }());

    /*tslint:disable:no-invalid-this */
    function OnChange(defaultValue) {
        var sufix = 'Change';
        return function OnChangeHandler(target, propertyKey) {
            var _key = " __" + propertyKey + "Value";
            Object.defineProperty(target, propertyKey, {
                get: function () {
                    return this[_key];
                },
                set: function (value) {
                    var prevValue = this[_key];
                    this[_key] = value;
                    if (prevValue !== value && this[propertyKey + sufix]) {
                        this[propertyKey + sufix].emit(value);
                    }
                }
            });
        };
    }
    /* tslint:enable */

    var _messagesHash = {};
    var _hideMsg = typeof console === 'undefined' || !('warn' in console);
    function warnOnce(msg) {
        if (!core.isDevMode() || _hideMsg || msg in _messagesHash) {
            return;
        }
        _messagesHash[msg] = true;
        /*tslint:disable-next-line*/
        console.warn(msg);
    }

    var __decorate$r = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata$h = (undefined && undefined.__metadata) || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    var TooltipDirective = (function () {
        function TooltipDirective(_viewContainerRef, _renderer, _elementRef, cis, config) {
            this._renderer = _renderer;
            this._elementRef = _elementRef;
            /** Fired when tooltip content changes */
            this.tooltipChange = new core.EventEmitter();
            /**
             * Css class for tooltip container
             */
            this.containerClass = '';
            /** @deprecated - removed, will be added to configuration */
            this._animation = true;
            /** @deprecated */
            this._fadeDuration = 150;
            /** @deprecated */
            this.tooltipStateChanged = new core.EventEmitter();
            this._tooltip = cis
                .createLoader(this._elementRef, _viewContainerRef, this._renderer)
                .provide({ provide: TooltipConfig, useValue: config });
            Object.assign(this, config);
            this.onShown = this._tooltip.onShown;
            this.onHidden = this._tooltip.onHidden;
        }
        Object.defineProperty(TooltipDirective.prototype, "isOpen", {
            /**
             * Returns whether or not the tooltip is currently being shown
             */
            get: function () {
                return this._tooltip.isShown;
            },
            set: function (value) {
                if (value) {
                    this.show();
                }
                else {
                    this.hide();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TooltipDirective.prototype, "htmlContent", {
            /** @deprecated - please use `tooltip` instead */
            set: function (value) {
                warnOnce('tooltipHtml was deprecated, please use `tooltip` instead');
                this.tooltip = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TooltipDirective.prototype, "_placement", {
            /** @deprecated - please use `placement` instead */
            set: function (value) {
                warnOnce('tooltipPlacement was deprecated, please use `placement` instead');
                this.placement = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TooltipDirective.prototype, "_isOpen", {
            get: function () {
                warnOnce('tooltipIsOpen was deprecated, please use `isOpen` instead');
                return this.isOpen;
            },
            /** @deprecated - please use `isOpen` instead*/
            set: function (value) {
                warnOnce('tooltipIsOpen was deprecated, please use `isOpen` instead');
                this.isOpen = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TooltipDirective.prototype, "_enable", {
            get: function () {
                warnOnce('tooltipEnable was deprecated, please use `isDisabled` instead');
                return this.isDisabled;
            },
            /** @deprecated - please use `isDisabled` instead */
            set: function (value) {
                warnOnce('tooltipEnable was deprecated, please use `isDisabled` instead');
                this.isDisabled = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TooltipDirective.prototype, "_appendToBody", {
            get: function () {
                warnOnce('tooltipAppendToBody was deprecated, please use `container="body"` instead');
                return this.container === 'body';
            },
            /** @deprecated - please use `container="body"` instead */
            set: function (value) {
                warnOnce('tooltipAppendToBody was deprecated, please use `container="body"` instead');
                this.container = value ? 'body' : this.container;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TooltipDirective.prototype, "_popupClass", {
            /** @deprecated - will replaced with customClass */
            set: function (value) {
                warnOnce('tooltipClass deprecated');
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TooltipDirective.prototype, "_tooltipContext", {
            /** @deprecated - removed */
            set: function (value) {
                warnOnce('tooltipContext deprecated');
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TooltipDirective.prototype, "_tooltipPopupDelay", {
            /** @deprecated */
            set: function (value) {
                warnOnce('tooltipPopupDelay is deprecated, use `delay` instead');
                this.delay = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TooltipDirective.prototype, "_tooltipTrigger", {
            /** @deprecated -  please use `triggers` instead */
            get: function () {
                warnOnce('tooltipTrigger was deprecated, please use `triggers` instead');
                return this.triggers;
            },
            set: function (value) {
                warnOnce('tooltipTrigger was deprecated, please use `triggers` instead');
                this.triggers = (value || '').toString();
            },
            enumerable: true,
            configurable: true
        });
        TooltipDirective.prototype.ngOnInit = function () {
            var _this = this;
            this._tooltip.listen({
                triggers: this.triggers,
                show: function () { return _this.show(); }
            });
            this.tooltipChange.subscribe(function (value) {
                if (!value) {
                    _this._tooltip.hide();
                }
            });
        };
        /**
         * Toggles an element’s tooltip. This is considered a “manual” triggering of
         * the tooltip.
         */
        TooltipDirective.prototype.toggle = function () {
            if (this.isOpen) {
                return this.hide();
            }
            this.show();
        };
        /**
         * Opens an element’s tooltip. This is considered a “manual” triggering of
         * the tooltip.
         */
        TooltipDirective.prototype.show = function () {
            var _this = this;
            if (this.isOpen ||
                this.isDisabled ||
                this._delayTimeoutId ||
                !this.tooltip) {
                return;
            }
            var showTooltip = function () {
                if (_this._delayTimeoutId) {
                    _this._delayTimeoutId = undefined;
                }
                _this._tooltip
                    .attach(TooltipContainerComponent)
                    .to(_this.container)
                    .position({ attachment: _this.placement })
                    .show({
                    content: _this.tooltip,
                    placement: _this.placement,
                    containerClass: _this.containerClass
                });
            };
            var cancelDelayedTooltipShowing = function () {
                if (_this._tooltipCancelShowFn) {
                    _this._tooltipCancelShowFn();
                }
            };
            if (this.delay) {
                var timer_1 = Observable.Observable.timer(this.delay).subscribe(function () {
                    showTooltip();
                    cancelDelayedTooltipShowing();
                });
                if (this.triggers) {
                    var triggers = parseTriggers(this.triggers);
                    this._tooltipCancelShowFn = this._renderer.listen(this._elementRef.nativeElement, triggers[0].close, function () {
                        timer_1.unsubscribe();
                        cancelDelayedTooltipShowing();
                    });
                }
            }
            else {
                showTooltip();
            }
        };
        /**
         * Closes an element’s tooltip. This is considered a “manual” triggering of
         * the tooltip.
         */
        TooltipDirective.prototype.hide = function () {
            var _this = this;
            if (this._delayTimeoutId) {
                clearTimeout(this._delayTimeoutId);
                this._delayTimeoutId = undefined;
            }
            if (!this._tooltip.isShown) {
                return;
            }
            this._tooltip.instance.classMap.in = false;
            setTimeout(function () {
                _this._tooltip.hide();
            }, this._fadeDuration);
        };
        TooltipDirective.prototype.ngOnDestroy = function () {
            this._tooltip.dispose();
        };
        TooltipDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[tooltip], [tooltipHtml]',
                        exportAs: 'bs-tooltip'
                    },] },
        ];
        /** @nocollapse */
        TooltipDirective.ctorParameters = function () { return [
            { type: core.ViewContainerRef, },
            { type: core.Renderer2, },
            { type: core.ElementRef, },
            { type: ComponentLoaderFactory, },
            { type: TooltipConfig, },
        ]; };
        TooltipDirective.propDecorators = {
            'tooltip': [{ type: core.Input },],
            'tooltipChange': [{ type: core.Output },],
            'placement': [{ type: core.Input },],
            'triggers': [{ type: core.Input },],
            'container': [{ type: core.Input },],
            'isOpen': [{ type: core.Input },],
            'isDisabled': [{ type: core.Input },],
            'containerClass': [{ type: core.Input },],
            'delay': [{ type: core.Input },],
            'onShown': [{ type: core.Output },],
            'onHidden': [{ type: core.Output },],
            'htmlContent': [{ type: core.Input, args: ['tooltipHtml',] },],
            '_placement': [{ type: core.Input, args: ['tooltipPlacement',] },],
            '_isOpen': [{ type: core.Input, args: ['tooltipIsOpen',] },],
            '_enable': [{ type: core.Input, args: ['tooltipEnable',] },],
            '_appendToBody': [{ type: core.Input, args: ['tooltipAppendToBody',] },],
            '_animation': [{ type: core.Input, args: ['tooltipAnimation',] },],
            '_popupClass': [{ type: core.Input, args: ['tooltipClass',] },],
            '_tooltipContext': [{ type: core.Input, args: ['tooltipContext',] },],
            '_tooltipPopupDelay': [{ type: core.Input, args: ['tooltipPopupDelay',] },],
            '_fadeDuration': [{ type: core.Input, args: ['tooltipFadeDuration',] },],
            '_tooltipTrigger': [{ type: core.Input, args: ['tooltipTrigger',] },],
            'tooltipStateChanged': [{ type: core.Output },],
        };
        __decorate$r([
            OnChange(),
            __metadata$h("design:type", Object)
        ], TooltipDirective.prototype, "tooltip", void 0);
        return TooltipDirective;
    }());

    var TooltipModule = (function () {
        function TooltipModule() {
        }
        TooltipModule.forRoot = function () {
            return {
                ngModule: TooltipModule,
                providers: [TooltipConfig, ComponentLoaderFactory, PositioningService]
            };
        };
        TooltipModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule],
                        declarations: [TooltipDirective, TooltipContainerComponent],
                        exports: [TooltipDirective],
                        entryComponents: [TooltipContainerComponent]
                    },] },
        ];
        /** @nocollapse */
        TooltipModule.ctorParameters = function () { return []; };
        return TooltipModule;
    }());

    var __decorate$s = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var InlineCopyModule = /** @class */ (function () {
        function InlineCopyModule() {
        }
        InlineCopyModule = __decorate$s([
            core.NgModule({
                imports: [
                    common.CommonModule,
                    TooltipModule.forRoot()
                ],
                declarations: [
                    InlineCopyComponent
                ],
                exports: [InlineCopyComponent],
                providers: [CopyService, TooltipConfig]
            })
        ], InlineCopyModule);
        return InlineCopyModule;
    }());

    var __extends$d = (undefined && undefined.__extends) || (function () {
        var extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var __decorate$t = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata$i = (undefined && undefined.__metadata) || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    var BlockCopyComponent = /** @class */ (function (_super) {
        __extends$d(BlockCopyComponent, _super);
        /**
         * The default constructor
         */
        function BlockCopyComponent(copyService) {
            var _this = _super.call(this, copyService) || this;
            _this.copyService = copyService;
            /**
             * Copy button text
             */
            _this.buttonLabel = 'Copy';
            /**
             * Controls the expanded state of block copy
             */
            _this.expanded = false;
            /**
             * Generates a unique value for an id
             */
            _this.uniqueID = lodash.uniqueId('pfng-block-copy');
            return _this;
        }
        Object.defineProperty(BlockCopyComponent.prototype, "copyBtnId", {
            /**
             * Used to uniquly relate label to copy button
             */
            get: function () {
                return this.uniqueID + "-button";
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Toggle copyValue panel open and close
         */
        BlockCopyComponent.prototype.togglePanel = function () {
            this.expanded = !this.expanded;
        };
        /**
         * Copies the label value to the users clipboard
         */
        BlockCopyComponent.prototype.copyToClipboard = function () {
            this.copyValueToClipboard(this.label);
        };
        __decorate$t([
            core.Input('label'),
            __metadata$i("design:type", String)
        ], BlockCopyComponent.prototype, "label", void 0);
        __decorate$t([
            core.Input('buttonLabel'),
            __metadata$i("design:type", String)
        ], BlockCopyComponent.prototype, "buttonLabel", void 0);
        __decorate$t([
            core.Input('expanded'),
            __metadata$i("design:type", Boolean)
        ], BlockCopyComponent.prototype, "expanded", void 0);
        __decorate$t([
            core.Input('expandBtnAriaLabel'),
            __metadata$i("design:type", String)
        ], BlockCopyComponent.prototype, "expandBtnAriaLabel", void 0);
        BlockCopyComponent = __decorate$t([
            core.Component({
                encapsulation: core.ViewEncapsulation.None,
                selector: 'pfng-block-copy',
                template: "<div class=\"pfng-block-copy\"><label *ngIf=\"label\" class=\"pfng-block-copy-label\" [attr.for]=\"copyBtnId\">{{label}}</label><div class=\"pfng-block-copy-inner-container\"><div class=\"pfng-block-copy-preview\" [ngClass]=\"{'pf-is-open': expanded}\"><button [attr.aria-label]=\"expandBtnAriaLabel\" [attr.aria-expanded]=\"expanded\" class=\"pfng-block-copy-preview-btn\" (click)=\"togglePanel()\"><i aria-hidden=\"true\" class=\"fa pfng-block-copy-preview-icon\" [ngClass]=\"{'fa-angle-down': expanded, 'fa-angle-right': !expanded}\"></i></button><div class=\"pfng-block-copy-preview-txt-cont\" placement=\"{{tooltipPlacement ? tooltipPlacement : null}}\" tooltip=\"{{tooltip ? tooltip : null}}\"><span class=\"pfng-block-copy-preview-txt\">{{copyValue}}</span></div><button [attr.id]=\"copyBtnId\" class=\"btn btn-lg btn-default pfng-block-copy-btn\" [attr.aria-label]=\"copyBtnAriaLabel\" (click)=\"copyToClipboard()\"><span><ng-container *ngIf=\"!recentlyCopied\">{{buttonLabel}}</ng-container><ng-container *ngIf=\"recentlyCopied\"><i class=\"fa fa-check\" aria-hidden=\"true\"></i> Copied</ng-container></span></button></div><div class=\"pfng-block-copy-body\" *ngIf=\"expanded\"><span>{{copyValue}}</span></div></div></div>",
                styleUrls: ['./block-copy.component.less']
            }),
            __metadata$i("design:paramtypes", [CopyService])
        ], BlockCopyComponent);
        return BlockCopyComponent;
    }(CopyBase));

    var __decorate$u = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var BlockCopyModule = /** @class */ (function () {
        function BlockCopyModule() {
        }
        BlockCopyModule = __decorate$u([
            core.NgModule({
                imports: [
                    common.CommonModule,
                    TooltipModule.forRoot()
                ],
                declarations: [
                    BlockCopyComponent
                ],
                exports: [BlockCopyComponent],
                providers: [CopyService, TooltipConfig]
            })
        ], BlockCopyModule);
        return BlockCopyModule;
    }());

    /**
     * An empty state config containing component properties
     */
    var EmptyStateConfig = /** @class */ (function () {
        function EmptyStateConfig() {
        }
        return EmptyStateConfig;
    }());

    var __decorate$v = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata$j = (undefined && undefined.__metadata) || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    /**
     * Component for rendering an empty state.
     */
    var EmptyStateComponent = /** @class */ (function () {
        /**
         * The default constructor
         */
        function EmptyStateComponent() {
            /**
             * The event emitted when an action is selected
             */
            this.onActionSelect = new core.EventEmitter();
            this.defaultConfig = {
                title: 'No Items Available'
            };
        }
        // Initialization
        /**
         * Setup component configuration upon initialization
         */
        EmptyStateComponent.prototype.ngOnInit = function () {
            this.setupConfig();
        };
        /**
         * Check if the component config has changed
         */
        EmptyStateComponent.prototype.ngDoCheck = function () {
            // Do a deep compare on config
            if (!lodash.isEqual(this.config, this.prevConfig)) {
                this.setupConfig();
            }
        };
        /**
         * Set up default config
         */
        EmptyStateComponent.prototype.setupConfig = function () {
            if (this.config !== undefined) {
                lodash.defaults(this.config, this.defaultConfig);
            }
            else {
                this.config = lodash.cloneDeep(this.defaultConfig);
            }
            this.prevConfig = lodash.cloneDeep(this.config);
        };
        // Private
        EmptyStateComponent.prototype.handleAction = function (action) {
            if (action && action.disabled !== true) {
                this.onActionSelect.emit(action);
            }
        };
        __decorate$v([
            core.Input(),
            __metadata$j("design:type", EmptyStateConfig)
        ], EmptyStateComponent.prototype, "config", void 0);
        __decorate$v([
            core.Output('onActionSelect'),
            __metadata$j("design:type", Object)
        ], EmptyStateComponent.prototype, "onActionSelect", void 0);
        EmptyStateComponent = __decorate$v([
            core.Component({
                encapsulation: core.ViewEncapsulation.None,
                selector: 'pfng-empty-state',
                template: "<div class=\"blank-slate-pf\"><div *ngIf=\"config.iconStyleClass\" class=\"blank-slate-pf-icon\"><span class=\"{{config.iconStyleClass}}\"></span></div><h1 id=\"title\">{{config.title}}</h1><p id=\"info\" *ngIf=\"config.info !== undefined\">{{config.info}}</p><p id=\"helpLink\" *ngIf=\"config.helpLink !== undefined\">{{config.helpLink.text}} <a href=\"{{config.helpLink.url}}\">{{config.helpLink.hypertext}}</a>.</p><div *ngIf=\"config.actions?.primaryActions?.length > 0\" class=\"blank-slate-pf-main-action\"><button *ngFor=\"let action of config.actions.primaryActions\" class=\"btn btn-primary btn-lg {{action.styleClass}}\" title=\"{{action.tooltip}}\" [disabled]=\"action.disabled\" [ngClass]=\"{'disabled': action.disabled, 'hidden': action.visible === false}\" (click)=\"handleAction(action)\"><div *ngIf=\"action.template; then showButtonTemplate else showButton\"></div><ng-template #showButtonTemplate let-action=\"action\" [ngTemplateOutlet]=\"action.template\" [ngTemplateOutletContext]=\"{ action: action }\"></ng-template><ng-template #showButton>{{action.title}}</ng-template></button></div><div class=\"blank-slate-pf-secondary-action {{config.actions?.moreActionsStyleClass}}\" [ngClass]=\"{'hidden': config.actions?.moreActionsVisible === false}\" *ngIf=\"config.actions?.moreActions?.length > 0\"><button *ngFor=\"let action of config.actions.moreActions\" class=\"btn btn-default {{action.styleClass}}\" title=\"{{action.tooltip}}\" [disabled]=\"action.disabled\" [ngClass]=\"{'disabled': config.actions?.moreActionsDisabled, 'hidden': action.visible === false}\" (click)=\"handleAction(action)\">{{action.title}}</button></div></div>"
            }),
            __metadata$j("design:paramtypes", [])
        ], EmptyStateComponent);
        return EmptyStateComponent;
    }());

    var __decorate$w = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    /**
     * A module containing objects associated with the empty state component
     */
    var EmptyStateModule = /** @class */ (function () {
        function EmptyStateModule() {
        }
        EmptyStateModule = __decorate$w([
            core.NgModule({
                imports: [common.CommonModule],
                declarations: [EmptyStateComponent],
                exports: [EmptyStateComponent]
            })
        ], EmptyStateModule);
        return EmptyStateModule;
    }());

    /**
     * An object containing filter properties
     */
    var Filter = /** @class */ (function () {
        function Filter() {
        }
        return Filter;
    }());

    /**
     * A config containing properties for filters
     */
    var FilterConfig = /** @class */ (function () {
        function FilterConfig() {
        }
        return FilterConfig;
    }());

    var __decorate$x = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata$k = (undefined && undefined.__metadata) || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    /**
     * Component for the filter query field and filter query dropdown
     */
    var FilterFieldsComponent = /** @class */ (function () {
        /**
         * The default constructor
         */
        function FilterFieldsComponent() {
            /**
             * The event emitted when a filter has been added
             */
            this.onAdd = new core.EventEmitter();
            /**
             * The event emitted when a saved filter has been deleted
             */
            this.onDelete = new core.EventEmitter();
            /**
             * The event emitted when a field menu option is selected
             */
            this.onFieldSelect = new core.EventEmitter();
            /**
             * The event emitted when the user types ahead in the query input field
             */
            this.onTypeAhead = new core.EventEmitter();
            this.defaultConfig = {
                disabled: false
            };
        }
        // Initialization
        /**
         * Setup component configuration upon initialization
         */
        FilterFieldsComponent.prototype.ngOnInit = function () {
            this.setupConfig();
        };
        /**
         * Check if the component config has changed
         */
        FilterFieldsComponent.prototype.ngDoCheck = function () {
            // Do a deep compare on config
            if (!lodash.isEqual(this.config, this.prevConfig)) {
                this.setupConfig();
            }
        };
        /**
         * Set up default config
         */
        FilterFieldsComponent.prototype.setupConfig = function () {
            if (this.config !== undefined) {
                lodash.defaults(this.config, this.defaultConfig);
            }
            else {
                this.config = lodash.cloneDeep(this.defaultConfig);
            }
            if (this.config && this.config.fields === undefined) {
                this.config.fields = [];
            }
            if (this.config && this.config.tooltipPlacement === undefined) {
                this.config.tooltipPlacement = 'top';
            }
            this.initCurrentField();
            this.prevConfig = lodash.cloneDeep(this.config);
        };
        /**
         * Initialize current field and value
         */
        FilterFieldsComponent.prototype.initCurrentField = function () {
            var _this = this;
            var fieldFound = false;
            if (this._currentField !== undefined) {
                this.config.fields.forEach(function (nextField) {
                    if (nextField.id === _this._currentField.id) {
                        fieldFound = true;
                        return;
                    }
                });
            }
            if (!fieldFound) {
                this._currentField = this.config.fields[0];
                this._currentValue = null;
            }
            if (this._currentValue === undefined) {
                this._currentValue = null;
            }
        };
        /**
         * Reset current field and value
         */
        FilterFieldsComponent.prototype.reset = function () {
            this._currentField = undefined;
            this.initCurrentField();
        };
        Object.defineProperty(FilterFieldsComponent.prototype, "currentField", {
            // Accessors
            /**
             * Get the current filter field
             *
             * @returns {FilterField} The current filter field
             */
            get: function () {
                return this._currentField;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FilterFieldsComponent.prototype, "currentValue", {
            /**
             * Get the current filter field value
             *
             * @returns {string} The current filter field value
             */
            get: function () {
                return this._currentValue;
            },
            /**
             * Set the current filter field value
             *
             * @param val The current filter field value
             */
            set: function (val) {
                this._currentValue = val;
            },
            enumerable: true,
            configurable: true
        });
        // Private
        FilterFieldsComponent.prototype.deleteQuery = function ($event, filterQuery, el) {
            // Unset focus
            if (el !== undefined) {
                el.blur();
            }
            // Close previous open confirmation
            this.hideDeleteConfirm(false);
            // Show delete query confirmation
            filterQuery.showDeleteConfirm = true;
            // Menu should remain open
            $event.stopPropagation();
        };
        FilterFieldsComponent.prototype.deleteQueryCancel = function ($event, filterQuery) {
            // Hide delete query confirmation
            filterQuery.showDeleteConfirm = false;
            // Menu should remain open
            $event.stopPropagation();
        };
        FilterFieldsComponent.prototype.deleteQueryConfirm = function ($event, filterQuery) {
            // Hide delete query confirmation
            filterQuery.showDeleteConfirm = false;
            // Menu should remain open
            if (this._currentField.queries.length > 1) {
                $event.stopPropagation();
            }
            this.onDelete.emit({
                field: this._currentField,
                query: filterQuery,
                value: filterQuery.value
            });
            this._currentValue = null;
        };
        FilterFieldsComponent.prototype.fieldInputKeyPress = function ($event) {
            if ($event.which === 13 && this._currentValue && this._currentValue.length > 0) {
                this.onAdd.emit({
                    field: this._currentField,
                    value: this._currentValue
                });
                this._currentValue = undefined;
            }
        };
        // Hide all delete confirm
        FilterFieldsComponent.prototype.hideDeleteConfirm = function (isOpen) {
            this._currentField.queries.forEach(function (query) {
                query.showDeleteConfirm = false;
            });
        };
        FilterFieldsComponent.prototype.isFieldDisabled = function (field) {
            if (field.type === undefined || field.type === 'text') {
                return false;
            }
            return (field.queries === undefined || field.queries.length === 0);
        };
        FilterFieldsComponent.prototype.queryInputChange = function (value) {
            this.onTypeAhead.emit({
                field: this._currentField,
                value: this._currentValue
            });
        };
        FilterFieldsComponent.prototype.selectField = function (field) {
            this._currentField = field;
            this._currentValue = null;
            this.onFieldSelect.emit({
                field: this._currentField,
                value: this._currentValue
            });
        };
        FilterFieldsComponent.prototype.selectQuery = function (filterQuery) {
            this.onAdd.emit({
                field: this._currentField,
                query: filterQuery,
                value: filterQuery.value
            });
            this._currentValue = null;
        };
        FilterFieldsComponent.prototype.showDelete = function () {
            var result = false;
            this._currentField.queries.forEach(function (query) {
                if (query.showDelete === true) {
                    result = true;
                    return;
                }
            });
            return result;
        };
        __decorate$x([
            core.Input(),
            __metadata$k("design:type", FilterConfig)
        ], FilterFieldsComponent.prototype, "config", void 0);
        __decorate$x([
            core.Output('onAdd'),
            __metadata$k("design:type", Object)
        ], FilterFieldsComponent.prototype, "onAdd", void 0);
        __decorate$x([
            core.Output('onDelete'),
            __metadata$k("design:type", Object)
        ], FilterFieldsComponent.prototype, "onDelete", void 0);
        __decorate$x([
            core.Output('onFieldSelect'),
            __metadata$k("design:type", Object)
        ], FilterFieldsComponent.prototype, "onFieldSelect", void 0);
        __decorate$x([
            core.Output('onTypeAhead'),
            __metadata$k("design:type", Object)
        ], FilterFieldsComponent.prototype, "onTypeAhead", void 0);
        FilterFieldsComponent = __decorate$x([
            core.Component({
                encapsulation: core.ViewEncapsulation.None,
                selector: 'pfng-filter-fields',
                template: "<div class=\"filter-pf filter-fields\"><div class=\"input-group form-group\"><div class=\"input-group-btn\" dropdown><button type=\"button\" class=\"btn btn-default filter-fields dropdown-toggle\" dropdownToggle tooltip=\"Filter by\" placement=\"{{config?.tooltipPlacement}}\" [disabled]=\"config.disabled === true\">{{currentField?.title}} <span class=\"caret\"></span></button><ul class=\"dropdown-menu\" role=\"menu\" *dropdownMenu><li role=\"menuitem\" *ngFor=\"let field of config?.fields\" [ngClass]=\"{'disabled': isFieldDisabled(field), 'divider dropdown-divider': field.separator}\"><a class=\"filter-field dropdown-item\" href=\"javascript:void(0);\" role=\"menuitem\" tabindex=\"-1\" (click)=\"selectField(field)\" *ngIf=\"!field?.separator && !isFieldDisabled(field)\">{{field?.title}}</a> <a class=\"filter-field dropdown-item\" href=\"javascript:void(0);\" role=\"menuitem\" onclick=\"return false;\" *ngIf=\"!field?.separator && isFieldDisabled(field)\">{{field?.title}}</a></li></ul></div><div *ngIf=\"!currentField?.type || currentField?.type === 'text' || currentField.type === 'default'\"><input class=\"form-control\" type=\"{{currentField?.type}}\" [(ngModel)]=\"currentValue\" placeholder=\"{{currentField?.placeholder}}\" [disabled]=\"config.disabled === true\" (keypress)=\"fieldInputKeyPress($event)\"></div><div *ngIf=\"currentField?.type === 'select'\"><div class=\"btn-group bootstrap-select form-control filter-select\" dropdown><button type=\"button\" class=\"btn btn-default dropdown-toggle\" dropdownToggle [disabled]=\"config.disabled === true\"><span class=\"filter-option pull-left\">{{currentValue || currentField?.placeholder}}</span> <span class=\"caret\"></span></button><ul class=\"dropdown-menu\" role=\"menu\" *dropdownMenu><li role=\"menuitem\" *ngIf=\"currentField?.placeholder\"><a class=\"dropdown-item\" href=\"javascript:void(0);\" tabindex=\"-1\" (click)=\"selectQuery()\">{{currentField?.placeholder}}</a></li><li role=\"menuitem\" *ngFor=\"let query of currentField?.queries\" [ngClass]=\"{'selected': query?.value === currentValue, 'divider dropdown-divider': query?.separator}\"><a class=\"dropdown-item\" href=\"javascript:void(0);\" tabindex=\"-1\" (click)=\"selectQuery(query)\" *ngIf=\"!query?.separator\"><span class=\"{{query?.iconStyleClass}}\" *ngIf=\"query?.iconStyleClass\"></span> <img class=\"avatar\" [attr.src]=\"query?.imageUrl\" *ngIf=\"query?.imageUrl\"> {{query.value}}</a></li></ul></div></div><div *ngIf=\"currentField?.type === 'typeahead'\"><div class=\"btn-group bootstrap-select form-control filter-select\" *ngIf=\"config.disabled === true\"><div class=\"pull-left typeahead-input-container disabled\"><input class=\"form-control\" type=\"text\" placeholder=\"{{currentField?.placeholder}}\" [disabled]=\"config.disabled === true\"> <span class=\"caret\"></span></div></div><div class=\"btn-group bootstrap-select form-control filter-select\" dropdown (isOpenChange)=\"hideDeleteConfirm($event)\" *ngIf=\"config.disabled !== true\"><div class=\"pull-left typeahead-input-container dropdown-toggle\" dropdownToggle><input #queryInput class=\"form-control\" type=\"text\" placeholder=\"{{currentField?.placeholder}}\" [(ngModel)]=\"currentValue\" (ngModelChange)=\"queryInputChange($event)\"> <span (click)=\"queryInput.focus()\" class=\"caret\"></span></div><ul class=\"dropdown-menu\" role=\"menu\" *dropdownMenu><li role=\"menuitem\" *ngIf=\"currentField.placeholder\"><a class=\"dropdown-item\" href=\"javascript:void(0);\" tabindex=\"-1\" (click)=\"selectQuery()\">{{currentField?.placeholder}}</a></li><li role=\"menuitem\" *ngFor=\"let query of currentField?.queries\" [ngClass]=\"{'selected': query.value === currentValue,\n                          'divider dropdown-divider': query?.separator,\n                          'pfng-filter-delete-wrapper': query?.showDelete}\"><div class=\"pfng-filter-delete-slide\" [ngClass]=\"{'slide-in': query?.showDeleteConfirm}\" *ngIf=\"query?.showDelete\"><span class=\"pfng-filter-delete-text\">Delete filter?</span> <span class=\"pfng-filter-delete-confirm close\"><a class=\"padding-right-5\" href=\"javascript:void(0);\" tabindex=\"-1\" (click)=\"deleteQueryConfirm($event, query)\"><span class=\"fa fa-check\"></span> </a></span><span class=\"pfng-filter-delete-confirm close\"><a class=\"padding-right-5\" href=\"javascript:void(0);\" tabindex=\"-1\" (click)=\"deleteQueryCancel($event, query)\"><span class=\"fa fa-remove\"></span></a></span></div><a #blurable class=\"dropdown-item\" href=\"javascript:void(0);\" tabindex=\"-1\" (click)=\"selectQuery(query)\" *ngIf=\"!query?.separator\"><span class=\"pfng-filter-delete close\" *ngIf=\"query?.showDelete\"><a href=\"javascript:void(0);\" tabindex=\"-1\" [ngClass]=\"{'hidden': query?.showDeleteConfirm}\" (click)=\"deleteQuery($event, query, blurable)\"><span class=\"pficon pficon-remove\"></span> </a></span><span class=\"{{query?.iconStyleClass}}\" *ngIf=\"query?.iconStyleClass\"></span> <img class=\"avatar\" [attr.src]=\"query?.imageUrl\" *ngIf=\"query?.imageUrl\"> <span [innerHTML]=\"query.value | truncate: 20 | searchHighlight: queryInput.value\"></span></a></li></ul></div></div></div></div>"
            }),
            __metadata$k("design:paramtypes", [])
        ], FilterFieldsComponent);
        return FilterFieldsComponent;
    }());

    /*
     * An object containing properties for filter types
     */
    var FilterType = /** @class */ (function () {
        function FilterType() {
        }
        /**
         * Select type
         */
        FilterType.SELECT = 'select';
        /**
         * Text type
         */
        FilterType.TEXT = 'text';
        /**
         * Type ahead type
         */
        FilterType.TYPEAHEAD = 'typeahead';
        return FilterType;
    }());

    var __decorate$y = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata$l = (undefined && undefined.__metadata) || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    /**
     * Filter component
     */
    var FilterComponent = /** @class */ (function () {
        /**
         * The default constructor
         */
        function FilterComponent() {
            /**
             * The event emitted when a filter has been changed
             */
            this.onChange = new core.EventEmitter();
            /**
             * The event emitted when a query (i.e., saved filter) has been deleted
             */
            this.onDelete = new core.EventEmitter();
            /**
             * The event emitted when a field menu option is selected
             */
            this.onFilterSelect = new core.EventEmitter();
            /**
             * The event emitted when a filter has been changed
             */
            this.onSave = new core.EventEmitter();
            /**
             * The event emitted when the user types ahead in the query input field
             */
            this.onTypeAhead = new core.EventEmitter();
            this.defaultConfig = {
                disabled: false
            };
        }
        // Initialization
        /**
         * Setup component configuration upon initialization
         */
        FilterComponent.prototype.ngOnInit = function () {
            this.setupConfig();
        };
        /**
         * Check if the component config has changed
         */
        FilterComponent.prototype.ngDoCheck = function () {
            // Do a deep compare on config
            if (!lodash.isEqual(this.config, this.prevConfig)) {
                this.setupConfig();
            }
        };
        /**
         * Set up default config
         */
        FilterComponent.prototype.setupConfig = function () {
            if (this.config !== undefined) {
                lodash.defaults(this.config, this.defaultConfig);
            }
            else {
                this.config = lodash.cloneDeep(this.defaultConfig);
            }
            if (this.config && this.config.appliedFilters === undefined) {
                this.config.appliedFilters = [];
            }
            this.prevConfig = lodash.cloneDeep(this.config);
        };
        // Actions
        /**
         * Handle add filter event
         *
         * @param $event The FilterEvent contining properties for this event
         */
        FilterComponent.prototype.addFilter = function ($event) {
            var newFilter = {
                field: $event.field,
                query: $event.query,
                value: $event.value
            };
            if (!this.filterExists(newFilter)) {
                if (newFilter.field.type === FilterType.SELECT) {
                    this.enforceSingleSelect(newFilter);
                }
                this.config.appliedFilters.push(newFilter);
                $event.appliedFilters = this.config.appliedFilters;
                this.onChange.emit($event);
            }
        };
        /**
         * Handle clear filter event
         *
         * @param $event An array of current Filter objects
         */
        FilterComponent.prototype.clearFilter = function ($event) {
            this.config.appliedFilters = $event;
            this.onChange.emit({
                appliedFilters: $event
            });
        };
        /**
         * Handle delete query (i.e., saved filter) event
         *
         * @param $event The FilterEvent contining properties for this event
         */
        FilterComponent.prototype.deleteQuery = function ($event) {
            this.onDelete.emit($event);
        };
        /**
         * Handle filter field selected event
         *
         * @param $event The FilterEvent contining properties for this event
         */
        FilterComponent.prototype.fieldSelected = function ($event) {
            this.onFilterSelect.emit($event);
        };
        /**
         * Reset current field
         */
        FilterComponent.prototype.resetCurrentField = function () {
            this.filterFields.reset();
        };
        /**
         * Handle save filter event
         *
         * @param $event An array of current Filter objects
         */
        FilterComponent.prototype.saveFilter = function ($event) {
            this.onSave.emit($event);
        };
        /**
         * Handle type ahead event
         *
         * @param $event The FilterEvent contining properties for this event
         */
        FilterComponent.prototype.typeAhead = function ($event) {
            this.onTypeAhead.emit($event);
        };
        // Private
        FilterComponent.prototype.enforceSingleSelect = function (filter$$1) {
            lodash.remove(this.config.appliedFilters, { title: filter$$1.field.title });
        };
        FilterComponent.prototype.filterExists = function (filter$$1) {
            var foundFilter = lodash.find(this.config.appliedFilters, {
                field: filter$$1.field,
                value: filter$$1.value
            });
            return foundFilter !== undefined;
        };
        __decorate$y([
            core.Input(),
            __metadata$l("design:type", FilterConfig)
        ], FilterComponent.prototype, "config", void 0);
        __decorate$y([
            core.Output('onChange'),
            __metadata$l("design:type", Object)
        ], FilterComponent.prototype, "onChange", void 0);
        __decorate$y([
            core.Output('onDelete'),
            __metadata$l("design:type", Object)
        ], FilterComponent.prototype, "onDelete", void 0);
        __decorate$y([
            core.Output('onFieldSelect'),
            __metadata$l("design:type", Object)
        ], FilterComponent.prototype, "onFilterSelect", void 0);
        __decorate$y([
            core.Output('onSave'),
            __metadata$l("design:type", Object)
        ], FilterComponent.prototype, "onSave", void 0);
        __decorate$y([
            core.Output('onTypeAhead'),
            __metadata$l("design:type", Object)
        ], FilterComponent.prototype, "onTypeAhead", void 0);
        __decorate$y([
            core.ViewChild('filterFields'),
            __metadata$l("design:type", FilterFieldsComponent)
        ], FilterComponent.prototype, "filterFields", void 0);
        FilterComponent = __decorate$y([
            core.Component({
                encapsulation: core.ViewEncapsulation.None,
                selector: 'pfng-filter',
                template: "<div class=\"filter-pf\"><pfng-filter-fields #filterFields [config]=\"config\" (onAdd)=\"addFilter($event)\" (onDelete)=\"deleteQuery($event)\" (onFieldSelect)=\"fieldSelected($event)\" (onTypeAhead)=\"typeAhead($event)\"></pfng-filter-fields><pfng-filter-results [config]=\"config\" (onClear)=\"clearFilter($event)\" (onSave)=\"saveFilter($event)\"></pfng-filter-results></div>"
            }),
            __metadata$l("design:paramtypes", [])
        ], FilterComponent);
        return FilterComponent;
    }());

    /**
     * An object containing properties for filter events
     */
    var FilterEvent = /** @class */ (function () {
        function FilterEvent() {
        }
        return FilterEvent;
    }());

    /**
     * An object containing properties for a filterable field, used to select categories of filters
     */
    var FilterField = /** @class */ (function () {
        function FilterField() {
        }
        return FilterField;
    }());

    /**
     * Configuration service for the Popover directive.
     * You can inject this service, typically in your root component, and customize
     * the values of its properties in order to provide default values for all the
     * popovers used in the application.
     */
    var PopoverConfig = (function () {
        function PopoverConfig() {
            /**
             * Placement of a popover. Accepts: "top", "bottom", "left", "right", "auto"
             */
            this.placement = 'top';
            /**
             * Specifies events that should trigger. Supports a space separated list of
             * event names.
             */
            this.triggers = 'click';
            this.outsideClick = false;
        }
        PopoverConfig.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        PopoverConfig.ctorParameters = function () { return []; };
        return PopoverConfig;
    }());

    var PopoverContainerComponent = (function () {
        function PopoverContainerComponent(config) {
            Object.assign(this, config);
        }
        Object.defineProperty(PopoverContainerComponent.prototype, "isBs3", {
            get: function () {
                return isBs3();
            },
            enumerable: true,
            configurable: true
        });
        PopoverContainerComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'popover-container',
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        // tslint:disable-next-line
                        host: {
                            '[class]': '"popover in popover-" + placement + " " + "bs-popover-" + placement + " " + placement + " " + containerClass',
                            '[class.show]': '!isBs3',
                            role: 'tooltip',
                            style: 'display:block;'
                        },
                        styles: [
                            "\n    :host.bs-popover-top .arrow, :host.bs-popover-bottom .arrow {\n      left: 50%;\n      margin-left: -8px;\n    }\n    :host.bs-popover-left .arrow, :host.bs-popover-right .arrow {\n      top: 50%;\n      margin-top: -8px;\n    }\n  "
                        ],
                        template: "<div class=\"popover-arrow arrow\"></div> <h3 class=\"popover-title popover-header\" *ngIf=\"title\">{{ title }}</h3> <div class=\"popover-content popover-body\"> <ng-content></ng-content> </div> "
                    },] },
        ];
        /** @nocollapse */
        PopoverContainerComponent.ctorParameters = function () { return [
            { type: PopoverConfig, },
        ]; };
        PopoverContainerComponent.propDecorators = {
            'placement': [{ type: core.Input },],
            'title': [{ type: core.Input },],
        };
        return PopoverContainerComponent;
    }());

    /**
     * A lightweight, extensible directive for fancy popover creation.
     */
    var PopoverDirective = (function () {
        function PopoverDirective(_elementRef, _renderer, _viewContainerRef, _config, cis) {
            /**
             * Close popover on outside click
             */
            this.outsideClick = false;
            /**
             * Css class for popover container
             */
            this.containerClass = '';
            this._isInited = false;
            this._popover = cis
                .createLoader(_elementRef, _viewContainerRef, _renderer)
                .provide({ provide: PopoverConfig, useValue: _config });
            Object.assign(this, _config);
            this.onShown = this._popover.onShown;
            this.onHidden = this._popover.onHidden;
            // fix: no focus on button on Mac OS #1795
            if (typeof window !== 'undefined') {
                _elementRef.nativeElement.addEventListener('click', function () {
                    try {
                        _elementRef.nativeElement.focus();
                    }
                    catch (err) {
                        return;
                    }
                });
            }
        }
        Object.defineProperty(PopoverDirective.prototype, "isOpen", {
            /**
             * Returns whether or not the popover is currently being shown
             */
            get: function () {
                return this._popover.isShown;
            },
            set: function (value) {
                if (value) {
                    this.show();
                }
                else {
                    this.hide();
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Opens an element’s popover. This is considered a “manual” triggering of
         * the popover.
         */
        PopoverDirective.prototype.show = function () {
            if (this._popover.isShown || !this.popover) {
                return;
            }
            this._popover
                .attach(PopoverContainerComponent)
                .to(this.container)
                .position({ attachment: this.placement })
                .show({
                content: this.popover,
                context: this.popoverContext,
                placement: this.placement,
                title: this.popoverTitle,
                containerClass: this.containerClass
            });
            this.isOpen = true;
        };
        /**
         * Closes an element’s popover. This is considered a “manual” triggering of
         * the popover.
         */
        PopoverDirective.prototype.hide = function () {
            if (this.isOpen) {
                this._popover.hide();
                this.isOpen = false;
            }
        };
        /**
         * Toggles an element’s popover. This is considered a “manual” triggering of
         * the popover.
         */
        PopoverDirective.prototype.toggle = function () {
            if (this.isOpen) {
                return this.hide();
            }
            this.show();
        };
        PopoverDirective.prototype.ngOnInit = function () {
            var _this = this;
            // fix: seems there are an issue with `routerLinkActive`
            // which result in duplicated call ngOnInit without call to ngOnDestroy
            // read more: https://github.com/valor-software/ngx-bootstrap/issues/1885
            if (this._isInited) {
                return;
            }
            this._isInited = true;
            this._popover.listen({
                triggers: this.triggers,
                outsideClick: this.outsideClick,
                show: function () { return _this.show(); }
            });
        };
        PopoverDirective.prototype.ngOnDestroy = function () {
            this._popover.dispose();
        };
        PopoverDirective.decorators = [
            { type: core.Directive, args: [{ selector: '[popover]', exportAs: 'bs-popover' },] },
        ];
        /** @nocollapse */
        PopoverDirective.ctorParameters = function () { return [
            { type: core.ElementRef, },
            { type: core.Renderer2, },
            { type: core.ViewContainerRef, },
            { type: PopoverConfig, },
            { type: ComponentLoaderFactory, },
        ]; };
        PopoverDirective.propDecorators = {
            'popover': [{ type: core.Input },],
            'popoverContext': [{ type: core.Input },],
            'popoverTitle': [{ type: core.Input },],
            'placement': [{ type: core.Input },],
            'outsideClick': [{ type: core.Input },],
            'triggers': [{ type: core.Input },],
            'container': [{ type: core.Input },],
            'containerClass': [{ type: core.Input },],
            'isOpen': [{ type: core.Input },],
            'onShown': [{ type: core.Output },],
            'onHidden': [{ type: core.Output },],
        };
        return PopoverDirective;
    }());

    var PopoverModule = (function () {
        function PopoverModule() {
        }
        PopoverModule.forRoot = function () {
            return {
                ngModule: PopoverModule,
                providers: [PopoverConfig, ComponentLoaderFactory, PositioningService]
            };
        };
        PopoverModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule],
                        declarations: [PopoverDirective, PopoverContainerComponent],
                        exports: [PopoverDirective],
                        entryComponents: [PopoverContainerComponent]
                    },] },
        ];
        /** @nocollapse */
        PopoverModule.ctorParameters = function () { return []; };
        return PopoverModule;
    }());

    var __decorate$z = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata$m = (undefined && undefined.__metadata) || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    /**
     * Component for the filter results
     */
    var FilterResultsComponent = /** @class */ (function () {
        /**
         * The default constructor
         */
        function FilterResultsComponent() {
            /**
             * The event emitted when the clear action is selected
             */
            this.onClear = new core.EventEmitter();
            /**
             * The event emitted when the save action is selected
             */
            this.onSave = new core.EventEmitter();
            this.defaultConfig = {
                disabled: false
            };
        }
        // Initialization
        /**
         * Setup component configuration upon initialization
         */
        FilterResultsComponent.prototype.ngOnInit = function () {
            this.setupConfig();
        };
        /**
         * Check if the component config has changed
         */
        FilterResultsComponent.prototype.ngDoCheck = function () {
            // Do a deep compare on config
            if (!lodash.isEqual(this.config, this.prevConfig)) {
                this.setupConfig();
            }
        };
        /**
         * Set up default config
         */
        FilterResultsComponent.prototype.setupConfig = function () {
            if (this.config !== undefined) {
                lodash.defaults(this.config, this.defaultConfig);
            }
            else {
                this.config = lodash.cloneDeep(this.defaultConfig);
            }
            if (this.config && this.config.appliedFilters === undefined) {
                this.config.appliedFilters = [];
            }
            if (this.config && this.config.resultsCount === undefined) {
                this.config.resultsCount = 0;
            }
            if (this.config && this.config.selectedCount === undefined) {
                this.config.selectedCount = 0;
            }
            if (this.config && this.config.totalCount === undefined) {
                this.config.totalCount = 0;
            }
            this.prevConfig = lodash.cloneDeep(this.config);
        };
        // Private
        FilterResultsComponent.prototype.clearFilter = function (filter$$1) {
            var newFilters = [];
            this.config.appliedFilters.forEach(function (appliedFilter) {
                if (appliedFilter.field.title !== filter$$1.field.title
                    || appliedFilter.value !== filter$$1.value) {
                    newFilters.push(appliedFilter);
                }
            });
            this.config.appliedFilters = newFilters;
            this.onClear.emit(this.config.appliedFilters);
        };
        FilterResultsComponent.prototype.clearAllFilters = function () {
            this.config.appliedFilters = [];
            this.onClear.emit(this.config.appliedFilters);
        };
        FilterResultsComponent.prototype.saveAllFilters = function () {
            this.onSave.emit({
                appliedFilters: this.config.appliedFilters,
                value: lodash.clone(this.saveFilterName)
            });
            this.saveFilterName = ''; // Reset
        };
        __decorate$z([
            core.Input(),
            __metadata$m("design:type", FilterConfig)
        ], FilterResultsComponent.prototype, "config", void 0);
        __decorate$z([
            core.Output('onClear'),
            __metadata$m("design:type", Object)
        ], FilterResultsComponent.prototype, "onClear", void 0);
        __decorate$z([
            core.Output('onSave'),
            __metadata$m("design:type", Object)
        ], FilterResultsComponent.prototype, "onSave", void 0);
        FilterResultsComponent = __decorate$z([
            core.Component({
                encapsulation: core.ViewEncapsulation.None,
                selector: 'pfng-filter-results',
                template: "<div class=\"filter-pf\" *ngIf=\"config && (config.appliedFilters && config.appliedFilters.length > 0) || config.totalCount > 0\"><div class=\"row toolbar-pf-results\"><div [ngClass]=\"{'col-sm-9': config.totalCount !== undefined, 'col-sm-12': config.totalCount === undefined}\"><h5 *ngIf=\"config.appliedFilters.length > 0 && config.resultsCount >= 0\">{{config.resultsCount}} Results</h5><p *ngIf=\"config.appliedFilters.length > 0\">Active filters:</p><ul class=\"list-inline\"><li *ngFor=\"let filter of config.appliedFilters\"><span class=\"active-filter label label-info\">{{filter.field.title}}: {{filter.value}} <span class=\"margin-left-5 pficon pficon-close\" (click)=\"clearFilter(filter)\" *ngIf=\"config.disabled !== true\"></span></span></li></ul><p><a class=\"clear-filters\" href=\"javascript:void(0)\" [class.disabled]=\"config.disabled === true\" (click)=\"config.disabled !== true && clearAllFilters()\" *ngIf=\"config.appliedFilters.length > 0\">Clear All Filters</a></p><p class=\"pfng-save-filter margin-left-10\"><ng-template #saveFilterTemplate><label class=\"control-label required-pf margin-right-15\" for=\"saveFilterName\">Name your filter</label><span class=\"pfng-save-filter-close close\"><span class=\"pficon pficon-close\" (click)=\"saveFilterPop.hide(); saveFilterName = ''\"></span></span><div class=\"margin-top-5\"><input class=\"form-control\" id=\"saveFilterName\" name=\"saveFilterName\" type=\"text\" [(ngModel)]=\"saveFilterName\"></div><div class=\"pfng-save-filter-divider\"></div><div class=\"pfng-save-filter-footer\"><button class=\"btn btn-default\" (click)=\"saveFilterPop.hide(); saveFilterName = ''\">Cancel</button> <span class=\"margin-left-5\"><button class=\"btn btn-primary\" [disabled]=\"saveFilterName === undefined || saveFilterName?.length === 0\" (click)=\"saveAllFilters(); saveFilterPop.hide()\">Save</button></span></div></ng-template><span placement=\"bottom\" [popover]=\"saveFilterTemplate\" #saveFilterPop=\"bs-popover\"><a *ngIf=\"config.showSaveFilter && config.disabled !== true\">Save Filter</a> </span><a href=\"javascript:void(0)\" [class.disabled]=\"config.disabled === true\" *ngIf=\"config.showSaveFilter && config.disabled === true\">Save Filter</a></p></div><div class=\"col-sm-3 table-view-pf-select-results\" *ngIf=\"config.totalCount > 0\"><strong>{{config.selectedCount}}</strong> of <strong>{{config.totalCount}}</strong> selected</div></div></div>"
            }),
            __metadata$m("design:paramtypes", [])
        ], FilterResultsComponent);
        return FilterResultsComponent;
    }());

    /**
     * An object containing properties for a filterable query, used when filterType is 'select'
     */
    var FilterQuery = /** @class */ (function () {
        function FilterQuery() {
        }
        return FilterQuery;
    }());

    var __decorate$A = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    /**
     * Search highlight pipe
     *
     * This is currently used with the type ahead feature of the filter fields component
     */
    var SearchHighlightPipe = /** @class */ (function () {
        function SearchHighlightPipe() {
        }
        /**
         *
         * @param {string} val The string to highlight
         * @param {string} search The text to search for
         * @returns {any} The given string with highlighted text
         */
        SearchHighlightPipe.prototype.transform = function (val, search) {
            if (search !== undefined && search.length > 0) {
                var lowerVal = val.toLowerCase();
                search = search.toLowerCase();
                if (!lowerVal)
                    return '';
                else
                    return this.convertToOriginal(lowerVal.split(search).join('<b>' + search + '</b>'), val);
            }
            else {
                return val;
            }
        };
        SearchHighlightPipe.prototype.convertToOriginal = function (str, original) {
            var output = '';
            var inTag = false;
            var j = 0;
            for (var i = 0; i < str.length; i++) {
                if (str[i] === '<') {
                    inTag = true;
                    output += str[i];
                }
                else if (str[i] === '>') {
                    inTag = false;
                    output += str[i];
                }
                else if (!inTag) {
                    output += original[j++];
                }
                else {
                    output += str[i];
                }
            }
            return output;
        };
        SearchHighlightPipe = __decorate$A([
            core.Pipe({ name: 'searchHighlight' })
        ], SearchHighlightPipe);
        return SearchHighlightPipe;
    }());

    var __decorate$B = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    /**
     * A module containing objects associated with the search highlight pipe
     */
    var SearchHighlightPipeModule = /** @class */ (function () {
        function SearchHighlightPipeModule() {
        }
        SearchHighlightPipeModule = __decorate$B([
            core.NgModule({
                declarations: [
                    SearchHighlightPipe
                ],
                exports: [
                    SearchHighlightPipe
                ]
            })
        ], SearchHighlightPipeModule);
        return SearchHighlightPipeModule;
    }());

    var __decorate$C = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    /**
     * Truncate pipe
     *
     * This is currently used with the save filter feature of the filter fields component
     */
    var TruncatePipe = /** @class */ (function () {
        function TruncatePipe() {
        }
        /**
         * Truncate given string
         *
         * @param {string} value The string to truncate
         * @param {string} limit The number of characters to truncate the string at
         * @param {string} trail The trailing characters representing truncation
         * @returns {string} The truncated string
         */
        TruncatePipe.prototype.transform = function (value, limit, trail) {
            if (limit === void 0) { limit = 10; }
            if (trail === void 0) { trail = '...'; }
            return (value.length > limit) ? value.substring(0, limit) + trail : value;
        };
        TruncatePipe = __decorate$C([
            core.Pipe({ name: 'truncate' })
        ], TruncatePipe);
        return TruncatePipe;
    }());

    var __decorate$D = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    /**
     * A module containing objects associated with the truncate pipe
     */
    var TruncatePipeModule = /** @class */ (function () {
        function TruncatePipeModule() {
        }
        TruncatePipeModule = __decorate$D([
            core.NgModule({
                declarations: [
                    TruncatePipe
                ],
                exports: [
                    TruncatePipe
                ]
            })
        ], TruncatePipeModule);
        return TruncatePipeModule;
    }());

    var __decorate$E = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    /**
     * A module containing objects associated with filter components
     */
    var FilterModule = /** @class */ (function () {
        function FilterModule() {
        }
        FilterModule = __decorate$E([
            core.NgModule({
                imports: [
                    BsDropdownModule.forRoot(),
                    common.CommonModule,
                    forms.FormsModule,
                    PopoverModule.forRoot(),
                    SearchHighlightPipeModule,
                    TooltipModule.forRoot(),
                    TruncatePipeModule
                ],
                declarations: [FilterComponent, FilterFieldsComponent, FilterResultsComponent],
                exports: [FilterComponent, FilterFieldsComponent, FilterResultsComponent],
                providers: [BsDropdownConfig, TooltipConfig]
            })
        ], FilterModule);
        return FilterModule;
    }());

    var __decorate$F = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata$n = (undefined && undefined.__metadata) || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    /**
     * List base
     */
    var ListBase = /** @class */ (function () {
        /**
         * The default constructor
         */
        function ListBase() {
            /**
             * The event emitted when an action (e.g., button, kebab, etc.) has been selected
             */
            this.onActionSelect = new core.EventEmitter();
            /**
             * The event emitted when an item has been clicked
             */
            this.onClick = new core.EventEmitter();
            /**
             * The event emitted when an item is double clicked
             */
            this.onDblClick = new core.EventEmitter();
            /**
             * The event emitted when an item selection has been changed
             */
            this.onSelectionChange = new core.EventEmitter();
        }
        // Initialization
        /**
         * Set up default config
         */
        ListBase.prototype.setupConfig = function () {
            var config = this.getConfig();
            if (config.multiSelect === undefined || config.multiSelect === false) {
                var selectedItems = this.getSelectedItems(this.items);
                if (selectedItems.length > 0) {
                    this.selectSingleItem(selectedItems[0]);
                }
            }
            if (config.multiSelect && config.dblClick) {
                throw new Error('ListComponent - Illegal use: ' +
                    'Cannot use both multi-select and double click selection at the same time.');
            }
            if (config.selectItems && config.showCheckbox) {
                throw new Error('ListComponent - Illegal use: ' +
                    'Cannot use both checkbox and click selection at the same time.');
            }
            if (config.selectItems && config.showRadioButton) {
                throw new Error('ListComponent - Illegal use: ' +
                    'Cannot use both radio button and single row selection at the same time.');
            }
            if (config.showRadioButton && config.showCheckbox) {
                throw new Error('ListComponent - Illegal use: ' +
                    'Cannot use both radio button and checkbox at the same time.');
            }
        };
        Object.defineProperty(ListBase.prototype, "itemsEmpty", {
            // Accessors
            /**
             * Get the flag indicating list has no items
             *
             * @returns {boolean} The flag indicating list has no items
             */
            get: function () {
                return !(this.items !== undefined && this.items.length > 0);
            },
            enumerable: true,
            configurable: true
        });
        // Actions
        /**
         * Helper to generate action select event
         *
         * @param {Action} action The selected action
         */
        ListBase.prototype.handleAction = function (action) {
            if (action && action.disabled !== true) {
                this.onActionSelect.emit(action);
            }
        };
        // Selection
        /**
         * Helper to generate selection change event
         *
         * @param item The selected item
         */
        ListBase.prototype.checkboxChange = function (item) {
            this.onSelectionChange.emit({
                item: item,
                selectedItems: this.getSelectedItems(this.items)
            });
        };
        /**
         * Helper to generate double click event
         *
         * @param {MouseEvent} $event The triggered event
         * @param item The double clicked item
         */
        ListBase.prototype.dblClick = function ($event, item) {
            var config = this.getConfig();
            if (config.dblClick === true) {
                this.onDblClick.emit({
                    item: item
                });
            }
        };
        /**
         * Helper to deselect given items items and children
         *
         * @param {any[]} items The items to be deselected
         */
        ListBase.prototype.deselectItems = function (items) {
            if (items !== undefined) {
                for (var i = 0; i < items.length; i++) {
                    items[i].selected = false;
                    if (Array.isArray(items[i].children)) {
                        this.deselectItems(items[i].children);
                    }
                }
            }
        };
        /**
         * Helper to retrieve selected items
         *
         * @param {any[]} items The items containing possible selections
         * @returns {any[]} A list of selected items
         */
        ListBase.prototype.getSelectedItems = function (items) {
            var selectedItems = [];
            if (items !== undefined) {
                for (var i = 0; i < items.length; i++) {
                    if (items[i].selected) {
                        selectedItems.push(items[i]);
                    }
                    if (Array.isArray(items[i].children)) {
                        var selectedChildren = this.getSelectedItems(items[i].children);
                        selectedItems = selectedItems.concat(selectedChildren);
                    }
                }
            }
            return selectedItems;
        };
        /**
         * Helper to generate selection change event
         *
         * @param item The selected item
         */
        ListBase.prototype.radioButtonChange = function (item) {
            var selected = item.selected;
            this.deselectItems(this.items);
            if (!selected) {
                this.selectSingleItem(item);
            }
            this.onSelectionChange.emit({
                item: item,
                selectedItems: this.getSelectedItems(this.items)
            });
        };
        /**
         * Helper to select a single item and deselect all others
         *
         * @param item The item to select
         */
        ListBase.prototype.selectSingleItem = function (item) {
            this.deselectItems(this.items);
            item.selected = true;
        };
        /**
         * Select or deselect an item
         *
         * @param item The item to select or deselect
         * @param {boolean} selected True if item should be selected
         */
        ListBase.prototype.selectItem = function (item, selected) {
            var config = this.getConfig();
            // Are we using checkboxes or radiobuttons?
            if (config.showCheckbox) {
                item.selected = selected;
                return;
            }
            if (config.showRadioButton) {
                this.deselectItems(this.items);
                this.selectSingleItem(item);
                return;
            }
            // Multiple item selection
            if (config.multiSelect && !config.dblClick) {
                item.selected = selected;
            }
            else {
                // Single item selection
                this.deselectItems(this.items);
                this.selectSingleItem(item);
            }
        };
        /**
         * Helper to toggle item selection
         *
         * @param {MouseEvent} $event The triggered event
         * @param item The item to select
         */
        ListBase.prototype.toggleSelection = function ($event, item) {
            var config = this.getConfig();
            var selectionChanged = false;
            // Always emit click event
            this.onClick.emit({
                item: item
            });
            // Go no further if click selection isn't enabled
            if (!config.selectItems) {
                return;
            }
            // Multiple item selection
            if (config.multiSelect && !config.dblClick) {
                // Item's 'selected' prop may be undefined initially
                if (item.selected === true) {
                    item.selected = false;
                }
                else {
                    item.selected = true;
                }
                selectionChanged = true;
            }
            else {
                // Single item selection
                if (item.selected === true) {
                    // Avoid accidentally deselecting by dblClick
                    if (!config.dblClick) {
                        this.deselectItems(this.items);
                        selectionChanged = true;
                    }
                }
                else {
                    this.selectSingleItem(item);
                    selectionChanged = true;
                }
            }
            // Emit event only if selection changed
            if (selectionChanged === true) {
                this.onSelectionChange.emit({
                    item: item,
                    selectedItems: this.getSelectedItems(this.items)
                });
            }
        };
        __decorate$F([
            core.Input(),
            __metadata$n("design:type", core.TemplateRef)
        ], ListBase.prototype, "actionTemplate", void 0);
        __decorate$F([
            core.Input(),
            __metadata$n("design:type", Array)
        ], ListBase.prototype, "items", void 0);
        __decorate$F([
            core.Input(),
            __metadata$n("design:type", core.TemplateRef)
        ], ListBase.prototype, "itemTemplate", void 0);
        __decorate$F([
            core.Output('onActionSelect'),
            __metadata$n("design:type", Object)
        ], ListBase.prototype, "onActionSelect", void 0);
        __decorate$F([
            core.Output('onClick'),
            __metadata$n("design:type", Object)
        ], ListBase.prototype, "onClick", void 0);
        __decorate$F([
            core.Output('onDblClick'),
            __metadata$n("design:type", Object)
        ], ListBase.prototype, "onDblClick", void 0);
        __decorate$F([
            core.Output('onSelectionChange'),
            __metadata$n("design:type", Object)
        ], ListBase.prototype, "onSelectionChange", void 0);
        return ListBase;
    }());

    /**
     * A config containing properties for tree list
     */
    var ListConfigBase = /** @class */ (function () {
        function ListConfigBase() {
        }
        return ListConfigBase;
    }());

    /**
     * An object containing properties for list events
     */
    var ListEvent = /** @class */ (function () {
        function ListEvent() {
        }
        return ListEvent;
    }());

    var __extends$e = (undefined && undefined.__extends) || (function () {
        var extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * A config containing properties for list view
     */
    var ListConfig = /** @class */ (function (_super) {
        __extends$e(ListConfig, _super);
        function ListConfig() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return ListConfig;
    }(ListConfigBase));

    var __extends$f = (undefined && undefined.__extends) || (function () {
        var extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var __decorate$G = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata$o = (undefined && undefined.__metadata) || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    /**
     * List component
     *
     * For items, use a template named itemTemplate to contain content for each item. For each item in the items array, the
     * expansion can be disabled by setting disabled to true on the item. If using actions, use a template named
     * actionTemplate to contain expandable content for the actions of each item. If using expand items, use a template
     * named itemExpandedTemplate to contain expandable content for each item.
     *
     * Cannot use both multi-select and double click selection at the same time
     * Cannot use both checkbox and click selection at the same time
     *
     * Unique IDs are generated for each list item, which can be overridden by providing an id for the pfng-list tag.
     *
     * Usage:
     * <br/><code>import { BasicListModule } from 'patternfly-ng/list';</code>
     *
     * Or:
     * <br/><code>import { BasicListModule } from 'patternfly-ng';</code>
     */
    var ListComponent = /** @class */ (function (_super) {
        __extends$f(ListComponent, _super);
        /**
         * The default constructor
         */
        function ListComponent(el) {
            var _this = _super.call(this) || this;
            _this.el = el;
            /**
             * The event emitted when an item pin has been changed
             */
            _this.onPinChange = new core.EventEmitter();
            _this.defaultConfig = {
                dblClick: false,
                hideClose: false,
                multiSelect: false,
                selectedItems: [],
                selectionMatchProp: 'uuid',
                selectItems: false,
                showCheckbox: false,
                showRadioButton: false,
                useExpandItems: false
            };
            _this.id = lodash.uniqueId('pfng-list');
            return _this;
        }
        // Initialization
        /**
         * Setup component configuration upon initialization
         */
        ListComponent.prototype.ngOnInit = function () {
            this.setupConfig();
        };
        /**
         * Check if the component config has changed
         */
        ListComponent.prototype.ngDoCheck = function () {
            // Do a deep compare on config
            if (!lodash.isEqual(this.config, this.prevConfig)) {
                this.setupConfig();
            }
        };
        /**
         * Set up default config
         */
        ListComponent.prototype.setupConfig = function () {
            if (this.config !== undefined) {
                lodash.defaults(this.config, this.defaultConfig);
            }
            else {
                this.config = lodash.cloneDeep(this.defaultConfig);
            }
            _super.prototype.setupConfig.call(this);
            this.prevConfig = lodash.cloneDeep(this.config);
        };
        /**
         * Return component config
         *
         * @returns {} ListConfig The component config
         */
        ListComponent.prototype.getConfig = function () {
            return this.config;
        };
        /**
         * Return an ID for the given element prefix and index (e.g., 'pfng-list1-item0')
         *
         * Note: The ID prefix can be overridden by providing an id for the pfng-list tag.
         *
         * @param {string} suffix The element suffix (e.g., 'item')
         * @param {number} index The current item index
         * @returns {string}
         */
        ListComponent.prototype.getId = function (suffix, index) {
            var result = this.id;
            if (this.el.nativeElement.id !== undefined && this.el.nativeElement.id.length > 0) {
                result = this.el.nativeElement.id;
            }
            return result + '-' + suffix + index;
        };
        // Toggle
        ListComponent.prototype.closeExpandArea = function (item) {
            item.expandId = undefined;
            item.expanded = false;
        };
        /**
         * Toggles the list item expansion
         *
         * @param {MouseEvent} $event The event emitted when an item has been clicked
         * @param {Object} item The object associated with the current row
         */
        ListComponent.prototype.toggleExpandArea = function ($event, item) {
            // Do nothing if item expansion is disabled
            if (!this.config.useExpandItems) {
                return;
            }
            // Do not trigger for child items, only on the DOM element to which the event is attached
            if ($event.target !== $event.currentTarget) {
                return;
            }
            // Item may already be open due to compound expansion
            if (item.expanded && item.expandId !== undefined) {
                item.expandId = undefined;
                return;
            }
            item.expandId = undefined;
            item.expanded = !item.expanded;
        };
        ListComponent.prototype.togglePin = function ($event, item) {
            item.showPin = (item.showPin === undefined) ? true : !item.showPin;
            this.onPinChange.emit({
                item: item
            });
        };
        __decorate$G([
            core.Input(),
            __metadata$o("design:type", core.TemplateRef)
        ], ListComponent.prototype, "actionHeadingTemplate", void 0);
        __decorate$G([
            core.Input(),
            __metadata$o("design:type", ListConfig)
        ], ListComponent.prototype, "config", void 0);
        __decorate$G([
            core.Input(),
            __metadata$o("design:type", core.TemplateRef)
        ], ListComponent.prototype, "expandTemplate", void 0);
        __decorate$G([
            core.Input(),
            __metadata$o("design:type", core.TemplateRef)
        ], ListComponent.prototype, "itemHeadingTemplate", void 0);
        __decorate$G([
            core.Output('onPinChange'),
            __metadata$o("design:type", Object)
        ], ListComponent.prototype, "onPinChange", void 0);
        ListComponent = __decorate$G([
            core.Component({
                encapsulation: core.ViewEncapsulation.None,
                selector: 'pfng-list',
                template: "<div class=\"list-pf\" *ngIf=\"!itemsEmpty\"><div class=\"list-pf-item pfng-list-heading {{item?.itemStyleClass}}\" *ngIf=\"itemHeadingTemplate || actionHeadingTemplate\"><div class=\"list-pf-container\"><div class=\"pfng-list-pin-placeholder\" *ngIf=\"config.usePinItems\"></div><div class=\"list-pf-chevron\" *ngIf=\"config.useExpandItems\"><div class=\"pfng-list-expand-placeholder\"></div></div><div class=\"list-pf-select\" *ngIf=\"config.showCheckbox || config.showRadioButton\"><div class=\"pfng-list-cb-placeholder\"></div></div><div class=\"list-pf-content list-pf-content-flex\"><div class=\"pfng-list-content\"><ng-template *ngIf=\"itemHeadingTemplate\" [ngTemplateOutlet]=\"itemHeadingTemplate\" [ngTemplateOutletContext]=\"{ item: item, index: i }\"></ng-template></div><div class=\"list-pf-actions\"><ng-template *ngIf=\"actionHeadingTemplate\" [ngTemplateOutlet]=\"actionHeadingTemplate\" [ngTemplateOutletContext]=\"{ item: item, index: i }\"></ng-template></div></div></div></div><div class=\"list-pf-item {{item?.itemStyleClass}}\" [ngClass]=\"{'active': item.selected || item.expanded}\" *ngFor=\"let item of (config.usePinItems ? (items | sortArray: 'showPin': true) : items); let i = index\"><div class=\"list-pf-container\" [id]=\"getId('item', i)\" (click)=\"toggleExpandArea($event, item)\"><div class=\"pfng-list-pin-container\" *ngIf=\"config.usePinItems\"><div class=\"pfng-list-pin-placeholder\" [ngClass]=\"{'multi-ctrls': config.useExpandItems || config.showCheckbox || config.showRadioButton}\" *ngIf=\"item.showPin !== true\"></div><div class=\"pfng-list-pin\" [ngClass]=\"{'multi-ctrls': config.useExpandItems || config.showCheckbox || config.showRadioButton}\" *ngIf=\"item.showPin === true\"><a href=\"javascript:void(0);\" tabindex=\"-1\" title=\"Remove pin\" (click)=\"togglePin($event, item)\"><span class=\"fa fa-thumb-tack\"></span></a></div></div><div class=\"list-pf-chevron pfng-list-expand\" *ngIf=\"config.useExpandItems\"><div class=\"pfng-list-expand-placeholder\" *ngIf=\"item.hideExpandToggle === true\"></div><span class=\"fa fa-angle-right\" *ngIf=\"item.hideExpandToggle !== true\" (click)=\"toggleExpandArea($event, item)\" [ngClass]=\"{'fa-angle-down': item.expanded && item.expandId === undefined}\"></span></div><div class=\"list-pf-select\" *ngIf=\"config.showCheckbox && !config.showRadioButton\"><input type=\"checkbox\" [id]=\"getId('checkbox', i)\" [(ngModel)]=\"item.selected\" (ngModelChange)=\"checkboxChange(item)\"></div><div class=\"list-pf-select\" *ngIf=\"!config.showCheckbox && config.showRadioButton\"><input type=\"radio\" [id]=\"getId('radio', i)\" [checked]=\"item.selected\" (click)=\"radioButtonChange(item)\"></div><div class=\"list-pf-content list-pf-content-flex\"><div class=\"pfng-list-content\" (click)=\"toggleSelection($event, item)\" (dblclick)=\"dblClick($event, item)\"><ng-template *ngIf=\"itemTemplate\" [ngTemplateOutlet]=\"itemTemplate\" [ngTemplateOutletContext]=\"{ item: item, index: i }\"></ng-template></div><div class=\"list-pf-actions\"><ng-template *ngIf=\"actionTemplate\" [ngTemplateOutlet]=\"actionTemplate\" [ngTemplateOutletContext]=\"{ item: item, index: i }\"></ng-template></div></div></div><div class=\"pfng-list-expansion list-pf-expansion collapse in\" *ngIf=\"expandTemplate && item.expanded\"><div class=\"list-pf-container\" tabindex=\"0\"><div class=\"list-pf-content\"><div class=\"close\" *ngIf=\"config.hideClose !== true\"><span class=\"pficon pficon-close\" (click)=\"closeExpandArea(item)\"></span></div><ng-template [ngTemplateOutlet]=\"expandTemplate\" [ngTemplateOutletContext]=\"{ item: item, index: i }\"></ng-template></div></div></div></div></div><pfng-empty-state *ngIf=\"itemsEmpty\" [config]=\"config.emptyStateConfig\" (onActionSelect)=\"handleAction($event)\"></pfng-empty-state>"
            }),
            __metadata$o("design:paramtypes", [core.ElementRef])
        ], ListComponent);
        return ListComponent;
    }(ListBase));

    var __decorate$H = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata$p = (undefined && undefined.__metadata) || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    /**
     * List compund expansion toggle component.
     *
     * This is intended to be used with the list component's itemExpandTemplate
     */
    var ListExpandToggleComponent = /** @class */ (function () {
        /**
         * The default constructor
         */
        function ListExpandToggleComponent() {
        }
        // Initialization
        /**
         * Setup component configuration upon initialization
         */
        ListExpandToggleComponent.prototype.ngOnInit = function () {
            if (this.item === undefined) {
                throw new Error('ListCompoundToggleComponent: item attribute not set');
            }
            if (this.expandId === undefined) {
                throw new Error('ListCompoundToggleComponent: expandId attribute not set');
            }
        };
        Object.defineProperty(ListExpandToggleComponent.prototype, "isExpanded", {
            // Actions
            /**
             * Test if item is expanded based on given expand item ID
             *
             * @returns {boolean} True if item is expanded
             */
            get: function () {
                return (this.item.expanded === true && this.item.expandId === this.expandId);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Toggle expand item open/close
         */
        ListExpandToggleComponent.prototype.toggleExpand = function () {
            // Item may already be open
            if (this.item.expanded && this.item.expandId !== this.expandId) {
                this.item.expandId = this.expandId;
                return;
            }
            this.item.expandId = this.expandId;
            this.item.expanded = !this.item.expanded;
        };
        __decorate$H([
            core.Input(),
            __metadata$p("design:type", String)
        ], ListExpandToggleComponent.prototype, "expandId", void 0);
        __decorate$H([
            core.Input(),
            __metadata$p("design:type", Object)
        ], ListExpandToggleComponent.prototype, "item", void 0);
        __decorate$H([
            core.Input(),
            __metadata$p("design:type", core.TemplateRef)
        ], ListExpandToggleComponent.prototype, "template", void 0);
        ListExpandToggleComponent = __decorate$H([
            core.Component({
                encapsulation: core.ViewEncapsulation.None,
                selector: 'pfng-list-expand-toggle',
                template: "<div class=\"list-pf-chevron\" (click)=\"toggleExpand()\"><span class=\"fa fa-angle-right\" [ngClass]=\"{'fa-angle-down': isExpanded}\"></span><ng-template *ngIf=\"template\" let-item=\"item\" [ngTemplateOutlet]=\"template\" [ngTemplateOutletContext]=\"{ item: item }\"></ng-template></div>"
            }),
            __metadata$p("design:paramtypes", [])
        ], ListExpandToggleComponent);
        return ListExpandToggleComponent;
    }());

    var __decorate$I = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    /**
     * Sort array pipe
     *
     * This is currently used with the pin feature of the list component
     *
     * Example:
     * <div *ngFor="let item of (items | sortPin: 'name': true)">
     */
    var SortArrayPipe = /** @class */ (function () {
        function SortArrayPipe() {
        }
        /**
         * Sort array by property
         *
         * @param {Array<any>} arr Array to sort
         * @param prop Property name to sort by
         * @param {boolean} descending True to sort descending
         * @returns {any} Returns sorted array
         */
        SortArrayPipe.prototype.transform = function (arr, prop, descending) {
            if (descending === void 0) { descending = false; }
            if (arr === undefined) {
                return arr;
            }
            var sortOrder = descending ? 'desc' : 'asc';
            var sortedArray = lodash.orderBy(arr, [prop], [sortOrder]);
            return sortedArray;
        };
        SortArrayPipe = __decorate$I([
            core.Pipe({ name: 'sortArray' })
        ], SortArrayPipe);
        return SortArrayPipe;
    }());

    var __decorate$J = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    /**
     * A module containing objects associated with the sort array pipe
     */
    var SortArrayPipeModule = /** @class */ (function () {
        function SortArrayPipeModule() {
        }
        SortArrayPipeModule = __decorate$J([
            core.NgModule({
                declarations: [
                    SortArrayPipe
                ],
                exports: [
                    SortArrayPipe
                ]
            })
        ], SortArrayPipeModule);
        return SortArrayPipeModule;
    }());

    var __decorate$K = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    /**
     * A module containing objects associated with basic list components
     */
    var ListModule = /** @class */ (function () {
        function ListModule() {
        }
        ListModule = __decorate$K([
            core.NgModule({
                imports: [
                    common.CommonModule,
                    EmptyStateModule,
                    forms.FormsModule,
                    SortArrayPipeModule
                ],
                declarations: [ListComponent, ListExpandToggleComponent],
                exports: [ListComponent, ListExpandToggleComponent]
            })
        ], ListModule);
        return ListModule;
    }());

    var __extends$g = (undefined && undefined.__extends) || (function () {
        var extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * A config containing properties for tree list
     *
     * @deprecated The tree-list component is deprecated due to issues with Angular 6 and mobx autorun,
     * introduced by angular-tree-component.
     *
     * See: https://github.com/patternfly/patternfly-ng/issues/381
     */
    var TreeListConfig = /** @class */ (function (_super) {
        __extends$g(TreeListConfig, _super);
        function TreeListConfig() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return TreeListConfig;
    }(ListConfigBase));

    var __extends$h = (undefined && undefined.__extends) || (function () {
        var extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var __decorate$L = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata$q = (undefined && undefined.__metadata) || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    /**
     * Tree List component
     *
     * For items, use a template named itemTemplate to contain content for each item. If using actions, use a template named
     * actionTemplate to contain expandable content for the actions of each item. Use the loadTemplate to customize lazy
     * loading messages.
     *
     * Cannot use both multi-select and double click selection at the same time
     * Cannot use both checkbox and click selection at the same time
     *
     * For angular-tree-component options, see: https://angular2-tree.readme.io/docs
     *
     * Usage:
     * <br/><code>import { TreeListModule } from 'patternfly-ng/list';</code>
     *
     * Or:
     * <br/><code>import { TreeListModule } from 'patternfly-ng';</code>
     *
     * @deprecated The tree-list component is deprecated due to issues with Angular 6 and mobx autorun,
     * introduced by angular-tree-component.
     *
     * See: https://github.com/patternfly/patternfly-ng/issues/381
     */
    var TreeListComponent = /** @class */ (function (_super) {
        __extends$h(TreeListComponent, _super);
        /**
         * The default constructor
         */
        function TreeListComponent() {
            var _this = _super.call(this) || this;
            /**
             * Catch-all event that is triggered for angular-tree-component
             */
            _this.onEvent = new core.EventEmitter();
            /**
             * This event is fired any time moveNode is called for angular-tree-component
             */
            _this.onMoveNode = new core.EventEmitter();
            /**
             * Triggers when expanding / collapsing angular-tree-component nodes
             */
            _this.onToggleExpanded = new core.EventEmitter();
            _this.defaultConfig = {
                dblClick: false,
                indentChildren: 80,
                multiSelect: false,
                treeOptions: {
                    allowDrag: false
                },
                selectedItems: [],
                selectionMatchProp: 'uuid',
                selectItems: false,
                showCheckbox: false,
                showRadioButton: false
            };
            return _this;
        }
        // Initialization
        /**
         * Setup component configuration upon initialization
         */
        TreeListComponent.prototype.ngOnInit = function () {
            this.setupConfig();
        };
        /**
         * Check if the component config has changed
         */
        TreeListComponent.prototype.ngDoCheck = function () {
            // Do a deep compare on config
            if (!lodash.isEqual(this.config, this.prevConfig)) {
                this.setupConfig();
            }
        };
        /**
         * Set up default config
         */
        TreeListComponent.prototype.setupConfig = function () {
            if (this.config !== undefined) {
                lodash.defaults(this.config, this.defaultConfig);
            }
            else {
                this.config = lodash.cloneDeep(this.defaultConfig);
            }
            _super.prototype.setupConfig.call(this);
            this.prevConfig = lodash.cloneDeep(this.config);
        };
        /**
         * Return component config
         *
         * @returns {TreeListConfig} The component config
         */
        TreeListComponent.prototype.getConfig = function () {
            return this.config;
        };
        /**
         * Helper to update angular-tree-component model
         *
         * After adding or removing nodes from the tree, the update method must be called
         * on the treeModel for it to take affect.
         *
         * See: https://angular2-tree.readme.io/docs/changing-the-tree
         */
        TreeListComponent.prototype.update = function () {
            this.tree.treeModel.update();
        };
        // Drag and drop
        TreeListComponent.prototype.handleDragStart = function ($event) {
            // Drag effect: https://developer.mozilla.org/en-US/docs/Web/API/HTML_Drag_and_Drop_API
            $event.dataTransfer.effectAllowed = 'copyMove';
        };
        // Tree events
        TreeListComponent.prototype.handleEvent = function ($event) {
            this.onEvent.emit($event);
        };
        TreeListComponent.prototype.handleMoveNode = function ($event) {
            this.onMoveNode.emit($event);
        };
        TreeListComponent.prototype.handleToggleExpanded = function ($event) {
            this.onToggleExpanded.emit($event);
        };
        /**
         * Get children indent in pixels
         *
         * @param {number} nodeLevel The level of the given node in the tree
         * @returns {string} The indent in pixels
         */
        TreeListComponent.prototype.getIndentChildren = function (nodeLevel) {
            return (nodeLevel > 1) ? (nodeLevel - 1) * this.config.indentChildren + '' : '';
        };
        __decorate$L([
            core.Input(),
            __metadata$q("design:type", TreeListConfig)
        ], TreeListComponent.prototype, "config", void 0);
        __decorate$L([
            core.Input(),
            __metadata$q("design:type", core.TemplateRef)
        ], TreeListComponent.prototype, "loadTemplate", void 0);
        __decorate$L([
            core.Output('onEvent'),
            __metadata$q("design:type", Object)
        ], TreeListComponent.prototype, "onEvent", void 0);
        __decorate$L([
            core.Output('onMoveNode'),
            __metadata$q("design:type", Object)
        ], TreeListComponent.prototype, "onMoveNode", void 0);
        __decorate$L([
            core.Output('onToggleExpanded'),
            __metadata$q("design:type", Object)
        ], TreeListComponent.prototype, "onToggleExpanded", void 0);
        __decorate$L([
            core.ViewChild(angularTreeComponent.TreeComponent),
            __metadata$q("design:type", angularTreeComponent.TreeComponent)
        ], TreeListComponent.prototype, "tree", void 0);
        TreeListComponent = __decorate$L([
            core.Component({
                encapsulation: core.ViewEncapsulation.None,
                selector: 'pfng-tree-list',
                template: "<div class=\"list-pf\" *ngIf=\"!itemsEmpty\"><tree-root class=\"pfng-tree-list\" #tree [nodes]=\"items\" [focused]=\"true\" [options]=\"config.treeOptions\" (event)=\"handleEvent($event)\" (moveNode)=\"handleMoveNode($event)\" (toggleExpanded)=\"handleToggleExpanded($event)\"><ng-template #treeNodeTemplate let-node let-index=\"index\"><ng-template [ngTemplateOutlet]=\"itemTemplate\" [ngTemplateOutletContext]=\"{ node: node, index: index }\"></ng-template></ng-template><ng-template #loadingTemplate let-node let-index=\"index\"><ng-template [ngTemplateOutlet]=\"loadTemplate\" [ngTemplateOutletContext]=\"{ node: node, index: index }\"></ng-template></ng-template><ng-template #treeNodeFullTemplate let-node=\"node\" let-index=\"index\" let-templates=\"templates\"><div *ngIf=\"node.isHidden !== true\" class=\"tree-node\" [ngClass]=\"node.getClass()\" [class.tree-node-expanded]=\"node.isExpanded && node.hasChildren\" [class.tree-node-collapsed]=\"node.isCollapsed && node.hasChildren\" [class.tree-node-leaf]=\"node.isLeaf\" [class.tree-node-active]=\"node.isActive\" [class.tree-node-focused]=\"node.isFocused\"><div class=\"list-pf-item\" [class.active]=\"node.data.selected\" [class.tree-item-placeholder]=\"index !== 0\" [class.tree-item-selected]=\"node.data.selected\"><tree-node-drop-slot *ngIf=\"index === 0\" [dropIndex]=\"node.index\" [node]=\"node.parent\"></tree-node-drop-slot><div class=\"node-wrapper\" [style.padding-left]=\"node.getNodePadding()\"><div class=\"node-content-wrapper\" (click)=\"node.mouseAction('click', $event)\" (dblclick)=\"node.mouseAction('dblClick', $event)\" (contextmenu)=\"node.mouseAction('contextMenu', $event)\" (dragstart)=\"handleDragStart($event)\" (treeDrop)=\"node.onDrop($event)\" [treeAllowDrop]=\"node.allowDrop\" [treeDrag]=\"node\" [treeDragEnabled]=\"node.allowDrag()\"><div class=\"list-pf-container\" [class.pfng-tree-list-dnd-slot]=\"index === 0\" [class.pfng-tree-list-dnd]=\"node.allowDrag()\" [style.padding-left.px]=\"getIndentChildren(node.level, node)\"><div class=\"list-pf-chevron\"><tree-node-expander [node]=\"node\"></tree-node-expander></div><div class=\"list-pf-select\" *ngIf=\"config.showCheckbox && !config.showRadioButton\"><input type=\"checkbox\" value=\"node.data.selected\" [(ngModel)]=\"node.data.selected\" (ngModelChange)=\"checkboxChange(node.data)\"></div><div class=\"list-pf-select\" *ngIf=\"!config.showCheckbox && config.showRadioButton\"><input type=\"radio\" value=\"node.data.selected\" [checked]=\"node.data.selected\" (click)=\"radioButtonChange(node.data)\"></div><div class=\"list-pf-content list-pf-content-flex\"><div class=\"pfng-tree-list-content\" (click)=\"toggleSelection($event, node.data)\" (dblclick)=\"dblClick($event, node.data)\"><ng-template [ngTemplateOutlet]=\"itemTemplate\" [ngTemplateOutletContext]=\"{ node: node, index: index }\"></ng-template></div><div class=\"list-pf-actions\" *ngIf=\"actionTemplate\"><ng-template [ngTemplateOutlet]=\"actionTemplate\" [ngTemplateOutletContext]=\"{ node: node, index: index }\"></ng-template></div></div></div></div></div><tree-node-drop-slot [dropIndex]=\"node.index + 1\" [node]=\"node.parent\"></tree-node-drop-slot></div><tree-node-children [node]=\"node\" [templates]=\"templates\"></tree-node-children></div></ng-template></tree-root></div><pfng-empty-state *ngIf=\"itemsEmpty\" [config]=\"config.emptyStateConfig\" (onActionSelect)=\"handleAction($event)\"></pfng-empty-state>"
            }),
            __metadata$q("design:paramtypes", [])
        ], TreeListComponent);
        return TreeListComponent;
    }(ListBase));

    var __decorate$M = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata$r = (undefined && undefined.__metadata) || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    /**
     * A module containing objects associated with tree list components
     *
     * @deprecated The tree-list component is deprecated due to issues with Angular 6 and mobx autorun,
     * introduced by angular-tree-component.
     *
     * See: https://github.com/patternfly/patternfly-ng/issues/381
     */
    var TreeListModule = /** @class */ (function () {
        function TreeListModule() {
            console.log('patternfly-ng: The tree-list component is deprecated due to issues with Angular 6 and ' +
                'mobx autorun, introduced by angular-tree-component.');
        }
        TreeListModule = __decorate$M([
            core.NgModule({
                imports: [
                    common.CommonModule,
                    EmptyStateModule,
                    forms.FormsModule,
                    angularTreeComponent.TreeModule
                ],
                declarations: [TreeListComponent],
                exports: [TreeListComponent]
            }),
            __metadata$r("design:paramtypes", [])
        ], TreeListModule);
        return TreeListModule;
    }());

    /**
     * A config containing properties for About Modal
     */
    var AboutModalConfig = /** @class */ (function () {
        function AboutModalConfig() {
        }
        return AboutModalConfig;
    }());

    var __decorate$N = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata$s = (undefined && undefined.__metadata) || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    /**
     * Component for rendering AboutModal
     */
    var AboutModalComponent = /** @class */ (function () {
        /**
         * The default contructor
         */
        function AboutModalComponent() {
            /**
             * The Event is emitted when modal is closed
             */
            this.onCancel = new core.EventEmitter();
            this.defaultConfig = {};
        }
        // Initialization
        /**
         * Setup component configuration upon initialization
         */
        AboutModalComponent.prototype.ngOnInit = function () {
            this.setupConfig();
        };
        /**
         * Check if the component config has changed
         */
        AboutModalComponent.prototype.ngDoCheck = function () {
            // Do a deep compare on config
            if (!lodash.isEqual(this.config, this.prevConfig)) {
                this.setupConfig();
            }
        };
        /**
         * Setup default config
         */
        AboutModalComponent.prototype.setupConfig = function () {
            if (this.config !== undefined) {
                lodash.defaults(this.config, this.defaultConfig);
            }
            else {
                this.config = lodash.cloneDeep(this.defaultConfig);
            }
            this.prevConfig = lodash.cloneDeep(this.config);
        };
        /**
         * Close the Modal
         * @param  $event MouseEvent to emit
         */
        AboutModalComponent.prototype.close = function () {
            this.onCancel.emit({
                close: true
            });
        };
        __decorate$N([
            core.Input(),
            __metadata$s("design:type", AboutModalConfig)
        ], AboutModalComponent.prototype, "config", void 0);
        __decorate$N([
            core.Output('onCancel'),
            __metadata$s("design:type", Object)
        ], AboutModalComponent.prototype, "onCancel", void 0);
        AboutModalComponent = __decorate$N([
            core.Component({
                encapsulation: core.ViewEncapsulation.None,
                selector: 'pfng-about-modal',
                template: "<div class=\"about-modal-pf\"><div class=\"modal-header\"><button type=\"button\" class=\"close\" (click)=\"close()\" aria-hidden=\"true\"><span class=\"pficon pficon-close\"></span></button></div><div class=\"modal-body\"><h1 *ngIf=\"config.title\">{{config.title}}</h1><div *ngIf=\"config.productInfo && config.productInfo.length > 0\" class=\"product-versions-pf\"><ul class=\"list-unstyled\"><li *ngFor=\"let info of config.productInfo\"><strong>{{info.name}}</strong> {{info.value}}</li></ul></div><div class=\"product-versions-pf\"><ng-content></ng-content></div><div *ngIf=\"config.additionalInfo\" class=\"product-versions-pf\">{{config.additionalInfo}}</div><div *ngIf=\"config.copyright\" class=\"trademark-pf\">{{config.copyright}}</div></div><div class=\"modal-footer\"><img *ngIf=\"config.logoImageSrc\" [src]=\"config.logoImageSrc\" alt=\"{{config.logoImageAlt}}\"></div></div>"
            }),
            __metadata$s("design:paramtypes", [])
        ], AboutModalComponent);
        return AboutModalComponent;
    }());

    var __decorate$O = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var ModalModule = /** @class */ (function () {
        function ModalModule() {
        }
        ModalModule = __decorate$O([
            core.NgModule({
                imports: [
                    common.CommonModule
                ],
                declarations: [AboutModalComponent],
                exports: [AboutModalComponent]
            })
        ], ModalModule);
        return ModalModule;
    }());

    /**
     * A config containing properties for navigation items
     */
    var NavigationItemBase = /** @class */ (function () {
        function NavigationItemBase() {
        }
        return NavigationItemBase;
    }());

    var __extends$i = (undefined && undefined.__extends) || (function () {
        var extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * A config containing properties for navigation items
     *
     * @deprecated Use VerticalNavigationItem, or ApplicationLauncherItem
     */
    var NavigationItemConfig = /** @class */ (function (_super) {
        __extends$i(NavigationItemConfig, _super);
        function NavigationItemConfig() {
            var _this = _super.call(this) || this;
            console.log('patternfly-ng: NavigationItemConfig is deprecated; use VerticalNavigationItem ' +
                'or ApplicationLauncherItem');
            return _this;
        }
        return NavigationItemConfig;
    }(NavigationItemBase));

    var __decorate$P = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata$t = (undefined && undefined.__metadata) || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    var ApplicationLauncherComponent = /** @class */ (function () {
        /**
         * The default constructor
         */
        function ApplicationLauncherComponent() {
            /**
             * Display items as a list instead of a grid, default: false
             */
            this.showAsList = false;
            /**
             * Flag to show icons on the launcher, default: true
             */
            this.showIcons = true;
        }
        /**
         * Initialize variable
         */
        ApplicationLauncherComponent.prototype.ngOnInit = function () {
        };
        __decorate$P([
            core.Input(),
            __metadata$t("design:type", Boolean)
        ], ApplicationLauncherComponent.prototype, "disabled", void 0);
        __decorate$P([
            core.Input(),
            __metadata$t("design:type", Array)
        ], ApplicationLauncherComponent.prototype, "items", void 0);
        __decorate$P([
            core.Input(),
            __metadata$t("design:type", String)
        ], ApplicationLauncherComponent.prototype, "label", void 0);
        __decorate$P([
            core.Input(),
            __metadata$t("design:type", Boolean)
        ], ApplicationLauncherComponent.prototype, "showAsList", void 0);
        __decorate$P([
            core.Input(),
            __metadata$t("design:type", Boolean)
        ], ApplicationLauncherComponent.prototype, "showIcons", void 0);
        ApplicationLauncherComponent = __decorate$P([
            core.Component({
                encapsulation: core.ViewEncapsulation.None,
                selector: 'pfng-application-launcher',
                template: "<div><div class=\"applauncher-pf dropdown dropdown-kebab-pf\" dropdown [ngClass]=\"{'applauncher-pf-block-list': !showAsList}\"><a class=\"dropdown-toggle drawer-pf-trigger-icon\" href=\"javascript:void(0)\" dropdownToggle *ngIf=\"!disabled\"><i class=\"fa fa-th applauncher-pf-icon\" aria-hidden=\"true\"></i> <span class=\"applauncher-pf-title\">{{label || 'Application Launcher'}} <span class=\"caret\" aria-hidden=\"true\"></span> </span></a><a class=\"dropdown-toggle drawer-pf-trigger-icon disabled\" href=\"javascript:void(0)\" onclick=\"return false;\" *ngIf=\"disabled\"><i class=\"fa fa-th applauncher-pf-icon\" aria-hidden=\"true\"></i> <span class=\"applauncher-pf-title\">{{label || 'Application Launcher'}} <span class=\"caret\" aria-hidden=\"true\"></span></span></a><ul class=\"dropdown-menu dropdown-menu-right\" role=\"menu\" *dropdownMenu><li class=\"applauncher-pf-item\" *ngFor=\"let item of items\"><a class=\"applauncher-pf-link\" href=\"{{item.url}}\" target=\"{{item.target || '_blank'}}\" title=\"{{badge.tooltip}}\" role=\"menuitem\" *ngFor=\"let badge of item.badges\"><i class=\"applauncher-pf-link-icon pficon {{item.iconStyleClass}}\" aria-hidden=\"true\" [ngClass]=\"{hidden: !showIcons}\" *ngIf=\"item.iconStyleClass\"></i> <span class=\"applauncher-pf-link-title\">{{item.title}}</span></a></li></ul></div></div>"
            })
            /**
             * Application launcher component
             */
            ,
            __metadata$t("design:paramtypes", [])
        ], ApplicationLauncherComponent);
        return ApplicationLauncherComponent;
    }());

    var __decorate$Q = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    /**
     * A module containing objects associated with the application laucnher components
     */
    var ApplicationLauncherModule = /** @class */ (function () {
        function ApplicationLauncherModule() {
        }
        ApplicationLauncherModule = __decorate$Q([
            core.NgModule({
                imports: [
                    BsDropdownModule.forRoot(),
                    common.CommonModule
                ],
                declarations: [ApplicationLauncherComponent],
                exports: [ApplicationLauncherComponent],
                providers: [BsDropdownConfig]
            })
        ], ApplicationLauncherModule);
        return ApplicationLauncherModule;
    }());

    var __decorate$R = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata$u = (undefined && undefined.__metadata) || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    /**
     * Vertical navigation component
     */
    var VerticalNavigationComponent = /** @class */ (function () {
        /**
         * The default constructor
         */
        function VerticalNavigationComponent(elementRef, renderer, router$$1, windowRef) {
            this.elementRef = elementRef;
            this.renderer = renderer;
            this.router = router$$1;
            this.windowRef = windowRef;
            /**
             * Boolean to indicate whether or not to show badges, default: false
             */
            this.showBadges = false;
            /**
             * Indicates whether or not to allow the secondary to persist, default: false
             */
            this.persistentSecondary = false;
            /**
             * Allow pinnable menus when they are open, default: false
             */
            this.pinnableMenus = false;
            /**
             * Show menu icons, default: true
             */
            this.showIcons = true;
            /**
             * Sets an active flag on items when they are selected, default: false
             */
            this.updateActiveItemsOnClick = false;
            /**
             * Indicates whether or not this is a mobile friendly navigation, default: false
             */
            this.ignoreMobile = false;
            /**
             * Show top banner, default: true
             */
            this.showTopBanner = true;
            /**
             * This event is fired any time the user has initiated navigation
             */
            this.navigationEvent = new core.EventEmitter();
            /**
             * This event is fired any time an item in the navigation is clicked
             */
            this.itemClickEvent = new core.EventEmitter();
            this._activeSecondary = false;
            this._collapsedSecondaryNav = false;
            this._collapsedTertiaryNav = false;
            this._forceHidden = false;
            this._hoverSecondaryNav = false;
            this._hoverTertiaryNav = false;
            this._navCollapsed = false;
            this._showMobileNav = false;
            this._showMobileSecondary = false;
            this._showMobileTertiary = false;
            this.breakpoints = {
                'tablet': 768,
                'desktop': 1200
            };
            this.explicitCollapse = false;
            this.hoverDelay = 500;
            this.hideDelay = this.hoverDelay + 200;
        }
        /**
         * Setup component configuration upon initialization
         */
        VerticalNavigationComponent.prototype.ngOnInit = function () {
            var _this = this;
            this.windowListener = this.windowRef.nativeWindow.addEventListener('resize', function (event) {
                _this.onResize(event);
            });
            this.routeChangeListener = this.router.events.subscribe(function (val) {
                if (val instanceof router.NavigationEnd) {
                    if (!_this.updateActiveItemsOnClick) {
                        _this.clearActiveItems();
                        _this.initActiveItems();
                    }
                }
            });
            if (!this.updateActiveItemsOnClick) {
                this.clearActiveItems();
                this.initActiveItems();
            }
            this.initBodyElement();
            this.checkNavState();
        };
        /**
         * Destroy listeners
         */
        VerticalNavigationComponent.prototype.ngOnDestroy = function () {
            if (this.routeChangeListener !== undefined) {
                this.routeChangeListener.unsubscribe();
            }
            if (this.windowListener !== undefined) {
                this.windowRef.nativeWindow.removeEventListener('resize', this.windowListener);
            }
        };
        Object.defineProperty(VerticalNavigationComponent.prototype, "activeSecondary", {
            // Accessors
            /**
             * Returns flag indicating if secondary menu is active
             *
             * @returns {boolean} True if secondary menu is active
             */
            get: function () {
                return this._activeSecondary;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(VerticalNavigationComponent.prototype, "showMobileNav", {
            /**
             * Returns flag indicating if mobile nav should be shown
             *
             * @returns {boolean} True if mobile nav should be shown
             */
            get: function () {
                return this._showMobileNav;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(VerticalNavigationComponent.prototype, "showMobileSecondary", {
            /**
             * Returns flag indicating if mobile secondary should be shown
             *
             * @returns {boolean} True if mobile secondary should be shown
             */
            get: function () {
                return this._showMobileSecondary;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(VerticalNavigationComponent.prototype, "showMobileTertiary", {
            /**
             * Returns flag indicating if mobile tertiary should be shown
             *
             * @returns {boolean} True if mobile tertiary should be shown
             */
            get: function () {
                return this._showMobileTertiary;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(VerticalNavigationComponent.prototype, "hoverSecondaryNav", {
            /**
             * Returns flag indicating if secondary nav is being hovered over
             *
             * @returns {boolean} True if secondary nav is being hovered over
             */
            get: function () {
                return this._hoverSecondaryNav;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(VerticalNavigationComponent.prototype, "hoverTertiaryNav", {
            /**
             * Returns flag indicating if tertiary nav is being hovered over
             *
             * @returns {boolean} True if tertiary nav is being hovered over
             */
            get: function () {
                return this._hoverTertiaryNav;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(VerticalNavigationComponent.prototype, "collapsedSecondaryNav", {
            /**
             * Returns flag indicating if secondary nav is collapsed
             *
             * @returns {boolean} True if secondary nav is collapsed
             */
            get: function () {
                return this._collapsedSecondaryNav;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(VerticalNavigationComponent.prototype, "collapsedTertiaryNav", {
            /**
             * Returns flag indicating if tertiary nav is collapsed
             *
             * @returns {boolean} True if tertiary nav is collapsed
             */
            get: function () {
                return this._collapsedTertiaryNav;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(VerticalNavigationComponent.prototype, "forceHidden", {
            /**
             * Returns flag indicating if nav should be entirely hidden when screen is below desktop resolution
             *
             * @returns {boolean} True if nav should be entirely hidden
             */
            get: function () {
                return this._forceHidden;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(VerticalNavigationComponent.prototype, "inMobileState", {
            /**
             * Returns flag indicating if the navigation is in a mobile state
             *
             * @returns {boolean} True if the navigation is in a mobile state
             */
            get: function () {
                return this._inMobileState;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(VerticalNavigationComponent.prototype, "navCollapsed", {
            /**
             * Returns flag indicating if nav is collapsed
             *
             * @returns {boolean} True if nav is collapsed
             */
            get: function () {
                return this._navCollapsed;
            },
            enumerable: true,
            configurable: true
        });
        // Actions
        /**
         * Clear all active items
         */
        VerticalNavigationComponent.prototype.clearActiveItems = function () {
            this.items.forEach(function (item) {
                item.trackActiveState = false;
                if (item.children !== undefined) {
                    item.children.forEach(function (secondary) {
                        secondary.trackActiveState = false;
                        if (secondary.children !== undefined) {
                            secondary.children.forEach(function (tertiary) {
                                tertiary.trackActiveState = false;
                            });
                        }
                    });
                }
            });
        };
        /**
         * Initialize the active items in the vertical navigation
         */
        VerticalNavigationComponent.prototype.initActiveItems = function () {
            var updatedRoute = this.router.url;
            // //Setting active state on load
            this.items.forEach(function (topLevel) {
                if (updatedRoute.indexOf(topLevel.url) > -1) {
                    topLevel.trackActiveState = true;
                }
                if (topLevel.children !== undefined) {
                    topLevel.children.forEach(function (secondLevel) {
                        if (updatedRoute.indexOf(secondLevel.url) > -1) {
                            secondLevel.trackActiveState = true;
                            topLevel.trackActiveState = true;
                        }
                        if (secondLevel.children !== undefined) {
                            secondLevel.children.forEach(function (thirdLevel) {
                                if (updatedRoute.indexOf(thirdLevel.url) > -1) {
                                    thirdLevel.trackActiveState = true;
                                    secondLevel.trackActiveState = true;
                                    topLevel.trackActiveState = true;
                                }
                            });
                        }
                    });
                }
            });
        };
        /**
         * Public resize event called when the window size changes
         * @param event
         */
        VerticalNavigationComponent.prototype.onResize = function (event) {
            this.checkNavState();
        };
        /**
         * Handles the navbar hamburger toggle click
         */
        VerticalNavigationComponent.prototype.handleNavBarToggleClick = function () {
            if (this.inMobileState === true) {
                // Toggle the mobile nav
                if (this.showMobileNav === true) {
                    this._showMobileNav = false;
                }
                else {
                    // Always start at the primary menu
                    this.updateMobileMenu();
                    this._showMobileNav = true;
                }
            }
            else if (this.navCollapsed === true) {
                this.expandMenu();
            }
            else {
                this.collapseMenu();
            }
        };
        /**
         * Primary item selection handler
         * @param item
         */
        VerticalNavigationComponent.prototype.handlePrimaryClick = function (item) {
            if (this.inMobileState === true) {
                if (item.children !== undefined && item.children.length > 0) {
                    this.updateMobileMenu(item);
                }
                else {
                    this.updateMobileMenu();
                    this.navigateToItem(item);
                }
            }
            else {
                this.navigateToItem(item);
            }
        };
        /**
         * Secondary item selection handler
         * @param primary
         * @param secondary
         */
        VerticalNavigationComponent.prototype.handleSecondaryClick = function (primary, secondary) {
            if (this.inMobileState === true) {
                if (secondary.children && secondary.children.length > 0) {
                    this.updateMobileMenu(primary, secondary);
                }
                else {
                    this.updateMobileMenu();
                    this.navigateToItem(secondary);
                }
            }
            else {
                this.navigateToItem(secondary);
            }
        };
        /**
         * Tertiary item selection handler
         * @param primary
         * @param secondary
         * @param tertiary
         */
        VerticalNavigationComponent.prototype.handleTertiaryClick = function (primary, secondary, tertiary) {
            if (this.inMobileState === true) {
                this.updateMobileMenu();
            }
            this.navigateToItem(tertiary);
        };
        /**
         *  Show secondary nav bar on hover of primary nav items
         * @param item
         */
        VerticalNavigationComponent.prototype.handlePrimaryHover = function (item) {
            var _this = this;
            if (item.children !== undefined && item.children.length > 0) {
                if (this.inMobileState !== true) {
                    if (item.blurTimeout !== undefined) {
                        clearTimeout(item.blurTimeout);
                        item.blurTimeout = undefined;
                    }
                    else if (this.hoverTimeout === undefined && !item.trackHoverState) {
                        item.hoverTimeout = setTimeout(function () {
                            _this._hoverSecondaryNav = true;
                            item.trackHoverState = true;
                            item.hoverTimeout = undefined;
                        }, this.hoverDelay);
                    }
                }
            }
        };
        /**
         * Hides menus on blur
         * @param item
         */
        VerticalNavigationComponent.prototype.handlePrimaryBlur = function (item) {
            var _this = this;
            if (item.children !== undefined && item.children.length > 0) {
                if (item.hoverTimeout !== undefined) {
                    clearTimeout(item.hoverTimeout);
                    item.hoverTimeout = undefined;
                }
                else if (item.blurTimeout === undefined && item.trackHoverState) {
                    item.blurTimeout = setTimeout(function () {
                        item.trackHoverState = false;
                        if (_this.primaryHover() !== true) {
                            _this._hoverSecondaryNav = false;
                        }
                        item.blurTimeout = undefined;
                    }, this.hideDelay);
                }
            }
        };
        /**
         * Show tertiary nav bar on hover of secondary nav items
         * @param item
         */
        VerticalNavigationComponent.prototype.handleSecondaryHover = function (item) {
            var _this = this;
            if (item.children !== undefined && item.children.length > 0) {
                if (this.inMobileState !== true) {
                    if (item.blurTimeout !== undefined) {
                        clearTimeout(item.blurTimeout);
                        item.blurTimeout = undefined;
                    }
                    else if (this.hoverTimeout === undefined) {
                        item.navHoverTimeout = setTimeout(function () {
                            _this._hoverTertiaryNav = true;
                            item.trackHoverState = true;
                            item.navHoverTimeout = undefined;
                        }, this.hoverDelay);
                    }
                }
            }
        };
        /**
         * Hides menus on blur
         * @param item
         */
        VerticalNavigationComponent.prototype.handleSecondaryBlur = function (item) {
            var _this = this;
            if (item.children !== undefined && item.children.length > 0) {
                if (item.hoverTimeout !== undefined) {
                    clearTimeout(item.hoverTimeout);
                    item.hoverTimeout = undefined;
                }
                else if (item.blurTimeout === undefined) {
                    item.blurTimeout = setTimeout(function () {
                        item.trackHoverState = false;
                        if (_this.secondaryHover() !== true) {
                            _this._hoverTertiaryNav = false;
                        }
                        item.blurTimeout = undefined;
                    }, this.hideDelay);
                }
            }
        };
        /**
         * Collapse secondary navigation
         * @param item
         */
        VerticalNavigationComponent.prototype.collapseSecondaryNav = function (item) {
            if (this.inMobileState === true) {
                this.updateMobileMenu();
            }
            else {
                if (item.secondaryCollapsed === true) {
                    this.updateSecondaryCollapsedState(false, item);
                    this.forceHideSecondaryMenu();
                }
                else {
                    this.updateSecondaryCollapsedState(true, item);
                }
            }
            this._hoverSecondaryNav = false;
        };
        /**
         * Collapse tertiary navigation
         * @param item
         */
        VerticalNavigationComponent.prototype.collapseTertiaryNav = function (item) {
            var _this = this;
            if (this.inMobileState === true) {
                this.items.forEach(function (primaryItem) {
                    if (primaryItem.children !== undefined) {
                        primaryItem.children.forEach(function (secondaryItem) {
                            if (secondaryItem === item) {
                                _this.updateMobileMenu(primaryItem);
                            }
                        });
                    }
                });
            }
            else {
                if (item.tertiaryCollapsed === true) {
                    this.updateTertiaryCollapsedState(false, item);
                    this.forceHideSecondaryMenu();
                }
                else {
                    this.updateTertiaryCollapsedState(true, item);
                }
            }
            this._hoverSecondaryNav = false;
            this._hoverTertiaryNav = false;
        };
        // Private
        VerticalNavigationComponent.prototype.addClass = function (className) {
            var element = this.elementRef.nativeElement;
            this.renderer.addClass(element, className);
        };
        VerticalNavigationComponent.prototype.removeClass = function (className) {
            var element = this.elementRef.nativeElement;
            this.renderer.removeClass(element, className);
        };
        VerticalNavigationComponent.prototype.initBodyElement = function () {
            if (this.contentContainer === undefined) {
                return;
            }
            if (this.showBadges === true) {
                this.renderer.addClass(this.contentContainer, 'nav-pf-vertical-with-badges');
            }
            if (this.persistentSecondary === true) {
                this.renderer.addClass(this.contentContainer, 'nav-pf-persistent-secondary');
            }
            if (this.showIcons !== true) {
                this.renderer.addClass(this.contentContainer, 'hidden-icons-pf');
            }
        };
        VerticalNavigationComponent.prototype.updateMobileMenu = function (selected, secondaryItem) {
            this.items.forEach(function (item) {
                item.mobileItem = false;
                if (item.children !== undefined) {
                    item.children.forEach(function (nextSecondary) {
                        nextSecondary.mobileItem = false;
                    });
                }
            });
            if (selected !== undefined) {
                selected.mobileItem = true;
                if (secondaryItem) {
                    secondaryItem.mobileItem = true;
                    this._showMobileSecondary = false;
                    this._showMobileTertiary = true;
                }
                else {
                    this._showMobileSecondary = true;
                    this._showMobileTertiary = false;
                }
            }
            else {
                this._showMobileSecondary = false;
                this._showMobileTertiary = false;
            }
        };
        VerticalNavigationComponent.prototype.checkNavState = function () {
            var width = this.windowRef.nativeWindow.innerWidth;
            // Check to see if we need to enter/exit the mobile state
            if (this.ignoreMobile !== true && width < this.breakpoints.tablet) {
                if (this.inMobileState !== true) {
                    this._inMobileState = true;
                    // Set the body class to the correct state
                    if (this.contentContainer !== undefined) {
                        this.renderer.removeClass(this.contentContainer, 'collapsed-nav');
                        this.renderer.addClass(this.contentContainer, 'hidden-nav');
                    }
                    // Reset the collapsed states
                    this.updateSecondaryCollapsedState(false);
                    this.updateTertiaryCollapsedState(false);
                    this.explicitCollapse = false;
                }
            }
            else {
                this._inMobileState = false;
                this._showMobileNav = false;
                // Set the body class back to the default
                if (this.contentContainer !== undefined) {
                    this.renderer.removeClass(this.contentContainer, 'hidden-nav');
                }
            }
            if (this.explicitCollapse === true) {
                this._navCollapsed = true;
                this.addClass('collapsed-nav');
            }
            else {
                this._navCollapsed = false;
                this.removeClass('collapsed-nav');
            }
        };
        VerticalNavigationComponent.prototype.collapseMenu = function () {
            this._navCollapsed = true;
            // Set the body class to the correct state
            if (this.contentContainer !== undefined) {
                this.renderer.addClass(this.contentContainer, 'collapsed-nav');
            }
            this.explicitCollapse = true;
        };
        VerticalNavigationComponent.prototype.expandMenu = function () {
            this._navCollapsed = false;
            // Set the body class to the correct state
            if (this.contentContainer !== undefined) {
                this.renderer.removeClass(this.contentContainer, 'collapsed-nav');
            }
            this.explicitCollapse = false;
            // Dispatch a resize event when showing the expanding then menu to
            // allow content to adjust to the menu sizing
            this.windowRef.nativeWindow.dispatchEvent(new Event('resize'));
        };
        VerticalNavigationComponent.prototype.forceHideSecondaryMenu = function () {
            var _this = this;
            this._forceHidden = true;
            setTimeout(function () {
                _this._forceHidden = false;
            }, 500);
        };
        VerticalNavigationComponent.prototype.setParentActive = function (item) {
            this.items.forEach(function (topLevel) {
                if (topLevel.children !== undefined) {
                    topLevel.children.forEach(function (secondLevel) {
                        if (secondLevel === item) {
                            topLevel.trackActiveState = true;
                        }
                        if (secondLevel.children !== undefined) {
                            secondLevel.children.forEach(function (thirdLevel) {
                                if (thirdLevel === item) {
                                    topLevel.trackActiveState = true;
                                    secondLevel.trackActiveState = true;
                                }
                            });
                        }
                    });
                }
            });
        };
        VerticalNavigationComponent.prototype.getFirstNavigateChild = function (item) {
            var firstChild;
            if (item.children === undefined || item.children.length < 1) {
                firstChild = item;
            }
            else {
                firstChild = this.getFirstNavigateChild(item.children[0]);
            }
            return firstChild;
        };
        VerticalNavigationComponent.prototype.setSecondaryItemVisible = function () {
            var _this = this;
            this._activeSecondary = false;
            if (this.persistentSecondary === true && !this.inMobileState) {
                this.items.forEach(function (topLevel) {
                    if (topLevel.children) {
                        topLevel.children.forEach(function (secondLevel) {
                            if (secondLevel.trackActiveState) {
                                _this._activeSecondary = true;
                            }
                        });
                    }
                });
                if (this.contentContainer !== undefined) {
                    if (this.activeSecondary === true) {
                        this.renderer.addClass(this.contentContainer, 'secondary-visible-pf');
                    }
                    else {
                        this.renderer.removeClass(this.contentContainer, 'secondary-visible-pf');
                    }
                }
            }
        };
        VerticalNavigationComponent.prototype.navigateToItem = function (item) {
            var _this = this;
            var navItem = this.getFirstNavigateChild(item);
            if (navItem) {
                this._showMobileNav = false;
                var navTo = navItem.url;
                if (navTo) {
                    this.router.navigateByUrl(navTo);
                }
                if (this.navigationEvent) {
                    this.navigationEvent.emit(navItem);
                }
            }
            if (this.updateActiveItemsOnClick) {
                this.clearActiveItems();
                navItem.trackActiveState = true;
                this.setParentActive(navItem);
            }
            // Dismiss items (leaf nodes) immediately upon click
            if (!item.children) {
                this._hoverSecondaryNav = false;
                this._hoverTertiaryNav = false;
                this.items.forEach(function (primary) {
                    if (!_this.persistentSecondary) {
                        primary.trackHoverState = false;
                    }
                    if (primary.children !== undefined) {
                        primary.children.forEach(function (secondary) {
                            if (!_this.persistentSecondary) {
                                secondary.trackHoverState = false;
                            }
                        });
                    }
                });
            }
            else {
                this.setSecondaryItemVisible();
            }
            this.itemClickEvent.emit(item);
        };
        VerticalNavigationComponent.prototype.primaryHover = function () {
            var hover = false;
            this.items.forEach(function (item) {
                if (item.trackHoverState) {
                    hover = true;
                }
            });
            return hover;
        };
        VerticalNavigationComponent.prototype.secondaryHover = function () {
            var hover = false;
            this.items.forEach(function (item) {
                if (item.children && item.children.length > 0) {
                    item.children.forEach(function (secondaryItem) {
                        if (secondaryItem.trackHoverState) {
                            hover = true;
                        }
                    });
                }
            });
            return hover;
        };
        VerticalNavigationComponent.prototype.updateSecondaryCollapsedState = function (setCollapsed, collapsedItem) {
            if (collapsedItem !== undefined) {
                collapsedItem.secondaryCollapsed = setCollapsed;
            }
            if (setCollapsed === true) {
                this._collapsedSecondaryNav = true;
                if (this.contentContainer !== undefined) {
                    this.renderer.addClass(this.contentContainer, 'collapsed-secondary-nav-pf');
                }
            }
            else {
                // Remove any collapsed secondary menus
                if (this.items !== undefined) {
                    this.items.forEach(function (item) {
                        item.secondaryCollapsed = false;
                    });
                }
                this._collapsedSecondaryNav = false;
                if (this.contentContainer !== undefined) {
                    this.renderer.removeClass(this.contentContainer, 'collapsed-secondary-nav-pf');
                }
            }
        };
        VerticalNavigationComponent.prototype.updateTertiaryCollapsedState = function (setCollapsed, collapsedItem) {
            if (collapsedItem !== undefined) {
                collapsedItem.tertiaryCollapsed = setCollapsed;
            }
            if (setCollapsed === true) {
                this._collapsedTertiaryNav = true;
                this.updateSecondaryCollapsedState(false);
                if (this.contentContainer !== undefined) {
                    this.renderer.addClass(this.contentContainer, 'collapsed-tertiary-nav-pf');
                }
            }
            else {
                // Remove any collapsed secondary menus
                if (this.items !== undefined) {
                    this.items.forEach(function (item) {
                        if (item.children && item.children.length > 0) {
                            item.children.forEach(function (secondaryItem) {
                                secondaryItem.tertiaryCollapsed = false;
                            });
                        }
                    });
                }
                this._collapsedTertiaryNav = false;
                if (this.contentContainer !== undefined) {
                    this.renderer.removeClass(this.contentContainer, 'collapsed-tertiary-nav-pf');
                }
            }
        };
        __decorate$R([
            core.Input(),
            __metadata$u("design:type", String)
        ], VerticalNavigationComponent.prototype, "brandSrc", void 0);
        __decorate$R([
            core.Input(),
            __metadata$u("design:type", String)
        ], VerticalNavigationComponent.prototype, "brandAlt", void 0);
        __decorate$R([
            core.Input(),
            __metadata$u("design:type", HTMLElement)
        ], VerticalNavigationComponent.prototype, "contentContainer", void 0);
        __decorate$R([
            core.Input(),
            __metadata$u("design:type", Boolean)
        ], VerticalNavigationComponent.prototype, "showBadges", void 0);
        __decorate$R([
            core.Input(),
            __metadata$u("design:type", Boolean)
        ], VerticalNavigationComponent.prototype, "persistentSecondary", void 0);
        __decorate$R([
            core.Input(),
            __metadata$u("design:type", Boolean)
        ], VerticalNavigationComponent.prototype, "pinnableMenus", void 0);
        __decorate$R([
            core.Input(),
            __metadata$u("design:type", Boolean)
        ], VerticalNavigationComponent.prototype, "showIcons", void 0);
        __decorate$R([
            core.Input(),
            __metadata$u("design:type", Array)
        ], VerticalNavigationComponent.prototype, "items", void 0);
        __decorate$R([
            core.Input(),
            __metadata$u("design:type", Boolean)
        ], VerticalNavigationComponent.prototype, "updateActiveItemsOnClick", void 0);
        __decorate$R([
            core.Input(),
            __metadata$u("design:type", Boolean)
        ], VerticalNavigationComponent.prototype, "ignoreMobile", void 0);
        __decorate$R([
            core.Input(),
            __metadata$u("design:type", Boolean)
        ], VerticalNavigationComponent.prototype, "showTopBanner", void 0);
        __decorate$R([
            core.Output('onNavigationEvent'),
            __metadata$u("design:type", Object)
        ], VerticalNavigationComponent.prototype, "navigationEvent", void 0);
        __decorate$R([
            core.Output('onItemClickEvent'),
            __metadata$u("design:type", Object)
        ], VerticalNavigationComponent.prototype, "itemClickEvent", void 0);
        VerticalNavigationComponent = __decorate$R([
            core.Component({
                encapsulation: core.ViewEncapsulation.None,
                selector: 'pfng-vertical-navigation',
                template: "<div><nav class=\"navbar navbar-pf-vertical pfng-vertical-container\" [ngClass]=\"{'pfng-vertical-hide-nav': !showTopBanner}\"><ng-container *ngIf=\"showTopBanner\"><div class=\"navbar-header\"><button type=\"button\" class=\"navbar-toggle\" (click)=\"handleNavBarToggleClick()\"><span class=\"sr-only\">Toggle navigation</span> <span class=\"icon-bar\"></span> <span class=\"icon-bar\"></span> <span class=\"icon-bar\"></span></button> <span class=\"navbar-brand\"><img class=\"navbar-brand-icon\" *ngIf=\"brandSrc\" [src]=\"brandSrc\" alt=\"{{brandAlt}}\"> <span class=\"navbar-brand-txt\" *ngIf=\"!brandSrc\">{{brandAlt}}</span></span></div><nav class=\"collapse navbar-collapse\"><ng-content></ng-content></nav></ng-container><div class=\"nav-pf-vertical\" [ngClass]=\"{'nav-pf-persistent-secondary': persistentSecondary,\n                    'nav-pf-vertical-collapsible-menus': pinnableMenus,\n                    'hidden-icons-pf': !showIcons,\n                    'nav-pf-vertical-with-badges': showBadges,\n                    'secondary-visible-pf': activeSecondary,\n                    'show-mobile-secondary': showMobileSecondary,\n                    'show-mobile-tertiary': showMobileTertiary,\n                    'hover-secondary-nav-pf': hoverSecondaryNav,\n                    'hover-tertiary-nav-pf': hoverTertiaryNav,\n                    'collapsed-secondary-nav-pf': collapsedSecondaryNav,\n                    'collapsed-tertiary-nav-pf': collapsedTertiaryNav,\n                    'hidden': inMobileState,\n                    'collapsed': navCollapsed,\n                    'force-hide-secondary-nav-pf': forceHidden,\n                    'show-mobile-nav': showMobileNav}\"><ul class=\"list-group\"><li *ngFor=\"let item of items\" class=\"list-group-item\" [ngClass]=\"{'secondary-nav-item-pf': item.children && item.children.length > 0,\n                       'active': item.trackActiveState,\n                       'is-hover': item.trackHoverState,\n                       'mobile-nav-item-pf': item.mobileItem && showMobileSecondary,\n                       'mobile-secondary-item-pf': item.mobileItem && showMobileTertiary}\" (mouseenter)=\"handlePrimaryHover(item)\" (mouseleave)=\"handlePrimaryBlur(item)\"><a (click)=\"handlePrimaryClick(item)\"><span class=\"{{item.iconStyleClass}}\" *ngIf=\"item.iconStyleClass\" [ngClass]=\"{hidden: !showIcons}\" tooltip=\"{{item.title}}\" container=\"body\" placement=\"bottom\" isDisabled=\"!{{navCollapsed}}\" containerClass=\"nav-pf-vertical-tooltip\"></span> <span class=\"list-group-item-value\">{{item.title}}</span><div *ngIf=\"showBadges && item.badges\" class=\"badge-container-pf\"><div class=\"badge {{badge.badgeClass}}\" *ngFor=\"let badge of item.badges\" tooltip=\"{{badge.tooltip}}\" container=\"body\" placement=\"right\"><span *ngIf=\"badge.count && badge.iconStyleClass\" class=\"{{badge.iconStyleClass}}\"></span> <span *ngIf=\"badge.count\">{{badge.count}}</span></div></div></a><div *ngIf=\"item.children && item.children.length > 0\" class=\"nav-pf-secondary-nav\"><div class=\"nav-item-pf-header\"><a class=\"secondary-collapse-toggle-pf\" (click)=\"collapseSecondaryNav(item)\" [ngClass]=\"{'collapsed': item.secondaryCollapsed}\"></a> <span>{{item.title}}</span></div><ul class=\"list-group\"><li *ngFor=\"let secondaryItem of item.children\" class=\"list-group-item\" [ngClass]=\"{'tertiary-nav-item-pf': secondaryItem.children && secondaryItem.children.length > 0,\n                             'active': secondaryItem.trackActiveState,\n                             'is-hover': secondaryItem.trackHoverState,\n                             'mobile-nav-item-pf': secondaryItem.mobileItem}\" (mouseenter)=\"handleSecondaryHover(secondaryItem)\" (mouseleave)=\"handleSecondaryBlur(secondaryItem)\"><a (click)=\"handleSecondaryClick(item, secondaryItem)\"><span class=\"list-group-item-value\">{{secondaryItem.title}}</span><div *ngIf=\"showBadges && secondaryItem.badges\" class=\"badge-container-pf\"><div class=\"badge {{badge.badgeClass}}\" *ngFor=\"let badge of secondaryItem.badges\" tooltip=\"{{badge.tooltip}}\" container=\"body\" placement=\"right\"><span *ngIf=\"badge.count && badge.iconStyleClass\" class=\"{{badge.iconStyleClass}}\"></span> <span *ngIf=\"badge.count\">{{badge.count}}</span></div></div></a><div *ngIf=\"secondaryItem.children && secondaryItem.children.length > 0\" class=\"nav-pf-tertiary-nav\"><div class=\"nav-item-pf-header\"><a class=\"tertiary-collapse-toggle-pf\" (click)=\"collapseTertiaryNav(secondaryItem)\" [ngClass]=\"{'collapsed': secondaryItem.tertiaryCollapsed}\"></a> <span>{{secondaryItem.title}}</span></div><ul class=\"list-group\"><li *ngFor=\"let tertiaryItem of secondaryItem.children\" class=\"list-group-item\" [ngClass]=\"{'active': tertiaryItem.trackActiveState}\"><a (click)=\"handleTertiaryClick(item, secondaryItem, tertiaryItem)\"><span class=\"list-group-item-value\">{{tertiaryItem.title}}</span><div *ngIf=\"showBadges && tertiaryItem.badges\" class=\"badge-container-pf\"><div class=\"badge {{badge.badgeClass}}\" *ngFor=\"let badge of tertiaryItem.badges\" tooltip=\"{{badge.tooltip}}\" container=\"body\" placement=\"right\"><span *ngIf=\"badge.count && badge.iconStyleClass\" class=\"{{badge.iconStyleClass}}\"></span> <span *ngIf=\"badge.count\">{{badge.count}}</span></div></div></a></li></ul></div></li></ul></div></li></ul></div></nav></div>"
            }),
            __metadata$u("design:paramtypes", [core.ElementRef,
                core.Renderer2,
                router.Router,
                WindowReference])
        ], VerticalNavigationComponent);
        return VerticalNavigationComponent;
    }());

    var __decorate$S = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    /**
     * A module containing objects associated with vertical navigation components
     */
    var VerticalNavigationModule = /** @class */ (function () {
        function VerticalNavigationModule() {
        }
        VerticalNavigationModule = __decorate$S([
            core.NgModule({
                imports: [
                    common.CommonModule,
                    TooltipModule.forRoot()
                ],
                declarations: [VerticalNavigationComponent],
                exports: [VerticalNavigationComponent],
                providers: [TooltipConfig, WindowReference]
            })
        ], VerticalNavigationModule);
        return VerticalNavigationModule;
    }());

    var __decorate$T = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata$v = (undefined && undefined.__metadata) || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    /**
     * A module containing objects associated with the navigation components
     *
     * @deprecated Use individual module imports
     *
     * import {
     *   ApplicationLauncherModule,
     *   VerticalNavigationModule
     * } from 'patternfly-ng/navigation';
     */
    var NavigationModule = /** @class */ (function () {
        function NavigationModule() {
            console.log('patternfly-ng: NavigationModule is deprecated; use ApplicationLauncherModule ' +
                'or VerticalNavigationModule');
        }
        NavigationModule = __decorate$T([
            core.NgModule({
                imports: [
                    ApplicationLauncherModule,
                    common.CommonModule,
                    VerticalNavigationModule
                ],
                exports: [ApplicationLauncherComponent, VerticalNavigationComponent]
            }),
            __metadata$v("design:paramtypes", [])
        ], NavigationModule);
        return NavigationModule;
    }());

    /**
     * An object containing properties for notification messages
     */
    var Notification = /** @class */ (function () {
        function Notification() {
        }
        return Notification;
    }());

    /**
     * An object containing properties for notification events
     */
    var NotificationEvent = /** @class */ (function () {
        function NotificationEvent() {
        }
        return NotificationEvent;
    }());

    /**
     * An object containing properties for notification groups
     */
    var NotificaitonGroup = /** @class */ (function () {
        function NotificaitonGroup() {
        }
        return NotificaitonGroup;
    }());

    /*
     * An object containing properties for a notification type
     */
    var NotificationType = /** @class */ (function () {
        function NotificationType() {
        }
        /**
         * Danger notification type
         */
        NotificationType.DANGER = 'danger';
        /**
         * Information notification type
         */
        NotificationType.INFO = 'info';
        /**
         * Success notification type
         */
        NotificationType.SUCCESS = 'success';
        /**
         * Warning notification type
         */
        NotificationType.WARNING = 'warning';
        return NotificationType;
    }());

    var __decorate$U = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata$w = (undefined && undefined.__metadata) || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    /**
     * Inline notifications can be used to provide notifications to user that can persist on the page
     * they are also optionally dismissable by the user
     */
    var InlineNotificationComponent = /** @class */ (function () {
        /**
         * The default constructor
         */
        function InlineNotificationComponent() {
            /**
             * Indicates whether or not the notification is currently hidden
             */
            this.hidden = false;
            /**
             * The event emitted when the mouse hovers over and leaves a notification
             */
            this.hiddenChange = new core.EventEmitter();
        }
        /**
         * Function called from the view when the notification is removed
         */
        InlineNotificationComponent.prototype.notificationRemove = function () {
            this.hidden = true;
            this.hiddenChange.emit(this.hidden);
        };
        __decorate$U([
            core.Input(),
            __metadata$w("design:type", NotificationType)
        ], InlineNotificationComponent.prototype, "type", void 0);
        __decorate$U([
            core.Input(),
            __metadata$w("design:type", String)
        ], InlineNotificationComponent.prototype, "message", void 0);
        __decorate$U([
            core.Input(),
            __metadata$w("design:type", String)
        ], InlineNotificationComponent.prototype, "header", void 0);
        __decorate$U([
            core.Input(),
            __metadata$w("design:type", Boolean)
        ], InlineNotificationComponent.prototype, "dismissable", void 0);
        __decorate$U([
            core.Input(),
            __metadata$w("design:type", Boolean)
        ], InlineNotificationComponent.prototype, "hidden", void 0);
        __decorate$U([
            core.Output('hiddenChange'),
            __metadata$w("design:type", Object)
        ], InlineNotificationComponent.prototype, "hiddenChange", void 0);
        InlineNotificationComponent = __decorate$U([
            core.Component({
                encapsulation: core.ViewEncapsulation.None,
                selector: 'pfng-inline-notification',
                template: "<div class=\"alert alert-{{type}}\" [ngClass]=\"{'alert-dismissable': dismissable === true}\" *ngIf=\"!hidden\"><button *ngIf=\"dismissable\" (click)=\"notificationRemove()\" type=\"button\" class=\"close\" aria-hidden=\"true\"><span class=\"pficon pficon-close\"></span></button> <span class=\"pficon pficon-ok\" *ngIf=\"type === 'success'\"></span> <span class=\"pficon pficon-info\" *ngIf=\"type === 'info'\"></span> <span class=\"pficon pficon-error-circle-o\" *ngIf=\"type === 'danger'\"></span> <span class=\"pficon pficon-warning-triangle-o\" *ngIf=\"type === 'warning'\"></span> <strong>{{header}}</strong> {{message}}</div>"
            }),
            __metadata$w("design:paramtypes", [])
        ], InlineNotificationComponent);
        return InlineNotificationComponent;
    }());

    var __decorate$V = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    /**
     * A module containing objects associated with inline notifications
     */
    var InlineNotificationModule = /** @class */ (function () {
        function InlineNotificationModule() {
        }
        InlineNotificationModule = __decorate$V([
            core.NgModule({
                imports: [
                    common.CommonModule,
                    forms.FormsModule
                ],
                declarations: [
                    InlineNotificationComponent
                ],
                exports: [
                    InlineNotificationComponent
                ]
            })
        ], InlineNotificationModule);
        return InlineNotificationModule;
    }());

    var __decorate$W = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata$x = (undefined && undefined.__metadata) || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    /**
     * Notification drawer component
     *
     * This provides a common mechanism to handle how the notification drawer should look and behave without mandating
     * the look of the notification group heading or notification body.
     */
    var NotificationDrawerComponent = /** @class */ (function () {
        // Initialization
        /**
         * The default constructor
         */
        function NotificationDrawerComponent() {
            /**
             * Flag if the drawer can be expanded. Optional, default: false
             */
            this.allowExpand = false;
            /**
             * Flag if the drawer is expanded (only valid if allowExpand is true). Optional, default: false
             */
            this.expanded = false;
            /**
             * Flag if the mark all read button should be shown, optional, default is false
             */
            this.showMarkAllRead = false;
            /**
             * Event emitter when close icon clicked
             */
            this.close = new core.EventEmitter();
            /**
             * Event emitter when mark all button clicked
             */
            this.unreadNotifications = new core.EventEmitter();
        }
        /**
         * Setup component configuration upon initialization
         */
        NotificationDrawerComponent.prototype.ngOnInit = function () {
            this.collapseOpenGroups();
            this.singleGroup = lodash.size(this.notificationGroups) < 2;
            this.markreadCount = 0;
            this.setEmptyConfig();
            this.readCountConfig();
        };
        // Actions
        /**
         *  Return boolean if group has notifications
         *  @param group
         */
        NotificationDrawerComponent.prototype.hasNotifications = function (group) {
            return lodash.size(lodash.get(group, 'notifications')) > 0;
        };
        /**
         *  Return boolean if group has unread notifications
         *  @param group
         */
        NotificationDrawerComponent.prototype.hasUnread = function (group) {
            return lodash.size(lodash.filter(lodash.get(group, 'notifications'), { 'isViewing': false })) > 0;
        };
        /**
         * method for the close button, emits event with clicked over close icon
         *
         */
        NotificationDrawerComponent.prototype.onClose = function () {
            this.hidden = true;
            this.close.emit(this.hidden);
        };
        /**
         * Method for the mark all read button (Optional)
         * @param group
         */
        NotificationDrawerComponent.prototype.onMarkAllRead = function (group) {
            group.notifications.forEach(function (n) { return n.isViewing = true; });
            this.updateReadCount();
        };
        /**
         *  Method for the clear all button (Optional)
         *  @param group
         */
        NotificationDrawerComponent.prototype.onClearAll = function (group) {
            group.notifications = null;
            group.subHeading = '0 New Events';
        };
        /**
         *  Toggle to show / hide drawer
         *  @param group
         */
        NotificationDrawerComponent.prototype.toggleCollapse = function (group) {
            if (group.open) {
                group.open = false;
            }
            else {
                this.collapseOpenGroups();
                group.open = true;
            }
        };
        /**
         * Toggle to expand the drawer
         */
        NotificationDrawerComponent.prototype.toggleExpandDrawer = function () {
            if (this.allowExpand)
                this.expanded = !this.expanded;
        };
        // Private
        /**
         * Collapse panel for all groups
         */
        NotificationDrawerComponent.prototype.collapseOpenGroups = function () {
            this.notificationGroups.forEach(function (grp) { return grp.open = false; });
        };
        /**
         * Emit event during the inital load based on total unread notification
         */
        NotificationDrawerComponent.prototype.readCountConfig = function () {
            this.unreadCount = this.totalUnreadNotifications(this.notificationGroups);
            if (this.unreadCount > 0) {
                this.unreadNotifications.emit(true);
            }
            else {
                this.unreadNotifications.emit(false);
            }
        };
        /**
         * Empty config setup
         */
        NotificationDrawerComponent.prototype.setEmptyConfig = function () {
            this.emptyStateConfig = {
                iconStyleClass: 'pficon-info',
                title: this.noNotificationsText || this.noNotificationsText || 'There are no notifications to display.'
            };
        };
        /**
         * Total number of unread notifications
         * @param groups
         */
        NotificationDrawerComponent.prototype.totalUnreadNotifications = function (groups) {
            return lodash.size(lodash.filter(groups.map(function (g) { return lodash.filter(lodash.get(g, 'notifications'), { 'isViewing': false }).length > 0; }), function (o) { return o === true; }));
        };
        /**
         * Emit event when no unread notifications are remains
         */
        NotificationDrawerComponent.prototype.updateReadCount = function () {
            this.markreadCount = this.markreadCount + 1;
            if (this.markreadCount === this.unreadCount) {
                this.unreadNotifications.emit(false);
            }
        };
        __decorate$W([
            core.Input(),
            __metadata$x("design:type", Boolean)
        ], NotificationDrawerComponent.prototype, "allowExpand", void 0);
        __decorate$W([
            core.Input(),
            __metadata$x("design:type", Boolean)
        ], NotificationDrawerComponent.prototype, "expanded", void 0);
        __decorate$W([
            core.Input(),
            __metadata$x("design:type", core.TemplateRef)
        ], NotificationDrawerComponent.prototype, "headingTemplate", void 0);
        __decorate$W([
            core.Input(),
            __metadata$x("design:type", Boolean)
        ], NotificationDrawerComponent.prototype, "hidden", void 0);
        __decorate$W([
            core.Input(),
            __metadata$x("design:type", String)
        ], NotificationDrawerComponent.prototype, "noNotificationsText", void 0);
        __decorate$W([
            core.Input(),
            __metadata$x("design:type", core.TemplateRef)
        ], NotificationDrawerComponent.prototype, "notificationBodyTemplate", void 0);
        __decorate$W([
            core.Input(),
            __metadata$x("design:type", core.TemplateRef)
        ], NotificationDrawerComponent.prototype, "notificationFooterTemplate", void 0);
        __decorate$W([
            core.Input(),
            __metadata$x("design:type", Array)
        ], NotificationDrawerComponent.prototype, "notificationGroups", void 0);
        __decorate$W([
            core.Input(),
            __metadata$x("design:type", String)
        ], NotificationDrawerComponent.prototype, "notificationTrackField", void 0);
        __decorate$W([
            core.Input(),
            __metadata$x("design:type", Boolean)
        ], NotificationDrawerComponent.prototype, "showMarkAllRead", void 0);
        __decorate$W([
            core.Input(),
            __metadata$x("design:type", Boolean)
        ], NotificationDrawerComponent.prototype, "showClearAll", void 0);
        __decorate$W([
            core.Input(),
            __metadata$x("design:type", Boolean)
        ], NotificationDrawerComponent.prototype, "singleGroup", void 0);
        __decorate$W([
            core.Input(),
            __metadata$x("design:type", core.TemplateRef)
        ], NotificationDrawerComponent.prototype, "subHeadingTemplate", void 0);
        __decorate$W([
            core.Input(),
            __metadata$x("design:type", String)
        ], NotificationDrawerComponent.prototype, "title", void 0);
        __decorate$W([
            core.Input(),
            __metadata$x("design:type", core.TemplateRef)
        ], NotificationDrawerComponent.prototype, "titleTemplate", void 0);
        __decorate$W([
            core.Output('close'),
            __metadata$x("design:type", Object)
        ], NotificationDrawerComponent.prototype, "close", void 0);
        __decorate$W([
            core.Output('unreadNotifications'),
            __metadata$x("design:type", Object)
        ], NotificationDrawerComponent.prototype, "unreadNotifications", void 0);
        NotificationDrawerComponent = __decorate$W([
            core.Component({
                encapsulation: core.ViewEncapsulation.None,
                selector: 'pfng-notification-drawer',
                template: "<div class=\"drawer-pf\" [ngClass]=\"{'hide': hidden, 'drawer-pf-expanded': expanded}\"><div *ngIf=\"title\" class=\"drawer-pf-title\"><a *ngIf=\"allowExpand\" class=\"drawer-pf-toggle-expand fa fa-angle-double-left hidden-xs\" (click)=\"toggleExpandDrawer()\"></a> <a class=\"drawer-pf-close pficon pficon-close\" (click)=\"onClose()\"></a><div *ngIf=\"titleTemplate; then showTitleTemplate else showTitle\"></div><ng-template #showTitle><h3 class=\"text-center\">{{title}}</h3></ng-template><ng-template #showTitleTemplate [ngTemplateOutlet]=\"titleTemplate\"></ng-template></div><div *ngIf=\"!notificationGroups\"><pfng-empty-state [config]=\"emptyStateConfig\"></pfng-empty-state></div><div *ngIf=\"notificationGroups\" class=\"panel-group\"><div class=\"panel panel-default\" [ngClass]=\"{expanded: notificationGroup.open}\" *ngFor=\"let notificationGroup of notificationGroups, let index = index\"><div class=\"panel-heading\"><h4 class=\"panel-title\"><a *ngIf=\"!singleGroup\" (click)=\"toggleCollapse(notificationGroup)\" [ngClass]=\"{collapsed: !notificationGroup.open}\"><span><ng-template let-group=\"notificationGroup\" let-index=\"index\" [ngTemplateOutlet]=\"headingTemplate\" [ngTemplateOutletContext]=\"{group:notificationGroup, index: index}\"></ng-template></span></a></h4><ng-template class=\"panel-counter\" let-group=\"notificationGroup\" let-index=\"index\" [ngTemplateOutlet]=\"subHeadingTemplate\" [ngTemplateOutletContext]=\"{group:notificationGroup, index: index}\"></ng-template></div><div class=\"panel-collapse collapse\" [ngClass]=\"{in: notificationGroup.open || notificationGroups.length === 1}\"><div *ngIf=\"hasNotifications(notificationGroup)\" class=\"panel-body\"><div class=\"drawer-pf-notification\" [ngClass]=\"{unread: !notification.isViewing, 'expanded-notification': expanded}\" *ngFor=\"let notification of notificationGroup.notifications trackBy notificationTrackField, let index = index\"><ng-template let-notify=\"notification\" let-index=\"index\" [ngTemplateOutlet]=\"notificationBodyTemplate\" [ngTemplateOutletContext]=\"{notify:notification, index: index}\"></ng-template></div><div *ngIf=\"notificationGroup.loading\" class=\"drawer-pf-loading text-center\"><span class=\"spinner spinner-xs spinner-inline\"></span> Loading More</div></div><div *ngIf=\"(showClearAll || showMarkAllRead) && hasNotifications(notificationGroup)\" class=\"drawer-pf-action\"><span class=\"drawer-pf-action-link\" *ngIf=\"showMarkAllRead && hasUnread(notificationGroup)\"><button class=\"btn btn-link\" (click)=\"onMarkAllRead(notificationGroup)\">Mark All Read</button> </span><span class=\"drawer-pf-action-link\"><button class=\"btn btn-link\" *ngIf=\"showClearAll\" (click)=\"onClearAll(notificationGroup)\"><span class=\"pficon pficon-close\"></span> Clear All</button></span></div><div *ngIf=\"!hasNotifications(notificationGroup)\"><div class=\"panel-body\"><pfng-empty-state [config]=\"notificationGroup.emptyStateConfig\"></pfng-empty-state></div></div><ng-template *ngIf=\"notificationFooterTemplate\" [ngTemplateOutlet]=\"notificationFooterTemplate\"></ng-template></div></div></div></div>"
            }),
            __metadata$x("design:paramtypes", [])
        ], NotificationDrawerComponent);
        return NotificationDrawerComponent;
    }());

    var __decorate$X = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    /**
     * A module containing objects associated with the notification drawer
     */
    var NotificationDrawerModule = /** @class */ (function () {
        function NotificationDrawerModule() {
        }
        NotificationDrawerModule = __decorate$X([
            core.NgModule({
                imports: [
                    common.CommonModule,
                    EmptyStateModule,
                    forms.FormsModule
                ],
                declarations: [
                    NotificationDrawerComponent
                ],
                exports: [
                    NotificationDrawerComponent
                ]
            })
        ], NotificationDrawerModule);
        return NotificationDrawerModule;
    }());

    var __decorate$Y = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata$y = (undefined && undefined.__metadata) || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    /**
     * Toast notifications are used to notify users of a system occurrence. Toast notifications should be transient and stay
     * on the screen for 8 seconds, so that they do not block the information behind them for too long, but allows the user
     * to read the message. The ToastNotification component allows status, header, message, primary action and menu actions
     * for the notification. The notification can also allow the user to close the notification.
     *
     * Note: Using the kebab menu (more actions) with the close button is not currently supported. If both are specified the
     * close button will not be shown. Add a close menu item if you want to have both capabilities.
     */
    var ToastNotificationComponent = /** @class */ (function () {
        /**
         * The default constructor
         */
        function ToastNotificationComponent() {
            /**
             * The event emitted when an action has been selected
             */
            this.onActionSelect = new core.EventEmitter();
            /**
             * The event emitted when the close button has been selected
             */
            this.onCloseSelect = new core.EventEmitter();
            /**
             * The event emitted when the mouse hovers over and leaves a notification
             */
            this.onViewingChange = new core.EventEmitter();
            this._showCloseButton = false;
        }
        // Initialization
        /**
         * Setup component configuration upon initialization
         */
        ToastNotificationComponent.prototype.ngOnInit = function () {
        };
        /**
         * Check if the component config has changed
         */
        ToastNotificationComponent.prototype.ngDoCheck = function () {
            this._showCloseButton = (this.showClose === true)
                && (this.moreActions === undefined || this.moreActions === null || this.moreActions.length === 0);
        };
        Object.defineProperty(ToastNotificationComponent.prototype, "showCloseButton", {
            // Accessors
            /**
             * Get the flag indicating that the close button should be shown
             *
             * @returns {FilterField} The flag indicating that the close button should be shown
             */
            get: function () {
                return this._showCloseButton;
            },
            enumerable: true,
            configurable: true
        });
        // Actions
        ToastNotificationComponent.prototype.handleEnter = function ($event) {
            this.onViewingChange.emit({
                notification: this.notification,
                isViewing: true
            });
        };
        ToastNotificationComponent.prototype.handleLeave = function ($event) {
            this.onViewingChange.emit({
                notification: this.notification,
                isViewing: false
            });
        };
        // Private
        ToastNotificationComponent.prototype.handleAction = function (action) {
            if (action && action.disabled !== true) {
                this.onActionSelect.emit({
                    action: action,
                    notification: this.notification
                });
            }
        };
        ToastNotificationComponent.prototype.handleClose = function ($event) {
            this.onCloseSelect.emit({ notification: this.notification });
        };
        __decorate$Y([
            core.Input(),
            __metadata$y("design:type", String)
        ], ToastNotificationComponent.prototype, "header", void 0);
        __decorate$Y([
            core.Input(),
            __metadata$y("design:type", String)
        ], ToastNotificationComponent.prototype, "message", void 0);
        __decorate$Y([
            core.Input(),
            __metadata$y("design:type", Array)
        ], ToastNotificationComponent.prototype, "moreActions", void 0);
        __decorate$Y([
            core.Input(),
            __metadata$y("design:type", Notification)
        ], ToastNotificationComponent.prototype, "notification", void 0);
        __decorate$Y([
            core.Input(),
            __metadata$y("design:type", Action)
        ], ToastNotificationComponent.prototype, "primaryAction", void 0);
        __decorate$Y([
            core.Input(),
            __metadata$y("design:type", Boolean)
        ], ToastNotificationComponent.prototype, "showClose", void 0);
        __decorate$Y([
            core.Input(),
            __metadata$y("design:type", String)
        ], ToastNotificationComponent.prototype, "type", void 0);
        __decorate$Y([
            core.Output('onActionSelect'),
            __metadata$y("design:type", Object)
        ], ToastNotificationComponent.prototype, "onActionSelect", void 0);
        __decorate$Y([
            core.Output('onCloseSelect'),
            __metadata$y("design:type", Object)
        ], ToastNotificationComponent.prototype, "onCloseSelect", void 0);
        __decorate$Y([
            core.Output('onViewingChange'),
            __metadata$y("design:type", Object)
        ], ToastNotificationComponent.prototype, "onViewingChange", void 0);
        ToastNotificationComponent = __decorate$Y([
            core.Component({
                encapsulation: core.ViewEncapsulation.None,
                selector: 'pfng-toast-notification',
                template: "<div class=\"toast-pf alert alert-{{type}}\" [ngClass]=\"{'alert-dismissable': showCloseButton}\" (mouseenter)=\"handleEnter($event)\" (mouseleave)=\"handleLeave($event)\"><div *ngIf=\"moreActions?.length > 0\" class=\"pull-right dropdown-kebab-pf\" dropdown><button class=\"btn btn-link dropdown-toggle\" type=\"button\" id=\"dropdownKebabRight\" dropdownToggle><span class=\"fa fa-ellipsis-v\"></span></button><ul class=\"dropdown-menu dropdown-menu-right\" aria-labelledby=\"dropdownKebabRight\" *dropdownMenu><li *ngFor=\"let action of moreActions\" class=\"{{action.styleClass}}\" [attr.role]=\"action.separator === true ? 'separator' : 'menuitem'\" [ngClass]=\"{'divider': action.separator === true, 'disabled': action.disabled === true, 'hidden': action.visible === false}\"><a *ngIf=\"action.disabled !== true && action.separator !== true\" class=\"dropdown-item secondary-action\" href=\"javascript:void(0)\" title=\"{{action.tooltip}}\" (click)=\"handleAction(action)\">{{action.title}}</a> <a *ngIf=\"action.disabled === true && action.separator !== true\" class=\"dropdown-item secondary-action\" href=\"javascript:void(0)\" title=\"{{action.tooltip}}\" onclick=\"return false;\">{{action.title}}</a></li></ul></div><button *ngIf=\"showCloseButton\" type=\"button\" class=\"close\" aria-hidden=\"true\" (click)=\"handleClose($event)\"><span class=\"pficon pficon-close\"></span></button><div *ngIf=\"primaryAction\" class=\"pull-right toast-pf-action {{primaryAction.styleClass}}\" [ngClass]=\"{'padding-right-15': showCloseButton == true, 'hidden': primaryAction?.visible === false}\"><div *ngIf=\"primaryAction.template; then showButtonTemplate else showButton\"></div><ng-template #showButtonTemplate let-action=\"action\" [ngTemplateOutlet]=\"primaryAction.template\" [ngTemplateOutletContext]=\"{ action: action }\"></ng-template><ng-template #showButton><a *ngIf=\"primaryAction.disabled !== true\" href=\"javascript:void(0)\" title=\"{{primaryAction?.tooltip}}\" (click)=\"handleAction(primaryAction)\">{{primaryAction?.title}}</a> <a *ngIf=\"primaryAction.disabled === true\" href=\"javascript:void(0)\" title=\"{{primaryAction?.tooltip}}\" onclick=\"return false;\">{{primaryAction?.title}}</a></ng-template></div><span class=\"pficon pficon-ok\" *ngIf=\"type === 'success'\"></span> <span class=\"pficon pficon-info\" *ngIf=\"type === 'info'\"></span> <span class=\"pficon pficon-error-circle-o\" *ngIf=\"type === 'danger'\"></span> <span class=\"pficon pficon-warning-triangle-o\" *ngIf=\"type === 'warning'\"></span> <span *ngIf=\"header\"><strong>{{header}}</strong> {{message}} </span><span *ngIf=\"!header\">{{message}}</span></div>"
            }),
            __metadata$y("design:paramtypes", [])
        ], ToastNotificationComponent);
        return ToastNotificationComponent;
    }());

    var __decorate$Z = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    /**
     * A module containing objects associated with toast notifications
     */
    var ToastNotificationModule = /** @class */ (function () {
        function ToastNotificationModule() {
        }
        ToastNotificationModule = __decorate$Z([
            core.NgModule({
                imports: [
                    BsDropdownModule.forRoot(),
                    common.CommonModule,
                    forms.FormsModule
                ],
                declarations: [
                    ToastNotificationComponent
                ],
                exports: [
                    ToastNotificationComponent
                ],
                providers: [
                    BsDropdownConfig
                ]
            })
        ], ToastNotificationModule);
        return ToastNotificationModule;
    }());

    var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata$z = (undefined && undefined.__metadata) || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    /**
     * Component to display a list of toast notifications
     */
    var ToastNotificationListComponent = /** @class */ (function () {
        /**
         * The default constructor
         */
        function ToastNotificationListComponent() {
            /**
             * The event emitted when an action has been selected
             */
            this.onActionSelect = new core.EventEmitter();
            /**
             * The event emitted when the close button has been selected
             */
            this.onCloseSelect = new core.EventEmitter();
            /**
             * The event emitted when the mouse hovers over and leaves a notification
             */
            this.onViewingChange = new core.EventEmitter();
        }
        // Initialization
        /**
         * Setup component configuration upon initialization
         */
        ToastNotificationListComponent.prototype.ngOnInit = function () {
        };
        // Actions
        /**
         * Check if the component config has changed
         */
        ToastNotificationListComponent.prototype.handleAction = function ($event) {
            this.onActionSelect.emit($event);
        };
        ToastNotificationListComponent.prototype.handleClose = function ($event) {
            this.onCloseSelect.emit($event);
        };
        ToastNotificationListComponent.prototype.handleViewingChange = function ($event) {
            this.onViewingChange.emit($event);
        };
        __decorate([
            core.Input(),
            __metadata$z("design:type", Array)
        ], ToastNotificationListComponent.prototype, "notifications", void 0);
        __decorate([
            core.Input(),
            __metadata$z("design:type", Boolean)
        ], ToastNotificationListComponent.prototype, "showClose", void 0);
        __decorate([
            core.Output('onActionSelect'),
            __metadata$z("design:type", Object)
        ], ToastNotificationListComponent.prototype, "onActionSelect", void 0);
        __decorate([
            core.Output('onCloseSelect'),
            __metadata$z("design:type", Object)
        ], ToastNotificationListComponent.prototype, "onCloseSelect", void 0);
        __decorate([
            core.Output('onViewingChange'),
            __metadata$z("design:type", Object)
        ], ToastNotificationListComponent.prototype, "onViewingChange", void 0);
        ToastNotificationListComponent = __decorate([
            core.Component({
                encapsulation: core.ViewEncapsulation.None,
                selector: 'pfng-toast-notification-list',
                template: "<div class=\"toast-notifications-list-pf\" *ngIf=\"notifications?.length > 0\"><div *ngFor=\"let notification of notifications\"><pfng-toast-notification [header]=\"notification.header\" [message]=\"notification.message\" [notification]=\"notification\" [moreActions]=\"notification.moreActions\" [primaryAction]=\"notification.primaryAction\" [showClose]=\"showClose === true || notification.isPersistent === true\" [type]=\"notification.type\" (onActionSelect)=\"handleAction($event)\" (onCloseSelect)=\"handleClose($event)\" (onViewingChange)=\"handleViewingChange($event)\"></pfng-toast-notification></div></div>"
            }),
            __metadata$z("design:paramtypes", [])
        ], ToastNotificationListComponent);
        return ToastNotificationListComponent;
    }());

    var __decorate$_ = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    /**
     * A module containing objects associated with toast notification lists
     */
    var ToastNotificationListModule = /** @class */ (function () {
        function ToastNotificationListModule() {
        }
        ToastNotificationListModule = __decorate$_([
            core.NgModule({
                imports: [
                    common.CommonModule,
                    forms.FormsModule,
                    ToastNotificationModule
                ],
                declarations: [
                    ToastNotificationListComponent
                ],
                exports: [
                    ToastNotificationListComponent
                ]
            })
        ], ToastNotificationListModule);
        return ToastNotificationListModule;
    }());

    var __decorate$10 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata$A = (undefined && undefined.__metadata) || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    /**
     * A module containing objects associated with notification components
     *
     * @deprecated Use individual module imports
     *
     * import {
     *   InlineNotificationModule,
     *   NotificationDrawerModule,
     *   ToastNotificationModule,
     *   ToastNotificationListModule
     * } from 'patternfly-ng/notification';
     */
    var NotificationModule = /** @class */ (function () {
        function NotificationModule() {
            console.log('patternfly-ng: NotificationModule is deprecated; use InlineNotificationModule, ' +
                'NotificationDrawerModule, ToastNotificationModule, or ToastNotificationListModule');
        }
        NotificationModule = __decorate$10([
            core.NgModule({
                imports: [
                    common.CommonModule,
                    forms.FormsModule,
                    InlineNotificationModule,
                    NotificationDrawerModule,
                    ToastNotificationModule,
                    ToastNotificationListModule
                ],
                exports: [
                    InlineNotificationComponent,
                    NotificationDrawerComponent,
                    ToastNotificationComponent,
                    ToastNotificationListComponent
                ]
            }),
            __metadata$A("design:paramtypes", [])
        ], NotificationModule);
        return NotificationModule;
    }());

    var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function createCommonjsModule(fn, module) {
    	return module = { exports: {} }, fn(module, module.exports), module.exports;
    }

    // CommonJS / Node have global context exposed as "global" variable.
    // We don't want to include the whole node.d.ts this this compilation unit so we'll just fake
    // the global "global" var for now.
    var __window = typeof window !== 'undefined' && window;
    var __self = typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' &&
        self instanceof WorkerGlobalScope && self;
    var __global = typeof commonjsGlobal !== 'undefined' && commonjsGlobal;
    var _root = __window || __global || __self;
    var root_1 = _root;
    // Workaround Closure Compiler restriction: The body of a goog.module cannot use throw.
    // This is needed when used with angular/tsickle which inserts a goog.module statement.
    // Wrap in IIFE
    (function () {
        if (!_root) {
            throw new Error('RxJS could not find any global context (window, self, global)');
        }
    })();


    var root = {
    	root: root_1
    };

    function isFunction(x) {
        return typeof x === 'function';
    }
    var isFunction_2 = isFunction;


    var isFunction_1 = {
    	isFunction: isFunction_2
    };

    var isArray_1 = Array.isArray || (function (x) { return x && typeof x.length === 'number'; });


    var isArray = {
    	isArray: isArray_1
    };

    function isObject(x) {
        return x != null && typeof x === 'object';
    }
    var isObject_2 = isObject;


    var isObject_1 = {
    	isObject: isObject_2
    };

    // typeof any so that it we don't have to cast when comparing a result to the error object
    var errorObject_1 = { e: {} };


    var errorObject = {
    	errorObject: errorObject_1
    };

    var tryCatchTarget;
    function tryCatcher() {
        try {
            return tryCatchTarget.apply(this, arguments);
        }
        catch (e) {
            errorObject.errorObject.e = e;
            return errorObject.errorObject;
        }
    }
    function tryCatch(fn) {
        tryCatchTarget = fn;
        return tryCatcher;
    }
    var tryCatch_2 = tryCatch;


    var tryCatch_1 = {
    	tryCatch: tryCatch_2
    };

    var __extends$j = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    /**
     * An error thrown when one or more errors have occurred during the
     * `unsubscribe` of a {@link Subscription}.
     */
    var UnsubscriptionError = (function (_super) {
        __extends$j(UnsubscriptionError, _super);
        function UnsubscriptionError(errors) {
            _super.call(this);
            this.errors = errors;
            var err = Error.call(this, errors ?
                errors.length + " errors occurred during unsubscription:\n  " + errors.map(function (err, i) { return ((i + 1) + ") " + err.toString()); }).join('\n  ') : '');
            this.name = err.name = 'UnsubscriptionError';
            this.stack = err.stack;
            this.message = err.message;
        }
        return UnsubscriptionError;
    }(Error));
    var UnsubscriptionError_2 = UnsubscriptionError;


    var UnsubscriptionError_1 = {
    	UnsubscriptionError: UnsubscriptionError_2
    };

    /**
     * Represents a disposable resource, such as the execution of an Observable. A
     * Subscription has one important method, `unsubscribe`, that takes no argument
     * and just disposes the resource held by the subscription.
     *
     * Additionally, subscriptions may be grouped together through the `add()`
     * method, which will attach a child Subscription to the current Subscription.
     * When a Subscription is unsubscribed, all its children (and its grandchildren)
     * will be unsubscribed as well.
     *
     * @class Subscription
     */
    var Subscription = (function () {
        /**
         * @param {function(): void} [unsubscribe] A function describing how to
         * perform the disposal of resources when the `unsubscribe` method is called.
         */
        function Subscription(unsubscribe) {
            /**
             * A flag to indicate whether this Subscription has already been unsubscribed.
             * @type {boolean}
             */
            this.closed = false;
            this._parent = null;
            this._parents = null;
            this._subscriptions = null;
            if (unsubscribe) {
                this._unsubscribe = unsubscribe;
            }
        }
        /**
         * Disposes the resources held by the subscription. May, for instance, cancel
         * an ongoing Observable execution or cancel any other type of work that
         * started when the Subscription was created.
         * @return {void}
         */
        Subscription.prototype.unsubscribe = function () {
            var hasErrors = false;
            var errors;
            if (this.closed) {
                return;
            }
            var _a = this, _parent = _a._parent, _parents = _a._parents, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;
            this.closed = true;
            this._parent = null;
            this._parents = null;
            // null out _subscriptions first so any child subscriptions that attempt
            // to remove themselves from this subscription will noop
            this._subscriptions = null;
            var index = -1;
            var len = _parents ? _parents.length : 0;
            // if this._parent is null, then so is this._parents, and we
            // don't have to remove ourselves from any parent subscriptions.
            while (_parent) {
                _parent.remove(this);
                // if this._parents is null or index >= len,
                // then _parent is set to null, and the loop exits
                _parent = ++index < len && _parents[index] || null;
            }
            if (isFunction_1.isFunction(_unsubscribe)) {
                var trial = tryCatch_1.tryCatch(_unsubscribe).call(this);
                if (trial === errorObject.errorObject) {
                    hasErrors = true;
                    errors = errors || (errorObject.errorObject.e instanceof UnsubscriptionError_1.UnsubscriptionError ?
                        flattenUnsubscriptionErrors(errorObject.errorObject.e.errors) : [errorObject.errorObject.e]);
                }
            }
            if (isArray.isArray(_subscriptions)) {
                index = -1;
                len = _subscriptions.length;
                while (++index < len) {
                    var sub = _subscriptions[index];
                    if (isObject_1.isObject(sub)) {
                        var trial = tryCatch_1.tryCatch(sub.unsubscribe).call(sub);
                        if (trial === errorObject.errorObject) {
                            hasErrors = true;
                            errors = errors || [];
                            var err = errorObject.errorObject.e;
                            if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {
                                errors = errors.concat(flattenUnsubscriptionErrors(err.errors));
                            }
                            else {
                                errors.push(err);
                            }
                        }
                    }
                }
            }
            if (hasErrors) {
                throw new UnsubscriptionError_1.UnsubscriptionError(errors);
            }
        };
        /**
         * Adds a tear down to be called during the unsubscribe() of this
         * Subscription.
         *
         * If the tear down being added is a subscription that is already
         * unsubscribed, is the same reference `add` is being called on, or is
         * `Subscription.EMPTY`, it will not be added.
         *
         * If this subscription is already in an `closed` state, the passed
         * tear down logic will be executed immediately.
         *
         * @param {TeardownLogic} teardown The additional logic to execute on
         * teardown.
         * @return {Subscription} Returns the Subscription used or created to be
         * added to the inner subscriptions list. This Subscription can be used with
         * `remove()` to remove the passed teardown logic from the inner subscriptions
         * list.
         */
        Subscription.prototype.add = function (teardown) {
            if (!teardown || (teardown === Subscription.EMPTY)) {
                return Subscription.EMPTY;
            }
            if (teardown === this) {
                return this;
            }
            var subscription = teardown;
            switch (typeof teardown) {
                case 'function':
                    subscription = new Subscription(teardown);
                case 'object':
                    if (subscription.closed || typeof subscription.unsubscribe !== 'function') {
                        return subscription;
                    }
                    else if (this.closed) {
                        subscription.unsubscribe();
                        return subscription;
                    }
                    else if (typeof subscription._addParent !== 'function' /* quack quack */) {
                        var tmp = subscription;
                        subscription = new Subscription();
                        subscription._subscriptions = [tmp];
                    }
                    break;
                default:
                    throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');
            }
            var subscriptions = this._subscriptions || (this._subscriptions = []);
            subscriptions.push(subscription);
            subscription._addParent(this);
            return subscription;
        };
        /**
         * Removes a Subscription from the internal list of subscriptions that will
         * unsubscribe during the unsubscribe process of this Subscription.
         * @param {Subscription} subscription The subscription to remove.
         * @return {void}
         */
        Subscription.prototype.remove = function (subscription) {
            var subscriptions = this._subscriptions;
            if (subscriptions) {
                var subscriptionIndex = subscriptions.indexOf(subscription);
                if (subscriptionIndex !== -1) {
                    subscriptions.splice(subscriptionIndex, 1);
                }
            }
        };
        Subscription.prototype._addParent = function (parent) {
            var _a = this, _parent = _a._parent, _parents = _a._parents;
            if (!_parent || _parent === parent) {
                // If we don't have a parent, or the new parent is the same as the
                // current parent, then set this._parent to the new parent.
                this._parent = parent;
            }
            else if (!_parents) {
                // If there's already one parent, but not multiple, allocate an Array to
                // store the rest of the parent Subscriptions.
                this._parents = [parent];
            }
            else if (_parents.indexOf(parent) === -1) {
                // Only add the new parent to the _parents list if it's not already there.
                _parents.push(parent);
            }
        };
        Subscription.EMPTY = (function (empty) {
            empty.closed = true;
            return empty;
        }(new Subscription()));
        return Subscription;
    }());
    var Subscription_2 = Subscription;
    function flattenUnsubscriptionErrors(errors) {
        return errors.reduce(function (errs, err) { return errs.concat((err instanceof UnsubscriptionError_1.UnsubscriptionError) ? err.errors : err); }, []);
    }


    var Subscription_1 = {
    	Subscription: Subscription_2
    };

    var empty = {
        closed: true,
        next: function (value) { },
        error: function (err) { throw err; },
        complete: function () { }
    };


    var Observer = {
    	empty: empty
    };

    var rxSubscriber = createCommonjsModule(function (module, exports) {

    var Symbol = root.root.Symbol;
    exports.rxSubscriber = (typeof Symbol === 'function' && typeof Symbol.for === 'function') ?
        Symbol.for('rxSubscriber') : '@@rxSubscriber';
    /**
     * @deprecated use rxSubscriber instead
     */
    exports.$$rxSubscriber = exports.rxSubscriber;

    });
    var rxSubscriber_1 = rxSubscriber.rxSubscriber;
    var rxSubscriber_2 = rxSubscriber.$$rxSubscriber;

    var __extends$k = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };




    /**
     * Implements the {@link Observer} interface and extends the
     * {@link Subscription} class. While the {@link Observer} is the public API for
     * consuming the values of an {@link Observable}, all Observers get converted to
     * a Subscriber, in order to provide Subscription-like capabilities such as
     * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for
     * implementing operators, but it is rarely used as a public API.
     *
     * @class Subscriber<T>
     */
    var Subscriber = (function (_super) {
        __extends$k(Subscriber, _super);
        /**
         * @param {Observer|function(value: T): void} [destinationOrNext] A partially
         * defined Observer or a `next` callback function.
         * @param {function(e: ?any): void} [error] The `error` callback of an
         * Observer.
         * @param {function(): void} [complete] The `complete` callback of an
         * Observer.
         */
        function Subscriber(destinationOrNext, error, complete) {
            _super.call(this);
            this.syncErrorValue = null;
            this.syncErrorThrown = false;
            this.syncErrorThrowable = false;
            this.isStopped = false;
            switch (arguments.length) {
                case 0:
                    this.destination = Observer.empty;
                    break;
                case 1:
                    if (!destinationOrNext) {
                        this.destination = Observer.empty;
                        break;
                    }
                    if (typeof destinationOrNext === 'object') {
                        // HACK(benlesh): To resolve an issue where Node users may have multiple
                        // copies of rxjs in their node_modules directory.
                        if (isTrustedSubscriber(destinationOrNext)) {
                            var trustedSubscriber = destinationOrNext[rxSubscriber.rxSubscriber]();
                            this.syncErrorThrowable = trustedSubscriber.syncErrorThrowable;
                            this.destination = trustedSubscriber;
                            trustedSubscriber.add(this);
                        }
                        else {
                            this.syncErrorThrowable = true;
                            this.destination = new SafeSubscriber(this, destinationOrNext);
                        }
                        break;
                    }
                default:
                    this.syncErrorThrowable = true;
                    this.destination = new SafeSubscriber(this, destinationOrNext, error, complete);
                    break;
            }
        }
        Subscriber.prototype[rxSubscriber.rxSubscriber] = function () { return this; };
        /**
         * A static factory for a Subscriber, given a (potentially partial) definition
         * of an Observer.
         * @param {function(x: ?T): void} [next] The `next` callback of an Observer.
         * @param {function(e: ?any): void} [error] The `error` callback of an
         * Observer.
         * @param {function(): void} [complete] The `complete` callback of an
         * Observer.
         * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)
         * Observer represented by the given arguments.
         */
        Subscriber.create = function (next, error, complete) {
            var subscriber = new Subscriber(next, error, complete);
            subscriber.syncErrorThrowable = false;
            return subscriber;
        };
        /**
         * The {@link Observer} callback to receive notifications of type `next` from
         * the Observable, with a value. The Observable may call this method 0 or more
         * times.
         * @param {T} [value] The `next` value.
         * @return {void}
         */
        Subscriber.prototype.next = function (value) {
            if (!this.isStopped) {
                this._next(value);
            }
        };
        /**
         * The {@link Observer} callback to receive notifications of type `error` from
         * the Observable, with an attached {@link Error}. Notifies the Observer that
         * the Observable has experienced an error condition.
         * @param {any} [err] The `error` exception.
         * @return {void}
         */
        Subscriber.prototype.error = function (err) {
            if (!this.isStopped) {
                this.isStopped = true;
                this._error(err);
            }
        };
        /**
         * The {@link Observer} callback to receive a valueless notification of type
         * `complete` from the Observable. Notifies the Observer that the Observable
         * has finished sending push-based notifications.
         * @return {void}
         */
        Subscriber.prototype.complete = function () {
            if (!this.isStopped) {
                this.isStopped = true;
                this._complete();
            }
        };
        Subscriber.prototype.unsubscribe = function () {
            if (this.closed) {
                return;
            }
            this.isStopped = true;
            _super.prototype.unsubscribe.call(this);
        };
        Subscriber.prototype._next = function (value) {
            this.destination.next(value);
        };
        Subscriber.prototype._error = function (err) {
            this.destination.error(err);
            this.unsubscribe();
        };
        Subscriber.prototype._complete = function () {
            this.destination.complete();
            this.unsubscribe();
        };
        /** @deprecated internal use only */ Subscriber.prototype._unsubscribeAndRecycle = function () {
            var _a = this, _parent = _a._parent, _parents = _a._parents;
            this._parent = null;
            this._parents = null;
            this.unsubscribe();
            this.closed = false;
            this.isStopped = false;
            this._parent = _parent;
            this._parents = _parents;
            return this;
        };
        return Subscriber;
    }(Subscription_1.Subscription));
    var Subscriber_2 = Subscriber;
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var SafeSubscriber = (function (_super) {
        __extends$k(SafeSubscriber, _super);
        function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {
            _super.call(this);
            this._parentSubscriber = _parentSubscriber;
            var next;
            var context = this;
            if (isFunction_1.isFunction(observerOrNext)) {
                next = observerOrNext;
            }
            else if (observerOrNext) {
                next = observerOrNext.next;
                error = observerOrNext.error;
                complete = observerOrNext.complete;
                if (observerOrNext !== Observer.empty) {
                    context = Object.create(observerOrNext);
                    if (isFunction_1.isFunction(context.unsubscribe)) {
                        this.add(context.unsubscribe.bind(context));
                    }
                    context.unsubscribe = this.unsubscribe.bind(this);
                }
            }
            this._context = context;
            this._next = next;
            this._error = error;
            this._complete = complete;
        }
        SafeSubscriber.prototype.next = function (value) {
            if (!this.isStopped && this._next) {
                var _parentSubscriber = this._parentSubscriber;
                if (!_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(this._next, value);
                }
                else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {
                    this.unsubscribe();
                }
            }
        };
        SafeSubscriber.prototype.error = function (err) {
            if (!this.isStopped) {
                var _parentSubscriber = this._parentSubscriber;
                if (this._error) {
                    if (!_parentSubscriber.syncErrorThrowable) {
                        this.__tryOrUnsub(this._error, err);
                        this.unsubscribe();
                    }
                    else {
                        this.__tryOrSetError(_parentSubscriber, this._error, err);
                        this.unsubscribe();
                    }
                }
                else if (!_parentSubscriber.syncErrorThrowable) {
                    this.unsubscribe();
                    throw err;
                }
                else {
                    _parentSubscriber.syncErrorValue = err;
                    _parentSubscriber.syncErrorThrown = true;
                    this.unsubscribe();
                }
            }
        };
        SafeSubscriber.prototype.complete = function () {
            var _this = this;
            if (!this.isStopped) {
                var _parentSubscriber = this._parentSubscriber;
                if (this._complete) {
                    var wrappedComplete = function () { return _this._complete.call(_this._context); };
                    if (!_parentSubscriber.syncErrorThrowable) {
                        this.__tryOrUnsub(wrappedComplete);
                        this.unsubscribe();
                    }
                    else {
                        this.__tryOrSetError(_parentSubscriber, wrappedComplete);
                        this.unsubscribe();
                    }
                }
                else {
                    this.unsubscribe();
                }
            }
        };
        SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {
            try {
                fn.call(this._context, value);
            }
            catch (err) {
                this.unsubscribe();
                throw err;
            }
        };
        SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {
            try {
                fn.call(this._context, value);
            }
            catch (err) {
                parent.syncErrorValue = err;
                parent.syncErrorThrown = true;
                return true;
            }
            return false;
        };
        /** @deprecated internal use only */ SafeSubscriber.prototype._unsubscribe = function () {
            var _parentSubscriber = this._parentSubscriber;
            this._context = null;
            this._parentSubscriber = null;
            _parentSubscriber.unsubscribe();
        };
        return SafeSubscriber;
    }(Subscriber));
    function isTrustedSubscriber(obj) {
        return obj instanceof Subscriber || ('syncErrorThrowable' in obj && obj[rxSubscriber.rxSubscriber]);
    }


    var Subscriber_1 = {
    	Subscriber: Subscriber_2
    };

    function toSubscriber(nextOrObserver, error, complete) {
        if (nextOrObserver) {
            if (nextOrObserver instanceof Subscriber_1.Subscriber) {
                return nextOrObserver;
            }
            if (nextOrObserver[rxSubscriber.rxSubscriber]) {
                return nextOrObserver[rxSubscriber.rxSubscriber]();
            }
        }
        if (!nextOrObserver && !error && !complete) {
            return new Subscriber_1.Subscriber(Observer.empty);
        }
        return new Subscriber_1.Subscriber(nextOrObserver, error, complete);
    }
    var toSubscriber_2 = toSubscriber;


    var toSubscriber_1 = {
    	toSubscriber: toSubscriber_2
    };

    var observable = createCommonjsModule(function (module, exports) {

    function getSymbolObservable(context) {
        var $$observable;
        var Symbol = context.Symbol;
        if (typeof Symbol === 'function') {
            if (Symbol.observable) {
                $$observable = Symbol.observable;
            }
            else {
                $$observable = Symbol('observable');
                Symbol.observable = $$observable;
            }
        }
        else {
            $$observable = '@@observable';
        }
        return $$observable;
    }
    exports.getSymbolObservable = getSymbolObservable;
    exports.observable = getSymbolObservable(root.root);
    /**
     * @deprecated use observable instead
     */
    exports.$$observable = exports.observable;

    });
    var observable_1 = observable.getSymbolObservable;
    var observable_2 = observable.observable;
    var observable_3 = observable.$$observable;

    /* tslint:disable:no-empty */
    function noop() { }
    var noop_2 = noop;


    var noop_1 = {
    	noop: noop_2
    };

    /* tslint:enable:max-line-length */
    function pipe() {
        var fns = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            fns[_i - 0] = arguments[_i];
        }
        return pipeFromArray(fns);
    }
    var pipe_2 = pipe;
    /* @internal */
    function pipeFromArray(fns) {
        if (!fns) {
            return noop_1.noop;
        }
        if (fns.length === 1) {
            return fns[0];
        }
        return function piped(input) {
            return fns.reduce(function (prev, fn) { return fn(prev); }, input);
        };
    }
    var pipeFromArray_1 = pipeFromArray;


    var pipe_1 = {
    	pipe: pipe_2,
    	pipeFromArray: pipeFromArray_1
    };

    /**
     * A representation of any set of values over any amount of time. This is the most basic building block
     * of RxJS.
     *
     * @class Observable<T>
     */
    var Observable$1 = (function () {
        /**
         * @constructor
         * @param {Function} subscribe the function that is called when the Observable is
         * initially subscribed to. This function is given a Subscriber, to which new values
         * can be `next`ed, or an `error` method can be called to raise an error, or
         * `complete` can be called to notify of a successful completion.
         */
        function Observable$$1(subscribe) {
            this._isScalar = false;
            if (subscribe) {
                this._subscribe = subscribe;
            }
        }
        /**
         * Creates a new Observable, with this Observable as the source, and the passed
         * operator defined as the new observable's operator.
         * @method lift
         * @param {Operator} operator the operator defining the operation to take on the observable
         * @return {Observable} a new observable with the Operator applied
         */
        Observable$$1.prototype.lift = function (operator) {
            var observable$$1 = new Observable$$1();
            observable$$1.source = this;
            observable$$1.operator = operator;
            return observable$$1;
        };
        /**
         * Invokes an execution of an Observable and registers Observer handlers for notifications it will emit.
         *
         * <span class="informal">Use it when you have all these Observables, but still nothing is happening.</span>
         *
         * `subscribe` is not a regular operator, but a method that calls Observable's internal `subscribe` function. It
         * might be for example a function that you passed to a {@link create} static factory, but most of the time it is
         * a library implementation, which defines what and when will be emitted by an Observable. This means that calling
         * `subscribe` is actually the moment when Observable starts its work, not when it is created, as it is often
         * thought.
         *
         * Apart from starting the execution of an Observable, this method allows you to listen for values
         * that an Observable emits, as well as for when it completes or errors. You can achieve this in two
         * following ways.
         *
         * The first way is creating an object that implements {@link Observer} interface. It should have methods
         * defined by that interface, but note that it should be just a regular JavaScript object, which you can create
         * yourself in any way you want (ES6 class, classic function constructor, object literal etc.). In particular do
         * not attempt to use any RxJS implementation details to create Observers - you don't need them. Remember also
         * that your object does not have to implement all methods. If you find yourself creating a method that doesn't
         * do anything, you can simply omit it. Note however, that if `error` method is not provided, all errors will
         * be left uncaught.
         *
         * The second way is to give up on Observer object altogether and simply provide callback functions in place of its methods.
         * This means you can provide three functions as arguments to `subscribe`, where first function is equivalent
         * of a `next` method, second of an `error` method and third of a `complete` method. Just as in case of Observer,
         * if you do not need to listen for something, you can omit a function, preferably by passing `undefined` or `null`,
         * since `subscribe` recognizes these functions by where they were placed in function call. When it comes
         * to `error` function, just as before, if not provided, errors emitted by an Observable will be thrown.
         *
         * Whatever style of calling `subscribe` you use, in both cases it returns a Subscription object.
         * This object allows you to call `unsubscribe` on it, which in turn will stop work that an Observable does and will clean
         * up all resources that an Observable used. Note that cancelling a subscription will not call `complete` callback
         * provided to `subscribe` function, which is reserved for a regular completion signal that comes from an Observable.
         *
         * Remember that callbacks provided to `subscribe` are not guaranteed to be called asynchronously.
         * It is an Observable itself that decides when these functions will be called. For example {@link of}
         * by default emits all its values synchronously. Always check documentation for how given Observable
         * will behave when subscribed and if its default behavior can be modified with a {@link Scheduler}.
         *
         * @example <caption>Subscribe with an Observer</caption>
         * const sumObserver = {
         *   sum: 0,
         *   next(value) {
         *     console.log('Adding: ' + value);
         *     this.sum = this.sum + value;
         *   },
         *   error() { // We actually could just remove this method,
         *   },        // since we do not really care about errors right now.
         *   complete() {
         *     console.log('Sum equals: ' + this.sum);
         *   }
         * };
         *
         * Rx.Observable.of(1, 2, 3) // Synchronously emits 1, 2, 3 and then completes.
         * .subscribe(sumObserver);
         *
         * // Logs:
         * // "Adding: 1"
         * // "Adding: 2"
         * // "Adding: 3"
         * // "Sum equals: 6"
         *
         *
         * @example <caption>Subscribe with functions</caption>
         * let sum = 0;
         *
         * Rx.Observable.of(1, 2, 3)
         * .subscribe(
         *   function(value) {
         *     console.log('Adding: ' + value);
         *     sum = sum + value;
         *   },
         *   undefined,
         *   function() {
         *     console.log('Sum equals: ' + sum);
         *   }
         * );
         *
         * // Logs:
         * // "Adding: 1"
         * // "Adding: 2"
         * // "Adding: 3"
         * // "Sum equals: 6"
         *
         *
         * @example <caption>Cancel a subscription</caption>
         * const subscription = Rx.Observable.interval(1000).subscribe(
         *   num => console.log(num),
         *   undefined,
         *   () => console.log('completed!') // Will not be called, even
         * );                                // when cancelling subscription
         *
         *
         * setTimeout(() => {
         *   subscription.unsubscribe();
         *   console.log('unsubscribed!');
         * }, 2500);
         *
         * // Logs:
         * // 0 after 1s
         * // 1 after 2s
         * // "unsubscribed!" after 2.5s
         *
         *
         * @param {Observer|Function} observerOrNext (optional) Either an observer with methods to be called,
         *  or the first of three possible handlers, which is the handler for each value emitted from the subscribed
         *  Observable.
         * @param {Function} error (optional) A handler for a terminal event resulting from an error. If no error handler is provided,
         *  the error will be thrown as unhandled.
         * @param {Function} complete (optional) A handler for a terminal event resulting from successful completion.
         * @return {ISubscription} a subscription reference to the registered handlers
         * @method subscribe
         */
        Observable$$1.prototype.subscribe = function (observerOrNext, error, complete) {
            var operator = this.operator;
            var sink = toSubscriber_1.toSubscriber(observerOrNext, error, complete);
            if (operator) {
                operator.call(sink, this.source);
            }
            else {
                sink.add(this.source || !sink.syncErrorThrowable ? this._subscribe(sink) : this._trySubscribe(sink));
            }
            if (sink.syncErrorThrowable) {
                sink.syncErrorThrowable = false;
                if (sink.syncErrorThrown) {
                    throw sink.syncErrorValue;
                }
            }
            return sink;
        };
        Observable$$1.prototype._trySubscribe = function (sink) {
            try {
                return this._subscribe(sink);
            }
            catch (err) {
                sink.syncErrorThrown = true;
                sink.syncErrorValue = err;
                sink.error(err);
            }
        };
        /**
         * @method forEach
         * @param {Function} next a handler for each value emitted by the observable
         * @param {PromiseConstructor} [PromiseCtor] a constructor function used to instantiate the Promise
         * @return {Promise} a promise that either resolves on observable completion or
         *  rejects with the handled error
         */
        Observable$$1.prototype.forEach = function (next, PromiseCtor) {
            var _this = this;
            if (!PromiseCtor) {
                if (root.root.Rx && root.root.Rx.config && root.root.Rx.config.Promise) {
                    PromiseCtor = root.root.Rx.config.Promise;
                }
                else if (root.root.Promise) {
                    PromiseCtor = root.root.Promise;
                }
            }
            if (!PromiseCtor) {
                throw new Error('no Promise impl found');
            }
            return new PromiseCtor(function (resolve, reject) {
                // Must be declared in a separate statement to avoid a RefernceError when
                // accessing subscription below in the closure due to Temporal Dead Zone.
                var subscription;
                subscription = _this.subscribe(function (value) {
                    if (subscription) {
                        // if there is a subscription, then we can surmise
                        // the next handling is asynchronous. Any errors thrown
                        // need to be rejected explicitly and unsubscribe must be
                        // called manually
                        try {
                            next(value);
                        }
                        catch (err) {
                            reject(err);
                            subscription.unsubscribe();
                        }
                    }
                    else {
                        // if there is NO subscription, then we're getting a nexted
                        // value synchronously during subscription. We can just call it.
                        // If it errors, Observable's `subscribe` will ensure the
                        // unsubscription logic is called, then synchronously rethrow the error.
                        // After that, Promise will trap the error and send it
                        // down the rejection path.
                        next(value);
                    }
                }, reject, resolve);
            });
        };
        /** @deprecated internal use only */ Observable$$1.prototype._subscribe = function (subscriber) {
            return this.source.subscribe(subscriber);
        };
        /**
         * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable
         * @method Symbol.observable
         * @return {Observable} this instance of the observable
         */
        Observable$$1.prototype[observable.observable] = function () {
            return this;
        };
        /* tslint:enable:max-line-length */
        /**
         * Used to stitch together functional operators into a chain.
         * @method pipe
         * @return {Observable} the Observable result of all of the operators having
         * been called in the order they were passed in.
         *
         * @example
         *
         * import { map, filter, scan } from 'rxjs/operators';
         *
         * Rx.Observable.interval(1000)
         *   .pipe(
         *     filter(x => x % 2 === 0),
         *     map(x => x + x),
         *     scan((acc, x) => acc + x)
         *   )
         *   .subscribe(x => console.log(x))
         */
        Observable$$1.prototype.pipe = function () {
            var operations = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                operations[_i - 0] = arguments[_i];
            }
            if (operations.length === 0) {
                return this;
            }
            return pipe_1.pipeFromArray(operations)(this);
        };
        /* tslint:enable:max-line-length */
        Observable$$1.prototype.toPromise = function (PromiseCtor) {
            var _this = this;
            if (!PromiseCtor) {
                if (root.root.Rx && root.root.Rx.config && root.root.Rx.config.Promise) {
                    PromiseCtor = root.root.Rx.config.Promise;
                }
                else if (root.root.Promise) {
                    PromiseCtor = root.root.Promise;
                }
            }
            if (!PromiseCtor) {
                throw new Error('no Promise impl found');
            }
            return new PromiseCtor(function (resolve, reject) {
                var value;
                _this.subscribe(function (x) { return value = x; }, function (err) { return reject(err); }, function () { return resolve(value); });
            });
        };
        // HACK: Since TypeScript inherits static properties too, we have to
        // fight against TypeScript here so Subject can have a different static create signature
        /**
         * Creates a new cold Observable by calling the Observable constructor
         * @static true
         * @owner Observable
         * @method create
         * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor
         * @return {Observable} a new cold observable
         */
        Observable$$1.create = function (subscribe) {
            return new Observable$$1(subscribe);
        };
        return Observable$$1;
    }());
    var Observable_2 = Observable$1;


    var Observable_1 = {
    	Observable: Observable_2
    };

    var __extends$l = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    /**
     * An error thrown when an action is invalid because the object has been
     * unsubscribed.
     *
     * @see {@link Subject}
     * @see {@link BehaviorSubject}
     *
     * @class ObjectUnsubscribedError
     */
    var ObjectUnsubscribedError = (function (_super) {
        __extends$l(ObjectUnsubscribedError, _super);
        function ObjectUnsubscribedError() {
            var err = _super.call(this, 'object unsubscribed');
            this.name = err.name = 'ObjectUnsubscribedError';
            this.stack = err.stack;
            this.message = err.message;
        }
        return ObjectUnsubscribedError;
    }(Error));
    var ObjectUnsubscribedError_2 = ObjectUnsubscribedError;


    var ObjectUnsubscribedError_1 = {
    	ObjectUnsubscribedError: ObjectUnsubscribedError_2
    };

    var __extends$m = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };

    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var SubjectSubscription = (function (_super) {
        __extends$m(SubjectSubscription, _super);
        function SubjectSubscription(subject, subscriber) {
            _super.call(this);
            this.subject = subject;
            this.subscriber = subscriber;
            this.closed = false;
        }
        SubjectSubscription.prototype.unsubscribe = function () {
            if (this.closed) {
                return;
            }
            this.closed = true;
            var subject = this.subject;
            var observers = subject.observers;
            this.subject = null;
            if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {
                return;
            }
            var subscriberIndex = observers.indexOf(this.subscriber);
            if (subscriberIndex !== -1) {
                observers.splice(subscriberIndex, 1);
            }
        };
        return SubjectSubscription;
    }(Subscription_1.Subscription));
    var SubjectSubscription_2 = SubjectSubscription;


    var SubjectSubscription_1 = {
    	SubjectSubscription: SubjectSubscription_2
    };

    var __extends$n = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };






    /**
     * @class SubjectSubscriber<T>
     */
    var SubjectSubscriber = (function (_super) {
        __extends$n(SubjectSubscriber, _super);
        function SubjectSubscriber(destination) {
            _super.call(this, destination);
            this.destination = destination;
        }
        return SubjectSubscriber;
    }(Subscriber_1.Subscriber));
    var SubjectSubscriber_1 = SubjectSubscriber;
    /**
     * @class Subject<T>
     */
    var Subject = (function (_super) {
        __extends$n(Subject, _super);
        function Subject() {
            _super.call(this);
            this.observers = [];
            this.closed = false;
            this.isStopped = false;
            this.hasError = false;
            this.thrownError = null;
        }
        Subject.prototype[rxSubscriber.rxSubscriber] = function () {
            return new SubjectSubscriber(this);
        };
        Subject.prototype.lift = function (operator) {
            var subject = new AnonymousSubject(this, this);
            subject.operator = operator;
            return subject;
        };
        Subject.prototype.next = function (value) {
            if (this.closed) {
                throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
            }
            if (!this.isStopped) {
                var observers = this.observers;
                var len = observers.length;
                var copy = observers.slice();
                for (var i = 0; i < len; i++) {
                    copy[i].next(value);
                }
            }
        };
        Subject.prototype.error = function (err) {
            if (this.closed) {
                throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
            }
            this.hasError = true;
            this.thrownError = err;
            this.isStopped = true;
            var observers = this.observers;
            var len = observers.length;
            var copy = observers.slice();
            for (var i = 0; i < len; i++) {
                copy[i].error(err);
            }
            this.observers.length = 0;
        };
        Subject.prototype.complete = function () {
            if (this.closed) {
                throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
            }
            this.isStopped = true;
            var observers = this.observers;
            var len = observers.length;
            var copy = observers.slice();
            for (var i = 0; i < len; i++) {
                copy[i].complete();
            }
            this.observers.length = 0;
        };
        Subject.prototype.unsubscribe = function () {
            this.isStopped = true;
            this.closed = true;
            this.observers = null;
        };
        Subject.prototype._trySubscribe = function (subscriber) {
            if (this.closed) {
                throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
            }
            else {
                return _super.prototype._trySubscribe.call(this, subscriber);
            }
        };
        /** @deprecated internal use only */ Subject.prototype._subscribe = function (subscriber) {
            if (this.closed) {
                throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
            }
            else if (this.hasError) {
                subscriber.error(this.thrownError);
                return Subscription_1.Subscription.EMPTY;
            }
            else if (this.isStopped) {
                subscriber.complete();
                return Subscription_1.Subscription.EMPTY;
            }
            else {
                this.observers.push(subscriber);
                return new SubjectSubscription_1.SubjectSubscription(this, subscriber);
            }
        };
        Subject.prototype.asObservable = function () {
            var observable = new Observable_1.Observable();
            observable.source = this;
            return observable;
        };
        Subject.create = function (destination, source) {
            return new AnonymousSubject(destination, source);
        };
        return Subject;
    }(Observable_1.Observable));
    var Subject_2 = Subject;
    /**
     * @class AnonymousSubject<T>
     */
    var AnonymousSubject = (function (_super) {
        __extends$n(AnonymousSubject, _super);
        function AnonymousSubject(destination, source) {
            _super.call(this);
            this.destination = destination;
            this.source = source;
        }
        AnonymousSubject.prototype.next = function (value) {
            var destination = this.destination;
            if (destination && destination.next) {
                destination.next(value);
            }
        };
        AnonymousSubject.prototype.error = function (err) {
            var destination = this.destination;
            if (destination && destination.error) {
                this.destination.error(err);
            }
        };
        AnonymousSubject.prototype.complete = function () {
            var destination = this.destination;
            if (destination && destination.complete) {
                this.destination.complete();
            }
        };
        /** @deprecated internal use only */ AnonymousSubject.prototype._subscribe = function (subscriber) {
            var source = this.source;
            if (source) {
                return this.source.subscribe(subscriber);
            }
            else {
                return Subscription_1.Subscription.EMPTY;
            }
        };
        return AnonymousSubject;
    }(Subject));
    var AnonymousSubject_1 = AnonymousSubject;


    var Subject_1 = {
    	SubjectSubscriber: SubjectSubscriber_1,
    	Subject: Subject_2,
    	AnonymousSubject: AnonymousSubject_1
    };

    var __extends$o = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };


    /**
     * @class AsyncSubject<T>
     */
    var AsyncSubject = (function (_super) {
        __extends$o(AsyncSubject, _super);
        function AsyncSubject() {
            _super.apply(this, arguments);
            this.value = null;
            this.hasNext = false;
            this.hasCompleted = false;
        }
        /** @deprecated internal use only */ AsyncSubject.prototype._subscribe = function (subscriber) {
            if (this.hasError) {
                subscriber.error(this.thrownError);
                return Subscription_1.Subscription.EMPTY;
            }
            else if (this.hasCompleted && this.hasNext) {
                subscriber.next(this.value);
                subscriber.complete();
                return Subscription_1.Subscription.EMPTY;
            }
            return _super.prototype._subscribe.call(this, subscriber);
        };
        AsyncSubject.prototype.next = function (value) {
            if (!this.hasCompleted) {
                this.value = value;
                this.hasNext = true;
            }
        };
        AsyncSubject.prototype.error = function (error) {
            if (!this.hasCompleted) {
                _super.prototype.error.call(this, error);
            }
        };
        AsyncSubject.prototype.complete = function () {
            this.hasCompleted = true;
            if (this.hasNext) {
                _super.prototype.next.call(this, this.value);
            }
            _super.prototype.complete.call(this);
        };
        return AsyncSubject;
    }(Subject_1.Subject));
    var AsyncSubject_2 = AsyncSubject;


    var AsyncSubject_1 = {
    	AsyncSubject: AsyncSubject_2
    };

    var __extends$p = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };




    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @extends {Ignored}
     * @hide true
     */
    var BoundCallbackObservable = (function (_super) {
        __extends$p(BoundCallbackObservable, _super);
        function BoundCallbackObservable(callbackFunc, selector, args, context, scheduler) {
            _super.call(this);
            this.callbackFunc = callbackFunc;
            this.selector = selector;
            this.args = args;
            this.context = context;
            this.scheduler = scheduler;
        }
        /* tslint:enable:max-line-length */
        /**
         * Converts a callback API to a function that returns an Observable.
         *
         * <span class="informal">Give it a function `f` of type `f(x, callback)` and
         * it will return a function `g` that when called as `g(x)` will output an
         * Observable.</span>
         *
         * `bindCallback` is not an operator because its input and output are not
         * Observables. The input is a function `func` with some parameters, the
         * last parameter must be a callback function that `func` calls when it is
         * done.
         *
         * The output of `bindCallback` is a function that takes the same parameters
         * as `func`, except the last one (the callback). When the output function
         * is called with arguments it will return an Observable. If function `func`
         * calls its callback with one argument the Observable will emit that value.
         * If on the other hand the callback is called with multiple values the resulting
         * Observable will emit an array with said values as arguments.
         *
         * It is very important to remember that input function `func` is not called
         * when the output function is, but rather when the Observable returned by the output
         * function is subscribed. This means if `func` makes an AJAX request, that request
         * will be made every time someone subscribes to the resulting Observable, but not before.
         *
         * Optionally, a selector function can be passed to `bindObservable`. The selector function
         * takes the same arguments as the callback and returns the value that will be emitted by the Observable.
         * Even though by default multiple arguments passed to callback appear in the stream as an array
         * the selector function will be called with arguments directly, just as the callback would.
         * This means you can imagine the default selector (when one is not provided explicitly)
         * as a function that aggregates all its arguments into an array, or simply returns first argument
         * if there is only one.
         *
         * The last optional parameter - {@link Scheduler} - can be used to control when the call
         * to `func` happens after someone subscribes to Observable, as well as when results
         * passed to callback will be emitted. By default, the subscription to  an Observable calls `func`
         * synchronously, but using `Scheduler.async` as the last parameter will defer the call to `func`,
         * just like wrapping the call in `setTimeout` with a timeout of `0` would. If you use the async Scheduler
         * and call `subscribe` on the output Observable all function calls that are currently executing
         * will end before `func` is invoked.
         *
         * By default results passed to the callback are emitted immediately after `func` invokes the callback.
         * In particular, if the callback is called synchronously the subscription of the resulting Observable
         * will call the `next` function synchronously as well.  If you want to defer that call,
         * you may use `Scheduler.async` just as before.  This means that by using `Scheduler.async` you can
         * ensure that `func` always calls its callback asynchronously, thus avoiding terrifying Zalgo.
         *
         * Note that the Observable created by the output function will always emit a single value
         * and then complete immediately. If `func` calls the callback multiple times, values from subsequent
         * calls will not appear in the stream. If you need to listen for multiple calls,
         *  you probably want to use {@link fromEvent} or {@link fromEventPattern} instead.
         *
         * If `func` depends on some context (`this` property) and is not already bound the context of `func`
         * will be the context that the output function has at call time. In particular, if `func`
         * is called as a method of some objec and if `func` is not already bound, in order to preserve the context
         * it is recommended that the context of the output function is set to that object as well.
         *
         * If the input function calls its callback in the "node style" (i.e. first argument to callback is
         * optional error parameter signaling whether the call failed or not), {@link bindNodeCallback}
         * provides convenient error handling and probably is a better choice.
         * `bindCallback` will treat such functions the same as any other and error parameters
         * (whether passed or not) will always be interpreted as regular callback argument.
         *
         *
         * @example <caption>Convert jQuery's getJSON to an Observable API</caption>
         * // Suppose we have jQuery.getJSON('/my/url', callback)
         * var getJSONAsObservable = Rx.Observable.bindCallback(jQuery.getJSON);
         * var result = getJSONAsObservable('/my/url');
         * result.subscribe(x => console.log(x), e => console.error(e));
         *
         *
         * @example <caption>Receive an array of arguments passed to a callback</caption>
         * someFunction((a, b, c) => {
         *   console.log(a); // 5
         *   console.log(b); // 'some string'
         *   console.log(c); // {someProperty: 'someValue'}
         * });
         *
         * const boundSomeFunction = Rx.Observable.bindCallback(someFunction);
         * boundSomeFunction().subscribe(values => {
         *   console.log(values) // [5, 'some string', {someProperty: 'someValue'}]
         * });
         *
         *
         * @example <caption>Use bindCallback with a selector function</caption>
         * someFunction((a, b, c) => {
         *   console.log(a); // 'a'
         *   console.log(b); // 'b'
         *   console.log(c); // 'c'
         * });
         *
         * const boundSomeFunction = Rx.Observable.bindCallback(someFunction, (a, b, c) => a + b + c);
         * boundSomeFunction().subscribe(value => {
         *   console.log(value) // 'abc'
         * });
         *
         *
         * @example <caption>Compare behaviour with and without async Scheduler</caption>
         * function iCallMyCallbackSynchronously(cb) {
         *   cb();
         * }
         *
         * const boundSyncFn = Rx.Observable.bindCallback(iCallMyCallbackSynchronously);
         * const boundAsyncFn = Rx.Observable.bindCallback(iCallMyCallbackSynchronously, null, Rx.Scheduler.async);
         *
         * boundSyncFn().subscribe(() => console.log('I was sync!'));
         * boundAsyncFn().subscribe(() => console.log('I was async!'));
         * console.log('This happened...');
         *
         * // Logs:
         * // I was sync!
         * // This happened...
         * // I was async!
         *
         *
         * @example <caption>Use bindCallback on an object method</caption>
         * const boundMethod = Rx.Observable.bindCallback(someObject.methodWithCallback);
         * boundMethod.call(someObject) // make sure methodWithCallback has access to someObject
         * .subscribe(subscriber);
         *
         *
         * @see {@link bindNodeCallback}
         * @see {@link from}
         * @see {@link fromPromise}
         *
         * @param {function} func A function with a callback as the last parameter.
         * @param {function} [selector] A function which takes the arguments from the
         * callback and maps them to a value that is emitted on the output Observable.
         * @param {Scheduler} [scheduler] The scheduler on which to schedule the
         * callbacks.
         * @return {function(...params: *): Observable} A function which returns the
         * Observable that delivers the same values the callback would deliver.
         * @static true
         * @name bindCallback
         * @owner Observable
         */
        BoundCallbackObservable.create = function (func, selector, scheduler) {
            if (selector === void 0) { selector = undefined; }
            return function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i - 0] = arguments[_i];
                }
                return new BoundCallbackObservable(func, selector, args, this, scheduler);
            };
        };
        /** @deprecated internal use only */ BoundCallbackObservable.prototype._subscribe = function (subscriber) {
            var callbackFunc = this.callbackFunc;
            var args = this.args;
            var scheduler = this.scheduler;
            var subject = this.subject;
            if (!scheduler) {
                if (!subject) {
                    subject = this.subject = new AsyncSubject_1.AsyncSubject();
                    var handler = function handlerFn() {
                        var innerArgs = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            innerArgs[_i - 0] = arguments[_i];
                        }
                        var source = handlerFn.source;
                        var selector = source.selector, subject = source.subject;
                        if (selector) {
                            var result_1 = tryCatch_1.tryCatch(selector).apply(this, innerArgs);
                            if (result_1 === errorObject.errorObject) {
                                subject.error(errorObject.errorObject.e);
                            }
                            else {
                                subject.next(result_1);
                                subject.complete();
                            }
                        }
                        else {
                            subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);
                            subject.complete();
                        }
                    };
                    // use named function instance to avoid closure.
                    handler.source = this;
                    var result = tryCatch_1.tryCatch(callbackFunc).apply(this.context, args.concat(handler));
                    if (result === errorObject.errorObject) {
                        subject.error(errorObject.errorObject.e);
                    }
                }
                return subject.subscribe(subscriber);
            }
            else {
                return scheduler.schedule(BoundCallbackObservable.dispatch, 0, { source: this, subscriber: subscriber, context: this.context });
            }
        };
        BoundCallbackObservable.dispatch = function (state) {
            var self = this;
            var source = state.source, subscriber = state.subscriber, context = state.context;
            var callbackFunc = source.callbackFunc, args = source.args, scheduler = source.scheduler;
            var subject = source.subject;
            if (!subject) {
                subject = source.subject = new AsyncSubject_1.AsyncSubject();
                var handler = function handlerFn() {
                    var innerArgs = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        innerArgs[_i - 0] = arguments[_i];
                    }
                    var source = handlerFn.source;
                    var selector = source.selector, subject = source.subject;
                    if (selector) {
                        var result_2 = tryCatch_1.tryCatch(selector).apply(this, innerArgs);
                        if (result_2 === errorObject.errorObject) {
                            self.add(scheduler.schedule(dispatchError, 0, { err: errorObject.errorObject.e, subject: subject }));
                        }
                        else {
                            self.add(scheduler.schedule(dispatchNext, 0, { value: result_2, subject: subject }));
                        }
                    }
                    else {
                        var value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;
                        self.add(scheduler.schedule(dispatchNext, 0, { value: value, subject: subject }));
                    }
                };
                // use named function to pass values in without closure
                handler.source = source;
                var result = tryCatch_1.tryCatch(callbackFunc).apply(context, args.concat(handler));
                if (result === errorObject.errorObject) {
                    subject.error(errorObject.errorObject.e);
                }
            }
            self.add(subject.subscribe(subscriber));
        };
        return BoundCallbackObservable;
    }(Observable_1.Observable));
    var BoundCallbackObservable_2 = BoundCallbackObservable;
    function dispatchNext(arg) {
        var value = arg.value, subject = arg.subject;
        subject.next(value);
        subject.complete();
    }
    function dispatchError(arg) {
        var err = arg.err, subject = arg.subject;
        subject.error(err);
    }


    var BoundCallbackObservable_1 = {
    	BoundCallbackObservable: BoundCallbackObservable_2
    };

    var bindCallback_1 = BoundCallbackObservable_1.BoundCallbackObservable.create;


    var bindCallback = {
    	bindCallback: bindCallback_1
    };

    Observable_1.Observable.bindCallback = bindCallback.bindCallback;

    var __extends$q = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };




    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @extends {Ignored}
     * @hide true
     */
    var BoundNodeCallbackObservable = (function (_super) {
        __extends$q(BoundNodeCallbackObservable, _super);
        function BoundNodeCallbackObservable(callbackFunc, selector, args, context, scheduler) {
            _super.call(this);
            this.callbackFunc = callbackFunc;
            this.selector = selector;
            this.args = args;
            this.context = context;
            this.scheduler = scheduler;
        }
        /* tslint:enable:max-line-length */
        /**
         * Converts a Node.js-style callback API to a function that returns an
         * Observable.
         *
         * <span class="informal">It's just like {@link bindCallback}, but the
         * callback is expected to be of type `callback(error, result)`.</span>
         *
         * `bindNodeCallback` is not an operator because its input and output are not
         * Observables. The input is a function `func` with some parameters, but the
         * last parameter must be a callback function that `func` calls when it is
         * done. The callback function is expected to follow Node.js conventions,
         * where the first argument to the callback is an error object, signaling
         * whether call was successful. If that object is passed to callback, it means
         * something went wrong.
         *
         * The output of `bindNodeCallback` is a function that takes the same
         * parameters as `func`, except the last one (the callback). When the output
         * function is called with arguments, it will return an Observable.
         * If `func` calls its callback with error parameter present, Observable will
         * error with that value as well. If error parameter is not passed, Observable will emit
         * second parameter. If there are more parameters (third and so on),
         * Observable will emit an array with all arguments, except first error argument.
         *
         * Optionally `bindNodeCallback` accepts selector function, which allows you to
         * make resulting Observable emit value computed by selector, instead of regular
         * callback arguments. It works similarly to {@link bindCallback} selector, but
         * Node.js-style error argument will never be passed to that function.
         *
         * Note that `func` will not be called at the same time output function is,
         * but rather whenever resulting Observable is subscribed. By default call to
         * `func` will happen synchronously after subscription, but that can be changed
         * with proper {@link Scheduler} provided as optional third parameter. Scheduler
         * can also control when values from callback will be emitted by Observable.
         * To find out more, check out documentation for {@link bindCallback}, where
         * Scheduler works exactly the same.
         *
         * As in {@link bindCallback}, context (`this` property) of input function will be set to context
         * of returned function, when it is called.
         *
         * After Observable emits value, it will complete immediately. This means
         * even if `func` calls callback again, values from second and consecutive
         * calls will never appear on the stream. If you need to handle functions
         * that call callbacks multiple times, check out {@link fromEvent} or
         * {@link fromEventPattern} instead.
         *
         * Note that `bindNodeCallback` can be used in non-Node.js environments as well.
         * "Node.js-style" callbacks are just a convention, so if you write for
         * browsers or any other environment and API you use implements that callback style,
         * `bindNodeCallback` can be safely used on that API functions as well.
         *
         * Remember that Error object passed to callback does not have to be an instance
         * of JavaScript built-in `Error` object. In fact, it does not even have to an object.
         * Error parameter of callback function is interpreted as "present", when value
         * of that parameter is truthy. It could be, for example, non-zero number, non-empty
         * string or boolean `true`. In all of these cases resulting Observable would error
         * with that value. This means usually regular style callbacks will fail very often when
         * `bindNodeCallback` is used. If your Observable errors much more often then you
         * would expect, check if callback really is called in Node.js-style and, if not,
         * switch to {@link bindCallback} instead.
         *
         * Note that even if error parameter is technically present in callback, but its value
         * is falsy, it still won't appear in array emitted by Observable or in selector function.
         *
         *
         * @example <caption>Read a file from the filesystem and get the data as an Observable</caption>
         * import * as fs from 'fs';
         * var readFileAsObservable = Rx.Observable.bindNodeCallback(fs.readFile);
         * var result = readFileAsObservable('./roadNames.txt', 'utf8');
         * result.subscribe(x => console.log(x), e => console.error(e));
         *
         *
         * @example <caption>Use on function calling callback with multiple arguments</caption>
         * someFunction((err, a, b) => {
         *   console.log(err); // null
         *   console.log(a); // 5
         *   console.log(b); // "some string"
         * });
         * var boundSomeFunction = Rx.Observable.bindNodeCallback(someFunction);
         * boundSomeFunction()
         * .subscribe(value => {
         *   console.log(value); // [5, "some string"]
         * });
         *
         *
         * @example <caption>Use with selector function</caption>
         * someFunction((err, a, b) => {
         *   console.log(err); // undefined
         *   console.log(a); // "abc"
         *   console.log(b); // "DEF"
         * });
         * var boundSomeFunction = Rx.Observable.bindNodeCallback(someFunction, (a, b) => a + b);
         * boundSomeFunction()
         * .subscribe(value => {
         *   console.log(value); // "abcDEF"
         * });
         *
         *
         * @example <caption>Use on function calling callback in regular style</caption>
         * someFunction(a => {
         *   console.log(a); // 5
         * });
         * var boundSomeFunction = Rx.Observable.bindNodeCallback(someFunction);
         * boundSomeFunction()
         * .subscribe(
         *   value => {}             // never gets called
         *   err => console.log(err) // 5
         *);
         *
         *
         * @see {@link bindCallback}
         * @see {@link from}
         * @see {@link fromPromise}
         *
         * @param {function} func Function with a Node.js-style callback as the last parameter.
         * @param {function} [selector] A function which takes the arguments from the
         * callback and maps those to a value to emit on the output Observable.
         * @param {Scheduler} [scheduler] The scheduler on which to schedule the
         * callbacks.
         * @return {function(...params: *): Observable} A function which returns the
         * Observable that delivers the same values the Node.js callback would
         * deliver.
         * @static true
         * @name bindNodeCallback
         * @owner Observable
         */
        BoundNodeCallbackObservable.create = function (func, selector, scheduler) {
            if (selector === void 0) { selector = undefined; }
            return function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i - 0] = arguments[_i];
                }
                return new BoundNodeCallbackObservable(func, selector, args, this, scheduler);
            };
        };
        /** @deprecated internal use only */ BoundNodeCallbackObservable.prototype._subscribe = function (subscriber) {
            var callbackFunc = this.callbackFunc;
            var args = this.args;
            var scheduler = this.scheduler;
            var subject = this.subject;
            if (!scheduler) {
                if (!subject) {
                    subject = this.subject = new AsyncSubject_1.AsyncSubject();
                    var handler = function handlerFn() {
                        var innerArgs = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            innerArgs[_i - 0] = arguments[_i];
                        }
                        var source = handlerFn.source;
                        var selector = source.selector, subject = source.subject;
                        var err = innerArgs.shift();
                        if (err) {
                            subject.error(err);
                        }
                        else if (selector) {
                            var result_1 = tryCatch_1.tryCatch(selector).apply(this, innerArgs);
                            if (result_1 === errorObject.errorObject) {
                                subject.error(errorObject.errorObject.e);
                            }
                            else {
                                subject.next(result_1);
                                subject.complete();
                            }
                        }
                        else {
                            subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);
                            subject.complete();
                        }
                    };
                    // use named function instance to avoid closure.
                    handler.source = this;
                    var result = tryCatch_1.tryCatch(callbackFunc).apply(this.context, args.concat(handler));
                    if (result === errorObject.errorObject) {
                        subject.error(errorObject.errorObject.e);
                    }
                }
                return subject.subscribe(subscriber);
            }
            else {
                return scheduler.schedule(dispatch, 0, { source: this, subscriber: subscriber, context: this.context });
            }
        };
        return BoundNodeCallbackObservable;
    }(Observable_1.Observable));
    var BoundNodeCallbackObservable_2 = BoundNodeCallbackObservable;
    function dispatch(state) {
        var self = this;
        var source = state.source, subscriber = state.subscriber, context = state.context;
        // XXX: cast to `any` to access to the private field in `source`.
        var _a = source, callbackFunc = _a.callbackFunc, args = _a.args, scheduler = _a.scheduler;
        var subject = source.subject;
        if (!subject) {
            subject = source.subject = new AsyncSubject_1.AsyncSubject();
            var handler = function handlerFn() {
                var innerArgs = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    innerArgs[_i - 0] = arguments[_i];
                }
                var source = handlerFn.source;
                var selector = source.selector, subject = source.subject;
                var err = innerArgs.shift();
                if (err) {
                    self.add(scheduler.schedule(dispatchError$1, 0, { err: err, subject: subject }));
                }
                else if (selector) {
                    var result_2 = tryCatch_1.tryCatch(selector).apply(this, innerArgs);
                    if (result_2 === errorObject.errorObject) {
                        self.add(scheduler.schedule(dispatchError$1, 0, { err: errorObject.errorObject.e, subject: subject }));
                    }
                    else {
                        self.add(scheduler.schedule(dispatchNext$1, 0, { value: result_2, subject: subject }));
                    }
                }
                else {
                    var value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;
                    self.add(scheduler.schedule(dispatchNext$1, 0, { value: value, subject: subject }));
                }
            };
            // use named function to pass values in without closure
            handler.source = source;
            var result = tryCatch_1.tryCatch(callbackFunc).apply(context, args.concat(handler));
            if (result === errorObject.errorObject) {
                self.add(scheduler.schedule(dispatchError$1, 0, { err: errorObject.errorObject.e, subject: subject }));
            }
        }
        self.add(subject.subscribe(subscriber));
    }
    function dispatchNext$1(arg) {
        var value = arg.value, subject = arg.subject;
        subject.next(value);
        subject.complete();
    }
    function dispatchError$1(arg) {
        var err = arg.err, subject = arg.subject;
        subject.error(err);
    }


    var BoundNodeCallbackObservable_1 = {
    	BoundNodeCallbackObservable: BoundNodeCallbackObservable_2
    };

    var bindNodeCallback_1 = BoundNodeCallbackObservable_1.BoundNodeCallbackObservable.create;


    var bindNodeCallback = {
    	bindNodeCallback: bindNodeCallback_1
    };

    Observable_1.Observable.bindNodeCallback = bindNodeCallback.bindNodeCallback;

    function isScheduler(value) {
        return value && typeof value.schedule === 'function';
    }
    var isScheduler_2 = isScheduler;


    var isScheduler_1 = {
    	isScheduler: isScheduler_2
    };

    var __extends$r = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };

    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @extends {Ignored}
     * @hide true
     */
    var ScalarObservable = (function (_super) {
        __extends$r(ScalarObservable, _super);
        function ScalarObservable(value, scheduler) {
            _super.call(this);
            this.value = value;
            this.scheduler = scheduler;
            this._isScalar = true;
            if (scheduler) {
                this._isScalar = false;
            }
        }
        ScalarObservable.create = function (value, scheduler) {
            return new ScalarObservable(value, scheduler);
        };
        ScalarObservable.dispatch = function (state) {
            var done = state.done, value = state.value, subscriber = state.subscriber;
            if (done) {
                subscriber.complete();
                return;
            }
            subscriber.next(value);
            if (subscriber.closed) {
                return;
            }
            state.done = true;
            this.schedule(state);
        };
        /** @deprecated internal use only */ ScalarObservable.prototype._subscribe = function (subscriber) {
            var value = this.value;
            var scheduler = this.scheduler;
            if (scheduler) {
                return scheduler.schedule(ScalarObservable.dispatch, 0, {
                    done: false, value: value, subscriber: subscriber
                });
            }
            else {
                subscriber.next(value);
                if (!subscriber.closed) {
                    subscriber.complete();
                }
            }
        };
        return ScalarObservable;
    }(Observable_1.Observable));
    var ScalarObservable_2 = ScalarObservable;


    var ScalarObservable_1 = {
    	ScalarObservable: ScalarObservable_2
    };

    var __extends$s = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };

    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @extends {Ignored}
     * @hide true
     */
    var EmptyObservable = (function (_super) {
        __extends$s(EmptyObservable, _super);
        function EmptyObservable(scheduler) {
            _super.call(this);
            this.scheduler = scheduler;
        }
        /**
         * Creates an Observable that emits no items to the Observer and immediately
         * emits a complete notification.
         *
         * <span class="informal">Just emits 'complete', and nothing else.
         * </span>
         *
         * <img src="./img/empty.png" width="100%">
         *
         * This static operator is useful for creating a simple Observable that only
         * emits the complete notification. It can be used for composing with other
         * Observables, such as in a {@link mergeMap}.
         *
         * @example <caption>Emit the number 7, then complete.</caption>
         * var result = Rx.Observable.empty().startWith(7);
         * result.subscribe(x => console.log(x));
         *
         * @example <caption>Map and flatten only odd numbers to the sequence 'a', 'b', 'c'</caption>
         * var interval = Rx.Observable.interval(1000);
         * var result = interval.mergeMap(x =>
         *   x % 2 === 1 ? Rx.Observable.of('a', 'b', 'c') : Rx.Observable.empty()
         * );
         * result.subscribe(x => console.log(x));
         *
         * // Results in the following to the console:
         * // x is equal to the count on the interval eg(0,1,2,3,...)
         * // x will occur every 1000ms
         * // if x % 2 is equal to 1 print abc
         * // if x % 2 is not equal to 1 nothing will be output
         *
         * @see {@link create}
         * @see {@link never}
         * @see {@link of}
         * @see {@link throw}
         *
         * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling
         * the emission of the complete notification.
         * @return {Observable} An "empty" Observable: emits only the complete
         * notification.
         * @static true
         * @name empty
         * @owner Observable
         */
        EmptyObservable.create = function (scheduler) {
            return new EmptyObservable(scheduler);
        };
        EmptyObservable.dispatch = function (arg) {
            var subscriber = arg.subscriber;
            subscriber.complete();
        };
        /** @deprecated internal use only */ EmptyObservable.prototype._subscribe = function (subscriber) {
            var scheduler = this.scheduler;
            if (scheduler) {
                return scheduler.schedule(EmptyObservable.dispatch, 0, { subscriber: subscriber });
            }
            else {
                subscriber.complete();
            }
        };
        return EmptyObservable;
    }(Observable_1.Observable));
    var EmptyObservable_2 = EmptyObservable;


    var EmptyObservable_1 = {
    	EmptyObservable: EmptyObservable_2
    };

    var __extends$t = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };




    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @extends {Ignored}
     * @hide true
     */
    var ArrayObservable = (function (_super) {
        __extends$t(ArrayObservable, _super);
        function ArrayObservable(array, scheduler) {
            _super.call(this);
            this.array = array;
            this.scheduler = scheduler;
            if (!scheduler && array.length === 1) {
                this._isScalar = true;
                this.value = array[0];
            }
        }
        ArrayObservable.create = function (array, scheduler) {
            return new ArrayObservable(array, scheduler);
        };
        /**
         * Creates an Observable that emits some values you specify as arguments,
         * immediately one after the other, and then emits a complete notification.
         *
         * <span class="informal">Emits the arguments you provide, then completes.
         * </span>
         *
         * <img src="./img/of.png" width="100%">
         *
         * This static operator is useful for creating a simple Observable that only
         * emits the arguments given, and the complete notification thereafter. It can
         * be used for composing with other Observables, such as with {@link concat}.
         * By default, it uses a `null` IScheduler, which means the `next`
         * notifications are sent synchronously, although with a different IScheduler
         * it is possible to determine when those notifications will be delivered.
         *
         * @example <caption>Emit 10, 20, 30, then 'a', 'b', 'c', then start ticking every second.</caption>
         * var numbers = Rx.Observable.of(10, 20, 30);
         * var letters = Rx.Observable.of('a', 'b', 'c');
         * var interval = Rx.Observable.interval(1000);
         * var result = numbers.concat(letters).concat(interval);
         * result.subscribe(x => console.log(x));
         *
         * @see {@link create}
         * @see {@link empty}
         * @see {@link never}
         * @see {@link throw}
         *
         * @param {...T} values Arguments that represent `next` values to be emitted.
         * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling
         * the emissions of the `next` notifications.
         * @return {Observable<T>} An Observable that emits each given input value.
         * @static true
         * @name of
         * @owner Observable
         */
        ArrayObservable.of = function () {
            var array = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                array[_i - 0] = arguments[_i];
            }
            var scheduler = array[array.length - 1];
            if (isScheduler_1.isScheduler(scheduler)) {
                array.pop();
            }
            else {
                scheduler = null;
            }
            var len = array.length;
            if (len > 1) {
                return new ArrayObservable(array, scheduler);
            }
            else if (len === 1) {
                return new ScalarObservable_1.ScalarObservable(array[0], scheduler);
            }
            else {
                return new EmptyObservable_1.EmptyObservable(scheduler);
            }
        };
        ArrayObservable.dispatch = function (state) {
            var array = state.array, index = state.index, count = state.count, subscriber = state.subscriber;
            if (index >= count) {
                subscriber.complete();
                return;
            }
            subscriber.next(array[index]);
            if (subscriber.closed) {
                return;
            }
            state.index = index + 1;
            this.schedule(state);
        };
        /** @deprecated internal use only */ ArrayObservable.prototype._subscribe = function (subscriber) {
            var index = 0;
            var array = this.array;
            var count = array.length;
            var scheduler = this.scheduler;
            if (scheduler) {
                return scheduler.schedule(ArrayObservable.dispatch, 0, {
                    array: array, index: index, count: count, subscriber: subscriber
                });
            }
            else {
                for (var i = 0; i < count && !subscriber.closed; i++) {
                    subscriber.next(array[i]);
                }
                subscriber.complete();
            }
        };
        return ArrayObservable;
    }(Observable_1.Observable));
    var ArrayObservable_2 = ArrayObservable;


    var ArrayObservable_1 = {
    	ArrayObservable: ArrayObservable_2
    };

    var __extends$u = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };

    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var OuterSubscriber = (function (_super) {
        __extends$u(OuterSubscriber, _super);
        function OuterSubscriber() {
            _super.apply(this, arguments);
        }
        OuterSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
            this.destination.next(innerValue);
        };
        OuterSubscriber.prototype.notifyError = function (error, innerSub) {
            this.destination.error(error);
        };
        OuterSubscriber.prototype.notifyComplete = function (innerSub) {
            this.destination.complete();
        };
        return OuterSubscriber;
    }(Subscriber_1.Subscriber));
    var OuterSubscriber_2 = OuterSubscriber;


    var OuterSubscriber_1 = {
    	OuterSubscriber: OuterSubscriber_2
    };

    var isArrayLike_1 = (function (x) { return x && typeof x.length === 'number'; });


    var isArrayLike = {
    	isArrayLike: isArrayLike_1
    };

    function isPromise(value) {
        return value && typeof value.subscribe !== 'function' && typeof value.then === 'function';
    }
    var isPromise_2 = isPromise;


    var isPromise_1 = {
    	isPromise: isPromise_2
    };

    var iterator = createCommonjsModule(function (module, exports) {

    function symbolIteratorPonyfill(root$$1) {
        var Symbol = root$$1.Symbol;
        if (typeof Symbol === 'function') {
            if (!Symbol.iterator) {
                Symbol.iterator = Symbol('iterator polyfill');
            }
            return Symbol.iterator;
        }
        else {
            // [for Mozilla Gecko 27-35:](https://mzl.la/2ewE1zC)
            var Set_1 = root$$1.Set;
            if (Set_1 && typeof new Set_1()['@@iterator'] === 'function') {
                return '@@iterator';
            }
            var Map_1 = root$$1.Map;
            // required for compatability with es6-shim
            if (Map_1) {
                var keys = Object.getOwnPropertyNames(Map_1.prototype);
                for (var i = 0; i < keys.length; ++i) {
                    var key = keys[i];
                    // according to spec, Map.prototype[@@iterator] and Map.orototype.entries must be equal.
                    if (key !== 'entries' && key !== 'size' && Map_1.prototype[key] === Map_1.prototype['entries']) {
                        return key;
                    }
                }
            }
            return '@@iterator';
        }
    }
    exports.symbolIteratorPonyfill = symbolIteratorPonyfill;
    exports.iterator = symbolIteratorPonyfill(root.root);
    /**
     * @deprecated use iterator instead
     */
    exports.$$iterator = exports.iterator;

    });
    var iterator_1 = iterator.symbolIteratorPonyfill;
    var iterator_2 = iterator.iterator;
    var iterator_3 = iterator.$$iterator;

    var __extends$v = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };

    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var InnerSubscriber = (function (_super) {
        __extends$v(InnerSubscriber, _super);
        function InnerSubscriber(parent, outerValue, outerIndex) {
            _super.call(this);
            this.parent = parent;
            this.outerValue = outerValue;
            this.outerIndex = outerIndex;
            this.index = 0;
        }
        InnerSubscriber.prototype._next = function (value) {
            this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);
        };
        InnerSubscriber.prototype._error = function (error) {
            this.parent.notifyError(error, this);
            this.unsubscribe();
        };
        InnerSubscriber.prototype._complete = function () {
            this.parent.notifyComplete(this);
            this.unsubscribe();
        };
        return InnerSubscriber;
    }(Subscriber_1.Subscriber));
    var InnerSubscriber_2 = InnerSubscriber;


    var InnerSubscriber_1 = {
    	InnerSubscriber: InnerSubscriber_2
    };

    function subscribeToResult(outerSubscriber, result, outerValue, outerIndex) {
        var destination = new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex);
        if (destination.closed) {
            return null;
        }
        if (result instanceof Observable_1.Observable) {
            if (result._isScalar) {
                destination.next(result.value);
                destination.complete();
                return null;
            }
            else {
                destination.syncErrorThrowable = true;
                return result.subscribe(destination);
            }
        }
        else if (isArrayLike.isArrayLike(result)) {
            for (var i = 0, len = result.length; i < len && !destination.closed; i++) {
                destination.next(result[i]);
            }
            if (!destination.closed) {
                destination.complete();
            }
        }
        else if (isPromise_1.isPromise(result)) {
            result.then(function (value) {
                if (!destination.closed) {
                    destination.next(value);
                    destination.complete();
                }
            }, function (err) { return destination.error(err); })
                .then(null, function (err) {
                // Escaping the Promise trap: globally throw unhandled errors
                root.root.setTimeout(function () { throw err; });
            });
            return destination;
        }
        else if (result && typeof result[iterator.iterator] === 'function') {
            var iterator$$1 = result[iterator.iterator]();
            do {
                var item = iterator$$1.next();
                if (item.done) {
                    destination.complete();
                    break;
                }
                destination.next(item.value);
                if (destination.closed) {
                    break;
                }
            } while (true);
        }
        else if (result && typeof result[observable.observable] === 'function') {
            var obs = result[observable.observable]();
            if (typeof obs.subscribe !== 'function') {
                destination.error(new TypeError('Provided object does not correctly implement Symbol.observable'));
            }
            else {
                return obs.subscribe(new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex));
            }
        }
        else {
            var value = isObject_1.isObject(result) ? 'an invalid object' : "'" + result + "'";
            var msg = ("You provided " + value + " where a stream was expected.")
                + ' You can provide an Observable, Promise, Array, or Iterable.';
            destination.error(new TypeError(msg));
        }
        return null;
    }
    var subscribeToResult_2 = subscribeToResult;


    var subscribeToResult_1 = {
    	subscribeToResult: subscribeToResult_2
    };

    var __extends$w = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };




    var none = {};
    /* tslint:enable:max-line-length */
    /**
     * Combines multiple Observables to create an Observable whose values are
     * calculated from the latest values of each of its input Observables.
     *
     * <span class="informal">Whenever any input Observable emits a value, it
     * computes a formula using the latest values from all the inputs, then emits
     * the output of that formula.</span>
     *
     * <img src="./img/combineLatest.png" width="100%">
     *
     * `combineLatest` combines the values from this Observable with values from
     * Observables passed as arguments. This is done by subscribing to each
     * Observable, in order, and collecting an array of each of the most recent
     * values any time any of the input Observables emits, then either taking that
     * array and passing it as arguments to an optional `project` function and
     * emitting the return value of that, or just emitting the array of recent
     * values directly if there is no `project` function.
     *
     * @example <caption>Dynamically calculate the Body-Mass Index from an Observable of weight and one for height</caption>
     * var weight = Rx.Observable.of(70, 72, 76, 79, 75);
     * var height = Rx.Observable.of(1.76, 1.77, 1.78);
     * var bmi = weight.combineLatest(height, (w, h) => w / (h * h));
     * bmi.subscribe(x => console.log('BMI is ' + x));
     *
     * // With output to console:
     * // BMI is 24.212293388429753
     * // BMI is 23.93948099205209
     * // BMI is 23.671253629592222
     *
     * @see {@link combineAll}
     * @see {@link merge}
     * @see {@link withLatestFrom}
     *
     * @param {ObservableInput} other An input Observable to combine with the source
     * Observable. More than one input Observables may be given as argument.
     * @param {function} [project] An optional function to project the values from
     * the combined latest values into a new value on the output Observable.
     * @return {Observable} An Observable of projected values from the most recent
     * values from each input Observable, or an array of the most recent values from
     * each input Observable.
     * @method combineLatest
     * @owner Observable
     */
    function combineLatest() {
        var observables = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            observables[_i - 0] = arguments[_i];
        }
        var project = null;
        if (typeof observables[observables.length - 1] === 'function') {
            project = observables.pop();
        }
        // if the first and only other argument besides the resultSelector is an array
        // assume it's been called with `combineLatest([obs1, obs2, obs3], project)`
        if (observables.length === 1 && isArray.isArray(observables[0])) {
            observables = observables[0].slice();
        }
        return function (source) { return source.lift.call(new ArrayObservable_1.ArrayObservable([source].concat(observables)), new CombineLatestOperator(project)); };
    }
    var combineLatest_2 = combineLatest;
    var CombineLatestOperator = (function () {
        function CombineLatestOperator(project) {
            this.project = project;
        }
        CombineLatestOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(new CombineLatestSubscriber(subscriber, this.project));
        };
        return CombineLatestOperator;
    }());
    var CombineLatestOperator_1 = CombineLatestOperator;
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var CombineLatestSubscriber = (function (_super) {
        __extends$w(CombineLatestSubscriber, _super);
        function CombineLatestSubscriber(destination, project) {
            _super.call(this, destination);
            this.project = project;
            this.active = 0;
            this.values = [];
            this.observables = [];
        }
        CombineLatestSubscriber.prototype._next = function (observable) {
            this.values.push(none);
            this.observables.push(observable);
        };
        CombineLatestSubscriber.prototype._complete = function () {
            var observables = this.observables;
            var len = observables.length;
            if (len === 0) {
                this.destination.complete();
            }
            else {
                this.active = len;
                this.toRespond = len;
                for (var i = 0; i < len; i++) {
                    var observable = observables[i];
                    this.add(subscribeToResult_1.subscribeToResult(this, observable, observable, i));
                }
            }
        };
        CombineLatestSubscriber.prototype.notifyComplete = function (unused) {
            if ((this.active -= 1) === 0) {
                this.destination.complete();
            }
        };
        CombineLatestSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
            var values = this.values;
            var oldVal = values[outerIndex];
            var toRespond = !this.toRespond
                ? 0
                : oldVal === none ? --this.toRespond : this.toRespond;
            values[outerIndex] = innerValue;
            if (toRespond === 0) {
                if (this.project) {
                    this._tryProject(values);
                }
                else {
                    this.destination.next(values.slice());
                }
            }
        };
        CombineLatestSubscriber.prototype._tryProject = function (values) {
            var result;
            try {
                result = this.project.apply(this, values);
            }
            catch (err) {
                this.destination.error(err);
                return;
            }
            this.destination.next(result);
        };
        return CombineLatestSubscriber;
    }(OuterSubscriber_1.OuterSubscriber));
    var CombineLatestSubscriber_1 = CombineLatestSubscriber;


    var combineLatest_1 = {
    	combineLatest: combineLatest_2,
    	CombineLatestOperator: CombineLatestOperator_1,
    	CombineLatestSubscriber: CombineLatestSubscriber_1
    };

    /* tslint:enable:max-line-length */
    /**
     * Combines multiple Observables to create an Observable whose values are
     * calculated from the latest values of each of its input Observables.
     *
     * <span class="informal">Whenever any input Observable emits a value, it
     * computes a formula using the latest values from all the inputs, then emits
     * the output of that formula.</span>
     *
     * <img src="./img/combineLatest.png" width="100%">
     *
     * `combineLatest` combines the values from all the Observables passed as
     * arguments. This is done by subscribing to each Observable in order and,
     * whenever any Observable emits, collecting an array of the most recent
     * values from each Observable. So if you pass `n` Observables to operator,
     * returned Observable will always emit an array of `n` values, in order
     * corresponding to order of passed Observables (value from the first Observable
     * on the first place and so on).
     *
     * Static version of `combineLatest` accepts either an array of Observables
     * or each Observable can be put directly as an argument. Note that array of
     * Observables is good choice, if you don't know beforehand how many Observables
     * you will combine. Passing empty array will result in Observable that
     * completes immediately.
     *
     * To ensure output array has always the same length, `combineLatest` will
     * actually wait for all input Observables to emit at least once,
     * before it starts emitting results. This means if some Observable emits
     * values before other Observables started emitting, all that values but last
     * will be lost. On the other hand, is some Observable does not emit value but
     * completes, resulting Observable will complete at the same moment without
     * emitting anything, since it will be now impossible to include value from
     * completed Observable in resulting array. Also, if some input Observable does
     * not emit any value and never completes, `combineLatest` will also never emit
     * and never complete, since, again, it will wait for all streams to emit some
     * value.
     *
     * If at least one Observable was passed to `combineLatest` and all passed Observables
     * emitted something, resulting Observable will complete when all combined
     * streams complete. So even if some Observable completes, result of
     * `combineLatest` will still emit values when other Observables do. In case
     * of completed Observable, its value from now on will always be the last
     * emitted value. On the other hand, if any Observable errors, `combineLatest`
     * will error immediately as well, and all other Observables will be unsubscribed.
     *
     * `combineLatest` accepts as optional parameter `project` function, which takes
     * as arguments all values that would normally be emitted by resulting Observable.
     * `project` can return any kind of value, which will be then emitted by Observable
     * instead of default array. Note that `project` does not take as argument that array
     * of values, but values themselves. That means default `project` can be imagined
     * as function that takes all its arguments and puts them into an array.
     *
     *
     * @example <caption>Combine two timer Observables</caption>
     * const firstTimer = Rx.Observable.timer(0, 1000); // emit 0, 1, 2... after every second, starting from now
     * const secondTimer = Rx.Observable.timer(500, 1000); // emit 0, 1, 2... after every second, starting 0,5s from now
     * const combinedTimers = Rx.Observable.combineLatest(firstTimer, secondTimer);
     * combinedTimers.subscribe(value => console.log(value));
     * // Logs
     * // [0, 0] after 0.5s
     * // [1, 0] after 1s
     * // [1, 1] after 1.5s
     * // [2, 1] after 2s
     *
     *
     * @example <caption>Combine an array of Observables</caption>
     * const observables = [1, 5, 10].map(
     *   n => Rx.Observable.of(n).delay(n * 1000).startWith(0) // emit 0 and then emit n after n seconds
     * );
     * const combined = Rx.Observable.combineLatest(observables);
     * combined.subscribe(value => console.log(value));
     * // Logs
     * // [0, 0, 0] immediately
     * // [1, 0, 0] after 1s
     * // [1, 5, 0] after 5s
     * // [1, 5, 10] after 10s
     *
     *
     * @example <caption>Use project function to dynamically calculate the Body-Mass Index</caption>
     * var weight = Rx.Observable.of(70, 72, 76, 79, 75);
     * var height = Rx.Observable.of(1.76, 1.77, 1.78);
     * var bmi = Rx.Observable.combineLatest(weight, height, (w, h) => w / (h * h));
     * bmi.subscribe(x => console.log('BMI is ' + x));
     *
     * // With output to console:
     * // BMI is 24.212293388429753
     * // BMI is 23.93948099205209
     * // BMI is 23.671253629592222
     *
     *
     * @see {@link combineAll}
     * @see {@link merge}
     * @see {@link withLatestFrom}
     *
     * @param {ObservableInput} observable1 An input Observable to combine with other Observables.
     * @param {ObservableInput} observable2 An input Observable to combine with other Observables.
     * More than one input Observables may be given as arguments
     * or an array of Observables may be given as the first argument.
     * @param {function} [project] An optional function to project the values from
     * the combined latest values into a new value on the output Observable.
     * @param {Scheduler} [scheduler=null] The IScheduler to use for subscribing to
     * each input Observable.
     * @return {Observable} An Observable of projected values from the most recent
     * values from each input Observable, or an array of the most recent values from
     * each input Observable.
     * @static true
     * @name combineLatest
     * @owner Observable
     */
    function combineLatest$1() {
        var observables = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            observables[_i - 0] = arguments[_i];
        }
        var project = null;
        var scheduler = null;
        if (isScheduler_1.isScheduler(observables[observables.length - 1])) {
            scheduler = observables.pop();
        }
        if (typeof observables[observables.length - 1] === 'function') {
            project = observables.pop();
        }
        // if the first and only other argument besides the resultSelector is an array
        // assume it's been called with `combineLatest([obs1, obs2, obs3], project)`
        if (observables.length === 1 && isArray.isArray(observables[0])) {
            observables = observables[0];
        }
        return new ArrayObservable_1.ArrayObservable(observables, scheduler).lift(new combineLatest_1.CombineLatestOperator(project));
    }
    var combineLatest_3 = combineLatest$1;


    var combineLatest_2$1 = {
    	combineLatest: combineLatest_3
    };

    Observable_1.Observable.combineLatest = combineLatest_2$1.combineLatest;

    var of_1 = ArrayObservable_1.ArrayObservable.of;


    var of = {
    	of: of_1
    };

    var __extends$x = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };


    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @extends {Ignored}
     * @hide true
     */
    var PromiseObservable = (function (_super) {
        __extends$x(PromiseObservable, _super);
        function PromiseObservable(promise, scheduler) {
            _super.call(this);
            this.promise = promise;
            this.scheduler = scheduler;
        }
        /**
         * Converts a Promise to an Observable.
         *
         * <span class="informal">Returns an Observable that just emits the Promise's
         * resolved value, then completes.</span>
         *
         * Converts an ES2015 Promise or a Promises/A+ spec compliant Promise to an
         * Observable. If the Promise resolves with a value, the output Observable
         * emits that resolved value as a `next`, and then completes. If the Promise
         * is rejected, then the output Observable emits the corresponding Error.
         *
         * @example <caption>Convert the Promise returned by Fetch to an Observable</caption>
         * var result = Rx.Observable.fromPromise(fetch('http://myserver.com/'));
         * result.subscribe(x => console.log(x), e => console.error(e));
         *
         * @see {@link bindCallback}
         * @see {@link from}
         *
         * @param {PromiseLike<T>} promise The promise to be converted.
         * @param {Scheduler} [scheduler] An optional IScheduler to use for scheduling
         * the delivery of the resolved value (or the rejection).
         * @return {Observable<T>} An Observable which wraps the Promise.
         * @static true
         * @name fromPromise
         * @owner Observable
         */
        PromiseObservable.create = function (promise, scheduler) {
            return new PromiseObservable(promise, scheduler);
        };
        /** @deprecated internal use only */ PromiseObservable.prototype._subscribe = function (subscriber) {
            var _this = this;
            var promise = this.promise;
            var scheduler = this.scheduler;
            if (scheduler == null) {
                if (this._isScalar) {
                    if (!subscriber.closed) {
                        subscriber.next(this.value);
                        subscriber.complete();
                    }
                }
                else {
                    promise.then(function (value) {
                        _this.value = value;
                        _this._isScalar = true;
                        if (!subscriber.closed) {
                            subscriber.next(value);
                            subscriber.complete();
                        }
                    }, function (err) {
                        if (!subscriber.closed) {
                            subscriber.error(err);
                        }
                    })
                        .then(null, function (err) {
                        // escape the promise trap, throw unhandled errors
                        root.root.setTimeout(function () { throw err; });
                    });
                }
            }
            else {
                if (this._isScalar) {
                    if (!subscriber.closed) {
                        return scheduler.schedule(dispatchNext$2, 0, { value: this.value, subscriber: subscriber });
                    }
                }
                else {
                    promise.then(function (value) {
                        _this.value = value;
                        _this._isScalar = true;
                        if (!subscriber.closed) {
                            subscriber.add(scheduler.schedule(dispatchNext$2, 0, { value: value, subscriber: subscriber }));
                        }
                    }, function (err) {
                        if (!subscriber.closed) {
                            subscriber.add(scheduler.schedule(dispatchError$2, 0, { err: err, subscriber: subscriber }));
                        }
                    })
                        .then(null, function (err) {
                        // escape the promise trap, throw unhandled errors
                        root.root.setTimeout(function () { throw err; });
                    });
                }
            }
        };
        return PromiseObservable;
    }(Observable_1.Observable));
    var PromiseObservable_2 = PromiseObservable;
    function dispatchNext$2(arg) {
        var value = arg.value, subscriber = arg.subscriber;
        if (!subscriber.closed) {
            subscriber.next(value);
            subscriber.complete();
        }
    }
    function dispatchError$2(arg) {
        var err = arg.err, subscriber = arg.subscriber;
        if (!subscriber.closed) {
            subscriber.error(err);
        }
    }


    var PromiseObservable_1 = {
    	PromiseObservable: PromiseObservable_2
    };

    var __extends$y = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };



    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @extends {Ignored}
     * @hide true
     */
    var IteratorObservable = (function (_super) {
        __extends$y(IteratorObservable, _super);
        function IteratorObservable(iterator$$1, scheduler) {
            _super.call(this);
            this.scheduler = scheduler;
            if (iterator$$1 == null) {
                throw new Error('iterator cannot be null.');
            }
            this.iterator = getIterator(iterator$$1);
        }
        IteratorObservable.create = function (iterator$$1, scheduler) {
            return new IteratorObservable(iterator$$1, scheduler);
        };
        IteratorObservable.dispatch = function (state) {
            var index = state.index, hasError = state.hasError, iterator$$1 = state.iterator, subscriber = state.subscriber;
            if (hasError) {
                subscriber.error(state.error);
                return;
            }
            var result = iterator$$1.next();
            if (result.done) {
                subscriber.complete();
                return;
            }
            subscriber.next(result.value);
            state.index = index + 1;
            if (subscriber.closed) {
                if (typeof iterator$$1.return === 'function') {
                    iterator$$1.return();
                }
                return;
            }
            this.schedule(state);
        };
        /** @deprecated internal use only */ IteratorObservable.prototype._subscribe = function (subscriber) {
            var index = 0;
            var _a = this, iterator$$1 = _a.iterator, scheduler = _a.scheduler;
            if (scheduler) {
                return scheduler.schedule(IteratorObservable.dispatch, 0, {
                    index: index, iterator: iterator$$1, subscriber: subscriber
                });
            }
            else {
                do {
                    var result = iterator$$1.next();
                    if (result.done) {
                        subscriber.complete();
                        break;
                    }
                    else {
                        subscriber.next(result.value);
                    }
                    if (subscriber.closed) {
                        if (typeof iterator$$1.return === 'function') {
                            iterator$$1.return();
                        }
                        break;
                    }
                } while (true);
            }
        };
        return IteratorObservable;
    }(Observable_1.Observable));
    var IteratorObservable_2 = IteratorObservable;
    var StringIterator = (function () {
        function StringIterator(str, idx, len) {
            if (idx === void 0) { idx = 0; }
            if (len === void 0) { len = str.length; }
            this.str = str;
            this.idx = idx;
            this.len = len;
        }
        StringIterator.prototype[iterator.iterator] = function () { return (this); };
        StringIterator.prototype.next = function () {
            return this.idx < this.len ? {
                done: false,
                value: this.str.charAt(this.idx++)
            } : {
                done: true,
                value: undefined
            };
        };
        return StringIterator;
    }());
    var ArrayIterator = (function () {
        function ArrayIterator(arr, idx, len) {
            if (idx === void 0) { idx = 0; }
            if (len === void 0) { len = toLength(arr); }
            this.arr = arr;
            this.idx = idx;
            this.len = len;
        }
        ArrayIterator.prototype[iterator.iterator] = function () { return this; };
        ArrayIterator.prototype.next = function () {
            return this.idx < this.len ? {
                done: false,
                value: this.arr[this.idx++]
            } : {
                done: true,
                value: undefined
            };
        };
        return ArrayIterator;
    }());
    function getIterator(obj) {
        var i = obj[iterator.iterator];
        if (!i && typeof obj === 'string') {
            return new StringIterator(obj);
        }
        if (!i && obj.length !== undefined) {
            return new ArrayIterator(obj);
        }
        if (!i) {
            throw new TypeError('object is not iterable');
        }
        return obj[iterator.iterator]();
    }
    var maxSafeInteger = Math.pow(2, 53) - 1;
    function toLength(o) {
        var len = +o.length;
        if (isNaN(len)) {
            return 0;
        }
        if (len === 0 || !numberIsFinite(len)) {
            return len;
        }
        len = sign(len) * Math.floor(Math.abs(len));
        if (len <= 0) {
            return 0;
        }
        if (len > maxSafeInteger) {
            return maxSafeInteger;
        }
        return len;
    }
    function numberIsFinite(value) {
        return typeof value === 'number' && root.root.isFinite(value);
    }
    function sign(value) {
        var valueAsNumber = +value;
        if (valueAsNumber === 0) {
            return valueAsNumber;
        }
        if (isNaN(valueAsNumber)) {
            return valueAsNumber;
        }
        return valueAsNumber < 0 ? -1 : 1;
    }


    var IteratorObservable_1 = {
    	IteratorObservable: IteratorObservable_2
    };

    var __extends$z = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };



    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @extends {Ignored}
     * @hide true
     */
    var ArrayLikeObservable = (function (_super) {
        __extends$z(ArrayLikeObservable, _super);
        function ArrayLikeObservable(arrayLike, scheduler) {
            _super.call(this);
            this.arrayLike = arrayLike;
            this.scheduler = scheduler;
            if (!scheduler && arrayLike.length === 1) {
                this._isScalar = true;
                this.value = arrayLike[0];
            }
        }
        ArrayLikeObservable.create = function (arrayLike, scheduler) {
            var length = arrayLike.length;
            if (length === 0) {
                return new EmptyObservable_1.EmptyObservable();
            }
            else if (length === 1) {
                return new ScalarObservable_1.ScalarObservable(arrayLike[0], scheduler);
            }
            else {
                return new ArrayLikeObservable(arrayLike, scheduler);
            }
        };
        ArrayLikeObservable.dispatch = function (state) {
            var arrayLike = state.arrayLike, index = state.index, length = state.length, subscriber = state.subscriber;
            if (subscriber.closed) {
                return;
            }
            if (index >= length) {
                subscriber.complete();
                return;
            }
            subscriber.next(arrayLike[index]);
            state.index = index + 1;
            this.schedule(state);
        };
        /** @deprecated internal use only */ ArrayLikeObservable.prototype._subscribe = function (subscriber) {
            var index = 0;
            var _a = this, arrayLike = _a.arrayLike, scheduler = _a.scheduler;
            var length = arrayLike.length;
            if (scheduler) {
                return scheduler.schedule(ArrayLikeObservable.dispatch, 0, {
                    arrayLike: arrayLike, index: index, length: length, subscriber: subscriber
                });
            }
            else {
                for (var i = 0; i < length && !subscriber.closed; i++) {
                    subscriber.next(arrayLike[i]);
                }
                subscriber.complete();
            }
        };
        return ArrayLikeObservable;
    }(Observable_1.Observable));
    var ArrayLikeObservable_2 = ArrayLikeObservable;


    var ArrayLikeObservable_1 = {
    	ArrayLikeObservable: ArrayLikeObservable_2
    };

    /**
     * Represents a push-based event or value that an {@link Observable} can emit.
     * This class is particularly useful for operators that manage notifications,
     * like {@link materialize}, {@link dematerialize}, {@link observeOn}, and
     * others. Besides wrapping the actual delivered value, it also annotates it
     * with metadata of, for instance, what type of push message it is (`next`,
     * `error`, or `complete`).
     *
     * @see {@link materialize}
     * @see {@link dematerialize}
     * @see {@link observeOn}
     *
     * @class Notification<T>
     */
    var Notification$1 = (function () {
        function Notification(kind, value, error) {
            this.kind = kind;
            this.value = value;
            this.error = error;
            this.hasValue = kind === 'N';
        }
        /**
         * Delivers to the given `observer` the value wrapped by this Notification.
         * @param {Observer} observer
         * @return
         */
        Notification.prototype.observe = function (observer) {
            switch (this.kind) {
                case 'N':
                    return observer.next && observer.next(this.value);
                case 'E':
                    return observer.error && observer.error(this.error);
                case 'C':
                    return observer.complete && observer.complete();
            }
        };
        /**
         * Given some {@link Observer} callbacks, deliver the value represented by the
         * current Notification to the correctly corresponding callback.
         * @param {function(value: T): void} next An Observer `next` callback.
         * @param {function(err: any): void} [error] An Observer `error` callback.
         * @param {function(): void} [complete] An Observer `complete` callback.
         * @return {any}
         */
        Notification.prototype.do = function (next, error, complete) {
            var kind = this.kind;
            switch (kind) {
                case 'N':
                    return next && next(this.value);
                case 'E':
                    return error && error(this.error);
                case 'C':
                    return complete && complete();
            }
        };
        /**
         * Takes an Observer or its individual callback functions, and calls `observe`
         * or `do` methods accordingly.
         * @param {Observer|function(value: T): void} nextOrObserver An Observer or
         * the `next` callback.
         * @param {function(err: any): void} [error] An Observer `error` callback.
         * @param {function(): void} [complete] An Observer `complete` callback.
         * @return {any}
         */
        Notification.prototype.accept = function (nextOrObserver, error, complete) {
            if (nextOrObserver && typeof nextOrObserver.next === 'function') {
                return this.observe(nextOrObserver);
            }
            else {
                return this.do(nextOrObserver, error, complete);
            }
        };
        /**
         * Returns a simple Observable that just delivers the notification represented
         * by this Notification instance.
         * @return {any}
         */
        Notification.prototype.toObservable = function () {
            var kind = this.kind;
            switch (kind) {
                case 'N':
                    return Observable_1.Observable.of(this.value);
                case 'E':
                    return Observable_1.Observable.throw(this.error);
                case 'C':
                    return Observable_1.Observable.empty();
            }
            throw new Error('unexpected notification kind value');
        };
        /**
         * A shortcut to create a Notification instance of the type `next` from a
         * given value.
         * @param {T} value The `next` value.
         * @return {Notification<T>} The "next" Notification representing the
         * argument.
         */
        Notification.createNext = function (value) {
            if (typeof value !== 'undefined') {
                return new Notification('N', value);
            }
            return Notification.undefinedValueNotification;
        };
        /**
         * A shortcut to create a Notification instance of the type `error` from a
         * given error.
         * @param {any} [err] The `error` error.
         * @return {Notification<T>} The "error" Notification representing the
         * argument.
         */
        Notification.createError = function (err) {
            return new Notification('E', undefined, err);
        };
        /**
         * A shortcut to create a Notification instance of the type `complete`.
         * @return {Notification<any>} The valueless "complete" Notification.
         */
        Notification.createComplete = function () {
            return Notification.completeNotification;
        };
        Notification.completeNotification = new Notification('C');
        Notification.undefinedValueNotification = new Notification('N', undefined);
        return Notification;
    }());
    var Notification_2 = Notification$1;


    var Notification_1 = {
    	Notification: Notification_2
    };

    var __extends$A = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };


    /**
     *
     * Re-emits all notifications from source Observable with specified scheduler.
     *
     * <span class="informal">Ensure a specific scheduler is used, from outside of an Observable.</span>
     *
     * `observeOn` is an operator that accepts a scheduler as a first parameter, which will be used to reschedule
     * notifications emitted by the source Observable. It might be useful, if you do not have control over
     * internal scheduler of a given Observable, but want to control when its values are emitted nevertheless.
     *
     * Returned Observable emits the same notifications (nexted values, complete and error events) as the source Observable,
     * but rescheduled with provided scheduler. Note that this doesn't mean that source Observables internal
     * scheduler will be replaced in any way. Original scheduler still will be used, but when the source Observable emits
     * notification, it will be immediately scheduled again - this time with scheduler passed to `observeOn`.
     * An anti-pattern would be calling `observeOn` on Observable that emits lots of values synchronously, to split
     * that emissions into asynchronous chunks. For this to happen, scheduler would have to be passed into the source
     * Observable directly (usually into the operator that creates it). `observeOn` simply delays notifications a
     * little bit more, to ensure that they are emitted at expected moments.
     *
     * As a matter of fact, `observeOn` accepts second parameter, which specifies in milliseconds with what delay notifications
     * will be emitted. The main difference between {@link delay} operator and `observeOn` is that `observeOn`
     * will delay all notifications - including error notifications - while `delay` will pass through error
     * from source Observable immediately when it is emitted. In general it is highly recommended to use `delay` operator
     * for any kind of delaying of values in the stream, while using `observeOn` to specify which scheduler should be used
     * for notification emissions in general.
     *
     * @example <caption>Ensure values in subscribe are called just before browser repaint.</caption>
     * const intervals = Rx.Observable.interval(10); // Intervals are scheduled
     *                                               // with async scheduler by default...
     *
     * intervals
     * .observeOn(Rx.Scheduler.animationFrame)       // ...but we will observe on animationFrame
     * .subscribe(val => {                           // scheduler to ensure smooth animation.
     *   someDiv.style.height = val + 'px';
     * });
     *
     * @see {@link delay}
     *
     * @param {IScheduler} scheduler Scheduler that will be used to reschedule notifications from source Observable.
     * @param {number} [delay] Number of milliseconds that states with what delay every notification should be rescheduled.
     * @return {Observable<T>} Observable that emits the same notifications as the source Observable,
     * but with provided scheduler.
     *
     * @method observeOn
     * @owner Observable
     */
    function observeOn(scheduler, delay) {
        if (delay === void 0) { delay = 0; }
        return function observeOnOperatorFunction(source) {
            return source.lift(new ObserveOnOperator(scheduler, delay));
        };
    }
    var observeOn_2 = observeOn;
    var ObserveOnOperator = (function () {
        function ObserveOnOperator(scheduler, delay) {
            if (delay === void 0) { delay = 0; }
            this.scheduler = scheduler;
            this.delay = delay;
        }
        ObserveOnOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));
        };
        return ObserveOnOperator;
    }());
    var ObserveOnOperator_1 = ObserveOnOperator;
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var ObserveOnSubscriber = (function (_super) {
        __extends$A(ObserveOnSubscriber, _super);
        function ObserveOnSubscriber(destination, scheduler, delay) {
            if (delay === void 0) { delay = 0; }
            _super.call(this, destination);
            this.scheduler = scheduler;
            this.delay = delay;
        }
        ObserveOnSubscriber.dispatch = function (arg) {
            var notification = arg.notification, destination = arg.destination;
            notification.observe(destination);
            this.unsubscribe();
        };
        ObserveOnSubscriber.prototype.scheduleMessage = function (notification) {
            this.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));
        };
        ObserveOnSubscriber.prototype._next = function (value) {
            this.scheduleMessage(Notification_1.Notification.createNext(value));
        };
        ObserveOnSubscriber.prototype._error = function (err) {
            this.scheduleMessage(Notification_1.Notification.createError(err));
        };
        ObserveOnSubscriber.prototype._complete = function () {
            this.scheduleMessage(Notification_1.Notification.createComplete());
        };
        return ObserveOnSubscriber;
    }(Subscriber_1.Subscriber));
    var ObserveOnSubscriber_1 = ObserveOnSubscriber;
    var ObserveOnMessage = (function () {
        function ObserveOnMessage(notification, destination) {
            this.notification = notification;
            this.destination = destination;
        }
        return ObserveOnMessage;
    }());
    var ObserveOnMessage_1 = ObserveOnMessage;


    var observeOn_1 = {
    	observeOn: observeOn_2,
    	ObserveOnOperator: ObserveOnOperator_1,
    	ObserveOnSubscriber: ObserveOnSubscriber_1,
    	ObserveOnMessage: ObserveOnMessage_1
    };

    var __extends$B = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };











    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @extends {Ignored}
     * @hide true
     */
    var FromObservable = (function (_super) {
        __extends$B(FromObservable, _super);
        function FromObservable(ish, scheduler) {
            _super.call(this, null);
            this.ish = ish;
            this.scheduler = scheduler;
        }
        /**
         * Creates an Observable from an Array, an array-like object, a Promise, an
         * iterable object, or an Observable-like object.
         *
         * <span class="informal">Converts almost anything to an Observable.</span>
         *
         * <img src="./img/from.png" width="100%">
         *
         * Convert various other objects and data types into Observables. `from`
         * converts a Promise or an array-like or an
         * [iterable](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterable)
         * object into an Observable that emits the items in that promise or array or
         * iterable. A String, in this context, is treated as an array of characters.
         * Observable-like objects (contains a function named with the ES2015 Symbol
         * for Observable) can also be converted through this operator.
         *
         * @example <caption>Converts an array to an Observable</caption>
         * var array = [10, 20, 30];
         * var result = Rx.Observable.from(array);
         * result.subscribe(x => console.log(x));
         *
         * // Results in the following:
         * // 10 20 30
         *
         * @example <caption>Convert an infinite iterable (from a generator) to an Observable</caption>
         * function* generateDoubles(seed) {
         *   var i = seed;
         *   while (true) {
         *     yield i;
         *     i = 2 * i; // double it
         *   }
         * }
         *
         * var iterator = generateDoubles(3);
         * var result = Rx.Observable.from(iterator).take(10);
         * result.subscribe(x => console.log(x));
         *
         * // Results in the following:
         * // 3 6 12 24 48 96 192 384 768 1536
         *
         * @see {@link create}
         * @see {@link fromEvent}
         * @see {@link fromEventPattern}
         * @see {@link fromPromise}
         *
         * @param {ObservableInput<T>} ish A subscribable object, a Promise, an
         * Observable-like, an Array, an iterable or an array-like object to be
         * converted.
         * @param {Scheduler} [scheduler] The scheduler on which to schedule the
         * emissions of values.
         * @return {Observable<T>} The Observable whose values are originally from the
         * input object that was converted.
         * @static true
         * @name from
         * @owner Observable
         */
        FromObservable.create = function (ish, scheduler) {
            if (ish != null) {
                if (typeof ish[observable.observable] === 'function') {
                    if (ish instanceof Observable_1.Observable && !scheduler) {
                        return ish;
                    }
                    return new FromObservable(ish, scheduler);
                }
                else if (isArray.isArray(ish)) {
                    return new ArrayObservable_1.ArrayObservable(ish, scheduler);
                }
                else if (isPromise_1.isPromise(ish)) {
                    return new PromiseObservable_1.PromiseObservable(ish, scheduler);
                }
                else if (typeof ish[iterator.iterator] === 'function' || typeof ish === 'string') {
                    return new IteratorObservable_1.IteratorObservable(ish, scheduler);
                }
                else if (isArrayLike.isArrayLike(ish)) {
                    return new ArrayLikeObservable_1.ArrayLikeObservable(ish, scheduler);
                }
            }
            throw new TypeError((ish !== null && typeof ish || ish) + ' is not observable');
        };
        /** @deprecated internal use only */ FromObservable.prototype._subscribe = function (subscriber) {
            var ish = this.ish;
            var scheduler = this.scheduler;
            if (scheduler == null) {
                return ish[observable.observable]().subscribe(subscriber);
            }
            else {
                return ish[observable.observable]().subscribe(new observeOn_1.ObserveOnSubscriber(subscriber, scheduler, 0));
            }
        };
        return FromObservable;
    }(Observable_1.Observable));
    var FromObservable_2 = FromObservable;


    var FromObservable_1 = {
    	FromObservable: FromObservable_2
    };

    var from_1 = FromObservable_1.FromObservable.create;


    var from = {
    	from: from_1
    };

    var __extends$C = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };


    /* tslint:enable:max-line-length */
    /**
     * Projects each source value to an Observable which is merged in the output
     * Observable.
     *
     * <span class="informal">Maps each value to an Observable, then flattens all of
     * these inner Observables using {@link mergeAll}.</span>
     *
     * <img src="./img/mergeMap.png" width="100%">
     *
     * Returns an Observable that emits items based on applying a function that you
     * supply to each item emitted by the source Observable, where that function
     * returns an Observable, and then merging those resulting Observables and
     * emitting the results of this merger.
     *
     * @example <caption>Map and flatten each letter to an Observable ticking every 1 second</caption>
     * var letters = Rx.Observable.of('a', 'b', 'c');
     * var result = letters.mergeMap(x =>
     *   Rx.Observable.interval(1000).map(i => x+i)
     * );
     * result.subscribe(x => console.log(x));
     *
     * // Results in the following:
     * // a0
     * // b0
     * // c0
     * // a1
     * // b1
     * // c1
     * // continues to list a,b,c with respective ascending integers
     *
     * @see {@link concatMap}
     * @see {@link exhaustMap}
     * @see {@link merge}
     * @see {@link mergeAll}
     * @see {@link mergeMapTo}
     * @see {@link mergeScan}
     * @see {@link switchMap}
     *
     * @param {function(value: T, ?index: number): ObservableInput} project A function
     * that, when applied to an item emitted by the source Observable, returns an
     * Observable.
     * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
     * A function to produce the value on the output Observable based on the values
     * and the indices of the source (outer) emission and the inner Observable
     * emission. The arguments passed to this function are:
     * - `outerValue`: the value that came from the source
     * - `innerValue`: the value that came from the projected Observable
     * - `outerIndex`: the "index" of the value that came from the source
     * - `innerIndex`: the "index" of the value from the projected Observable
     * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
     * Observables being subscribed to concurrently.
     * @return {Observable} An Observable that emits the result of applying the
     * projection function (and the optional `resultSelector`) to each item emitted
     * by the source Observable and merging the results of the Observables obtained
     * from this transformation.
     * @method mergeMap
     * @owner Observable
     */
    function mergeMap(project, resultSelector, concurrent) {
        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
        return function mergeMapOperatorFunction(source) {
            if (typeof resultSelector === 'number') {
                concurrent = resultSelector;
                resultSelector = null;
            }
            return source.lift(new MergeMapOperator(project, resultSelector, concurrent));
        };
    }
    var mergeMap_2 = mergeMap;
    var MergeMapOperator = (function () {
        function MergeMapOperator(project, resultSelector, concurrent) {
            if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
            this.project = project;
            this.resultSelector = resultSelector;
            this.concurrent = concurrent;
        }
        MergeMapOperator.prototype.call = function (observer, source) {
            return source.subscribe(new MergeMapSubscriber(observer, this.project, this.resultSelector, this.concurrent));
        };
        return MergeMapOperator;
    }());
    var MergeMapOperator_1 = MergeMapOperator;
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var MergeMapSubscriber = (function (_super) {
        __extends$C(MergeMapSubscriber, _super);
        function MergeMapSubscriber(destination, project, resultSelector, concurrent) {
            if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
            _super.call(this, destination);
            this.project = project;
            this.resultSelector = resultSelector;
            this.concurrent = concurrent;
            this.hasCompleted = false;
            this.buffer = [];
            this.active = 0;
            this.index = 0;
        }
        MergeMapSubscriber.prototype._next = function (value) {
            if (this.active < this.concurrent) {
                this._tryNext(value);
            }
            else {
                this.buffer.push(value);
            }
        };
        MergeMapSubscriber.prototype._tryNext = function (value) {
            var result;
            var index = this.index++;
            try {
                result = this.project(value, index);
            }
            catch (err) {
                this.destination.error(err);
                return;
            }
            this.active++;
            this._innerSub(result, value, index);
        };
        MergeMapSubscriber.prototype._innerSub = function (ish, value, index) {
            this.add(subscribeToResult_1.subscribeToResult(this, ish, value, index));
        };
        MergeMapSubscriber.prototype._complete = function () {
            this.hasCompleted = true;
            if (this.active === 0 && this.buffer.length === 0) {
                this.destination.complete();
            }
        };
        MergeMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
            if (this.resultSelector) {
                this._notifyResultSelector(outerValue, innerValue, outerIndex, innerIndex);
            }
            else {
                this.destination.next(innerValue);
            }
        };
        MergeMapSubscriber.prototype._notifyResultSelector = function (outerValue, innerValue, outerIndex, innerIndex) {
            var result;
            try {
                result = this.resultSelector(outerValue, innerValue, outerIndex, innerIndex);
            }
            catch (err) {
                this.destination.error(err);
                return;
            }
            this.destination.next(result);
        };
        MergeMapSubscriber.prototype.notifyComplete = function (innerSub) {
            var buffer = this.buffer;
            this.remove(innerSub);
            this.active--;
            if (buffer.length > 0) {
                this._next(buffer.shift());
            }
            else if (this.active === 0 && this.hasCompleted) {
                this.destination.complete();
            }
        };
        return MergeMapSubscriber;
    }(OuterSubscriber_1.OuterSubscriber));
    var MergeMapSubscriber_1 = MergeMapSubscriber;


    var mergeMap_1 = {
    	mergeMap: mergeMap_2,
    	MergeMapOperator: MergeMapOperator_1,
    	MergeMapSubscriber: MergeMapSubscriber_1
    };

    function identity(x) {
        return x;
    }
    var identity_2 = identity;


    var identity_1 = {
    	identity: identity_2
    };

    /**
     * Converts a higher-order Observable into a first-order Observable which
     * concurrently delivers all values that are emitted on the inner Observables.
     *
     * <span class="informal">Flattens an Observable-of-Observables.</span>
     *
     * <img src="./img/mergeAll.png" width="100%">
     *
     * `mergeAll` subscribes to an Observable that emits Observables, also known as
     * a higher-order Observable. Each time it observes one of these emitted inner
     * Observables, it subscribes to that and delivers all the values from the
     * inner Observable on the output Observable. The output Observable only
     * completes once all inner Observables have completed. Any error delivered by
     * a inner Observable will be immediately emitted on the output Observable.
     *
     * @example <caption>Spawn a new interval Observable for each click event, and blend their outputs as one Observable</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000));
     * var firstOrder = higherOrder.mergeAll();
     * firstOrder.subscribe(x => console.log(x));
     *
     * @example <caption>Count from 0 to 9 every second for each click, but only allow 2 concurrent timers</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000).take(10));
     * var firstOrder = higherOrder.mergeAll(2);
     * firstOrder.subscribe(x => console.log(x));
     *
     * @see {@link combineAll}
     * @see {@link concatAll}
     * @see {@link exhaust}
     * @see {@link merge}
     * @see {@link mergeMap}
     * @see {@link mergeMapTo}
     * @see {@link mergeScan}
     * @see {@link switch}
     * @see {@link zipAll}
     *
     * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of inner
     * Observables being subscribed to concurrently.
     * @return {Observable} An Observable that emits values coming from all the
     * inner Observables emitted by the source Observable.
     * @method mergeAll
     * @owner Observable
     */
    function mergeAll(concurrent) {
        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
        return mergeMap_1.mergeMap(identity_1.identity, null, concurrent);
    }
    var mergeAll_2 = mergeAll;


    var mergeAll_1 = {
    	mergeAll: mergeAll_2
    };

    /**
     * Converts a higher-order Observable into a first-order Observable by
     * concatenating the inner Observables in order.
     *
     * <span class="informal">Flattens an Observable-of-Observables by putting one
     * inner Observable after the other.</span>
     *
     * <img src="./img/concatAll.png" width="100%">
     *
     * Joins every Observable emitted by the source (a higher-order Observable), in
     * a serial fashion. It subscribes to each inner Observable only after the
     * previous inner Observable has completed, and merges all of their values into
     * the returned observable.
     *
     * __Warning:__ If the source Observable emits Observables quickly and
     * endlessly, and the inner Observables it emits generally complete slower than
     * the source emits, you can run into memory issues as the incoming Observables
     * collect in an unbounded buffer.
     *
     * Note: `concatAll` is equivalent to `mergeAll` with concurrency parameter set
     * to `1`.
     *
     * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var higherOrder = clicks.map(ev => Rx.Observable.interval(1000).take(4));
     * var firstOrder = higherOrder.concatAll();
     * firstOrder.subscribe(x => console.log(x));
     *
     * // Results in the following:
     * // (results are not concurrent)
     * // For every click on the "document" it will emit values 0 to 3 spaced
     * // on a 1000ms interval
     * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3
     *
     * @see {@link combineAll}
     * @see {@link concat}
     * @see {@link concatMap}
     * @see {@link concatMapTo}
     * @see {@link exhaust}
     * @see {@link mergeAll}
     * @see {@link switch}
     * @see {@link zipAll}
     *
     * @return {Observable} An Observable emitting values from all the inner
     * Observables concatenated.
     * @method concatAll
     * @owner Observable
     */
    function concatAll() {
        return mergeAll_1.mergeAll(1);
    }
    var concatAll_2 = concatAll;


    var concatAll_1 = {
    	concatAll: concatAll_2
    };

    /* tslint:enable:max-line-length */
    /**
     * Creates an output Observable which sequentially emits all values from given
     * Observable and then moves on to the next.
     *
     * <span class="informal">Concatenates multiple Observables together by
     * sequentially emitting their values, one Observable after the other.</span>
     *
     * <img src="./img/concat.png" width="100%">
     *
     * `concat` joins multiple Observables together, by subscribing to them one at a time and
     * merging their results into the output Observable. You can pass either an array of
     * Observables, or put them directly as arguments. Passing an empty array will result
     * in Observable that completes immediately.
     *
     * `concat` will subscribe to first input Observable and emit all its values, without
     * changing or affecting them in any way. When that Observable completes, it will
     * subscribe to then next Observable passed and, again, emit its values. This will be
     * repeated, until the operator runs out of Observables. When last input Observable completes,
     * `concat` will complete as well. At any given moment only one Observable passed to operator
     * emits values. If you would like to emit values from passed Observables concurrently, check out
     * {@link merge} instead, especially with optional `concurrent` parameter. As a matter of fact,
     * `concat` is an equivalent of `merge` operator with `concurrent` parameter set to `1`.
     *
     * Note that if some input Observable never completes, `concat` will also never complete
     * and Observables following the one that did not complete will never be subscribed. On the other
     * hand, if some Observable simply completes immediately after it is subscribed, it will be
     * invisible for `concat`, which will just move on to the next Observable.
     *
     * If any Observable in chain errors, instead of passing control to the next Observable,
     * `concat` will error immediately as well. Observables that would be subscribed after
     * the one that emitted error, never will.
     *
     * If you pass to `concat` the same Observable many times, its stream of values
     * will be "replayed" on every subscription, which means you can repeat given Observable
     * as many times as you like. If passing the same Observable to `concat` 1000 times becomes tedious,
     * you can always use {@link repeat}.
     *
     * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>
     * var timer = Rx.Observable.interval(1000).take(4);
     * var sequence = Rx.Observable.range(1, 10);
     * var result = Rx.Observable.concat(timer, sequence);
     * result.subscribe(x => console.log(x));
     *
     * // results in:
     * // 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10
     *
     *
     * @example <caption>Concatenate an array of 3 Observables</caption>
     * var timer1 = Rx.Observable.interval(1000).take(10);
     * var timer2 = Rx.Observable.interval(2000).take(6);
     * var timer3 = Rx.Observable.interval(500).take(10);
     * var result = Rx.Observable.concat([timer1, timer2, timer3]); // note that array is passed
     * result.subscribe(x => console.log(x));
     *
     * // results in the following:
     * // (Prints to console sequentially)
     * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9
     * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5
     * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9
     *
     *
     * @example <caption>Concatenate the same Observable to repeat it</caption>
     * const timer = Rx.Observable.interval(1000).take(2);
     *
     * Rx.Observable.concat(timer, timer) // concating the same Observable!
     * .subscribe(
     *   value => console.log(value),
     *   err => {},
     *   () => console.log('...and it is done!')
     * );
     *
     * // Logs:
     * // 0 after 1s
     * // 1 after 2s
     * // 0 after 3s
     * // 1 after 4s
     * // "...and it is done!" also after 4s
     *
     * @see {@link concatAll}
     * @see {@link concatMap}
     * @see {@link concatMapTo}
     *
     * @param {ObservableInput} input1 An input Observable to concatenate with others.
     * @param {ObservableInput} input2 An input Observable to concatenate with others.
     * More than one input Observables may be given as argument.
     * @param {Scheduler} [scheduler=null] An optional IScheduler to schedule each
     * Observable subscription on.
     * @return {Observable} All values of each passed Observable merged into a
     * single Observable, in order, in serial fashion.
     * @static true
     * @name concat
     * @owner Observable
     */
    function concat() {
        var observables = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            observables[_i - 0] = arguments[_i];
        }
        if (observables.length === 1 || (observables.length === 2 && isScheduler_1.isScheduler(observables[1]))) {
            return from.from(observables[0]);
        }
        return concatAll_1.concatAll()(of.of.apply(void 0, observables));
    }
    var concat_2 = concat;


    var concat_1 = {
    	concat: concat_2
    };

    Observable_1.Observable.concat = concat_1.concat;

    var __extends$D = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };



    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @extends {Ignored}
     * @hide true
     */
    var DeferObservable = (function (_super) {
        __extends$D(DeferObservable, _super);
        function DeferObservable(observableFactory) {
            _super.call(this);
            this.observableFactory = observableFactory;
        }
        /**
         * Creates an Observable that, on subscribe, calls an Observable factory to
         * make an Observable for each new Observer.
         *
         * <span class="informal">Creates the Observable lazily, that is, only when it
         * is subscribed.
         * </span>
         *
         * <img src="./img/defer.png" width="100%">
         *
         * `defer` allows you to create the Observable only when the Observer
         * subscribes, and create a fresh Observable for each Observer. It waits until
         * an Observer subscribes to it, and then it generates an Observable,
         * typically with an Observable factory function. It does this afresh for each
         * subscriber, so although each subscriber may think it is subscribing to the
         * same Observable, in fact each subscriber gets its own individual
         * Observable.
         *
         * @example <caption>Subscribe to either an Observable of clicks or an Observable of interval, at random</caption>
         * var clicksOrInterval = Rx.Observable.defer(function () {
         *   if (Math.random() > 0.5) {
         *     return Rx.Observable.fromEvent(document, 'click');
         *   } else {
         *     return Rx.Observable.interval(1000);
         *   }
         * });
         * clicksOrInterval.subscribe(x => console.log(x));
         *
         * // Results in the following behavior:
         * // If the result of Math.random() is greater than 0.5 it will listen
         * // for clicks anywhere on the "document"; when document is clicked it
         * // will log a MouseEvent object to the console. If the result is less
         * // than 0.5 it will emit ascending numbers, one every second(1000ms).
         *
         * @see {@link create}
         *
         * @param {function(): SubscribableOrPromise} observableFactory The Observable
         * factory function to invoke for each Observer that subscribes to the output
         * Observable. May also return a Promise, which will be converted on the fly
         * to an Observable.
         * @return {Observable} An Observable whose Observers' subscriptions trigger
         * an invocation of the given Observable factory function.
         * @static true
         * @name defer
         * @owner Observable
         */
        DeferObservable.create = function (observableFactory) {
            return new DeferObservable(observableFactory);
        };
        /** @deprecated internal use only */ DeferObservable.prototype._subscribe = function (subscriber) {
            return new DeferSubscriber(subscriber, this.observableFactory);
        };
        return DeferObservable;
    }(Observable_1.Observable));
    var DeferObservable_2 = DeferObservable;
    var DeferSubscriber = (function (_super) {
        __extends$D(DeferSubscriber, _super);
        function DeferSubscriber(destination, factory) {
            _super.call(this, destination);
            this.factory = factory;
            this.tryDefer();
        }
        DeferSubscriber.prototype.tryDefer = function () {
            try {
                this._callFactory();
            }
            catch (err) {
                this._error(err);
            }
        };
        DeferSubscriber.prototype._callFactory = function () {
            var result = this.factory();
            if (result) {
                this.add(subscribeToResult_1.subscribeToResult(this, result));
            }
        };
        return DeferSubscriber;
    }(OuterSubscriber_1.OuterSubscriber));


    var DeferObservable_1 = {
    	DeferObservable: DeferObservable_2
    };

    var defer_1 = DeferObservable_1.DeferObservable.create;


    var defer = {
    	defer: defer_1
    };

    Observable_1.Observable.defer = defer.defer;

    var empty_1 = EmptyObservable_1.EmptyObservable.create;


    var empty$1 = {
    	empty: empty_1
    };

    Observable_1.Observable.empty = empty$1.empty;

    var __extends$E = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };





    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @extends {Ignored}
     * @hide true
     */
    var ForkJoinObservable = (function (_super) {
        __extends$E(ForkJoinObservable, _super);
        function ForkJoinObservable(sources, resultSelector) {
            _super.call(this);
            this.sources = sources;
            this.resultSelector = resultSelector;
        }
        /* tslint:enable:max-line-length */
        /**
         * Joins last values emitted by passed Observables.
         *
         * <span class="informal">Wait for Observables to complete and then combine last values they emitted.</span>
         *
         * <img src="./img/forkJoin.png" width="100%">
         *
         * `forkJoin` is an operator that takes any number of Observables which can be passed either as an array
         * or directly as arguments. If no input Observables are provided, resulting stream will complete
         * immediately.
         *
         * `forkJoin` will wait for all passed Observables to complete and then it will emit an array with last
         * values from corresponding Observables. So if you pass `n` Observables to the operator, resulting
         * array will have `n` values, where first value is the last thing emitted by the first Observable,
         * second value is the last thing emitted by the second Observable and so on. That means `forkJoin` will
         * not emit more than once and it will complete after that. If you need to emit combined values not only
         * at the end of lifecycle of passed Observables, but also throughout it, try out {@link combineLatest}
         * or {@link zip} instead.
         *
         * In order for resulting array to have the same length as the number of input Observables, whenever any of
         * that Observables completes without emitting any value, `forkJoin` will complete at that moment as well
         * and it will not emit anything either, even if it already has some last values from other Observables.
         * Conversely, if there is an Observable that never completes, `forkJoin` will never complete as well,
         * unless at any point some other Observable completes without emitting value, which brings us back to
         * the previous case. Overall, in order for `forkJoin` to emit a value, all Observables passed as arguments
         * have to emit something at least once and complete.
         *
         * If any input Observable errors at some point, `forkJoin` will error as well and all other Observables
         * will be immediately unsubscribed.
         *
         * Optionally `forkJoin` accepts project function, that will be called with values which normally
         * would land in emitted array. Whatever is returned by project function, will appear in output
         * Observable instead. This means that default project can be thought of as a function that takes
         * all its arguments and puts them into an array. Note that project function will be called only
         * when output Observable is supposed to emit a result.
         *
         * @example <caption>Use forkJoin with operator emitting immediately</caption>
         * const observable = Rx.Observable.forkJoin(
         *   Rx.Observable.of(1, 2, 3, 4),
         *   Rx.Observable.of(5, 6, 7, 8)
         * );
         * observable.subscribe(
         *   value => console.log(value),
         *   err => {},
         *   () => console.log('This is how it ends!')
         * );
         *
         * // Logs:
         * // [4, 8]
         * // "This is how it ends!"
         *
         *
         * @example <caption>Use forkJoin with operator emitting after some time</caption>
         * const observable = Rx.Observable.forkJoin(
         *   Rx.Observable.interval(1000).take(3), // emit 0, 1, 2 every second and complete
         *   Rx.Observable.interval(500).take(4) // emit 0, 1, 2, 3 every half a second and complete
         * );
         * observable.subscribe(
         *   value => console.log(value),
         *   err => {},
         *   () => console.log('This is how it ends!')
         * );
         *
         * // Logs:
         * // [2, 3] after 3 seconds
         * // "This is how it ends!" immediately after
         *
         *
         * @example <caption>Use forkJoin with project function</caption>
         * const observable = Rx.Observable.forkJoin(
         *   Rx.Observable.interval(1000).take(3), // emit 0, 1, 2 every second and complete
         *   Rx.Observable.interval(500).take(4), // emit 0, 1, 2, 3 every half a second and complete
         *   (n, m) => n + m
         * );
         * observable.subscribe(
         *   value => console.log(value),
         *   err => {},
         *   () => console.log('This is how it ends!')
         * );
         *
         * // Logs:
         * // 5 after 3 seconds
         * // "This is how it ends!" immediately after
         *
         * @see {@link combineLatest}
         * @see {@link zip}
         *
         * @param {...SubscribableOrPromise} sources Any number of Observables provided either as an array or as an arguments
         * passed directly to the operator.
         * @param {function} [project] Function that takes values emitted by input Observables and returns value
         * that will appear in resulting Observable instead of default array.
         * @return {Observable} Observable emitting either an array of last values emitted by passed Observables
         * or value from project function.
         * @static true
         * @name forkJoin
         * @owner Observable
         */
        ForkJoinObservable.create = function () {
            var sources = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                sources[_i - 0] = arguments[_i];
            }
            if (sources === null || arguments.length === 0) {
                return new EmptyObservable_1.EmptyObservable();
            }
            var resultSelector = null;
            if (typeof sources[sources.length - 1] === 'function') {
                resultSelector = sources.pop();
            }
            // if the first and only other argument besides the resultSelector is an array
            // assume it's been called with `forkJoin([obs1, obs2, obs3], resultSelector)`
            if (sources.length === 1 && isArray.isArray(sources[0])) {
                sources = sources[0];
            }
            if (sources.length === 0) {
                return new EmptyObservable_1.EmptyObservable();
            }
            return new ForkJoinObservable(sources, resultSelector);
        };
        /** @deprecated internal use only */ ForkJoinObservable.prototype._subscribe = function (subscriber) {
            return new ForkJoinSubscriber(subscriber, this.sources, this.resultSelector);
        };
        return ForkJoinObservable;
    }(Observable_1.Observable));
    var ForkJoinObservable_2 = ForkJoinObservable;
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var ForkJoinSubscriber = (function (_super) {
        __extends$E(ForkJoinSubscriber, _super);
        function ForkJoinSubscriber(destination, sources, resultSelector) {
            _super.call(this, destination);
            this.sources = sources;
            this.resultSelector = resultSelector;
            this.completed = 0;
            this.haveValues = 0;
            var len = sources.length;
            this.total = len;
            this.values = new Array(len);
            for (var i = 0; i < len; i++) {
                var source = sources[i];
                var innerSubscription = subscribeToResult_1.subscribeToResult(this, source, null, i);
                if (innerSubscription) {
                    innerSubscription.outerIndex = i;
                    this.add(innerSubscription);
                }
            }
        }
        ForkJoinSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
            this.values[outerIndex] = innerValue;
            if (!innerSub._hasValue) {
                innerSub._hasValue = true;
                this.haveValues++;
            }
        };
        ForkJoinSubscriber.prototype.notifyComplete = function (innerSub) {
            var destination = this.destination;
            var _a = this, haveValues = _a.haveValues, resultSelector = _a.resultSelector, values = _a.values;
            var len = values.length;
            if (!innerSub._hasValue) {
                destination.complete();
                return;
            }
            this.completed++;
            if (this.completed !== len) {
                return;
            }
            if (haveValues === len) {
                var value = resultSelector ? resultSelector.apply(this, values) : values;
                destination.next(value);
            }
            destination.complete();
        };
        return ForkJoinSubscriber;
    }(OuterSubscriber_1.OuterSubscriber));


    var ForkJoinObservable_1 = {
    	ForkJoinObservable: ForkJoinObservable_2
    };

    var forkJoin_1 = ForkJoinObservable_1.ForkJoinObservable.create;


    var forkJoin = {
    	forkJoin: forkJoin_1
    };

    Observable_1.Observable.forkJoin = forkJoin.forkJoin;

    Observable_1.Observable.from = from.from;

    var __extends$F = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };





    var toString = Object.prototype.toString;
    function isNodeStyleEventEmitter(sourceObj) {
        return !!sourceObj && typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function';
    }
    function isJQueryStyleEventEmitter(sourceObj) {
        return !!sourceObj && typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function';
    }
    function isNodeList(sourceObj) {
        return !!sourceObj && toString.call(sourceObj) === '[object NodeList]';
    }
    function isHTMLCollection(sourceObj) {
        return !!sourceObj && toString.call(sourceObj) === '[object HTMLCollection]';
    }
    function isEventTarget(sourceObj) {
        return !!sourceObj && typeof sourceObj.addEventListener === 'function' && typeof sourceObj.removeEventListener === 'function';
    }
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @extends {Ignored}
     * @hide true
     */
    var FromEventObservable = (function (_super) {
        __extends$F(FromEventObservable, _super);
        function FromEventObservable(sourceObj, eventName, selector, options) {
            _super.call(this);
            this.sourceObj = sourceObj;
            this.eventName = eventName;
            this.selector = selector;
            this.options = options;
        }
        /* tslint:enable:max-line-length */
        /**
         * Creates an Observable that emits events of a specific type coming from the
         * given event target.
         *
         * <span class="informal">Creates an Observable from DOM events, or Node.js
         * EventEmitter events or others.</span>
         *
         * <img src="./img/fromEvent.png" width="100%">
         *
         * `fromEvent` accepts as a first argument event target, which is an object with methods
         * for registering event handler functions. As a second argument it takes string that indicates
         * type of event we want to listen for. `fromEvent` supports selected types of event targets,
         * which are described in detail below. If your event target does not match any of the ones listed,
         * you should use {@link fromEventPattern}, which can be used on arbitrary APIs.
         * When it comes to APIs supported by `fromEvent`, their methods for adding and removing event
         * handler functions have different names, but they all accept a string describing event type
         * and function itself, which will be called whenever said event happens.
         *
         * Every time resulting Observable is subscribed, event handler function will be registered
         * to event target on given event type. When that event fires, value
         * passed as a first argument to registered function will be emitted by output Observable.
         * When Observable is unsubscribed, function will be unregistered from event target.
         *
         * Note that if event target calls registered function with more than one argument, second
         * and following arguments will not appear in resulting stream. In order to get access to them,
         * you can pass to `fromEvent` optional project function, which will be called with all arguments
         * passed to event handler. Output Observable will then emit value returned by project function,
         * instead of the usual value.
         *
         * Remember that event targets listed below are checked via duck typing. It means that
         * no matter what kind of object you have and no matter what environment you work in,
         * you can safely use `fromEvent` on that object if it exposes described methods (provided
         * of course they behave as was described above). So for example if Node.js library exposes
         * event target which has the same method names as DOM EventTarget, `fromEvent` is still
         * a good choice.
         *
         * If the API you use is more callback then event handler oriented (subscribed
         * callback function fires only once and thus there is no need to manually
         * unregister it), you should use {@link bindCallback} or {@link bindNodeCallback}
         * instead.
         *
         * `fromEvent` supports following types of event targets:
         *
         * **DOM EventTarget**
         *
         * This is an object with `addEventListener` and `removeEventListener` methods.
         *
         * In the browser, `addEventListener` accepts - apart from event type string and event
         * handler function arguments - optional third parameter, which is either an object or boolean,
         * both used for additional configuration how and when passed function will be called. When
         * `fromEvent` is used with event target of that type, you can provide this values
         * as third parameter as well.
         *
         * **Node.js EventEmitter**
         *
         * An object with `addListener` and `removeListener` methods.
         *
         * **JQuery-style event target**
         *
         * An object with `on` and `off` methods
         *
         * **DOM NodeList**
         *
         * List of DOM Nodes, returned for example by `document.querySelectorAll` or `Node.childNodes`.
         *
         * Although this collection is not event target in itself, `fromEvent` will iterate over all Nodes
         * it contains and install event handler function in every of them. When returned Observable
         * is unsubscribed, function will be removed from all Nodes.
         *
         * **DOM HtmlCollection**
         *
         * Just as in case of NodeList it is a collection of DOM nodes. Here as well event handler function is
         * installed and removed in each of elements.
         *
         *
         * @example <caption>Emits clicks happening on the DOM document</caption>
         * var clicks = Rx.Observable.fromEvent(document, 'click');
         * clicks.subscribe(x => console.log(x));
         *
         * // Results in:
         * // MouseEvent object logged to console every time a click
         * // occurs on the document.
         *
         *
         * @example <caption>Use addEventListener with capture option</caption>
         * var clicksInDocument = Rx.Observable.fromEvent(document, 'click', true); // note optional configuration parameter
         *                                                                          // which will be passed to addEventListener
         * var clicksInDiv = Rx.Observable.fromEvent(someDivInDocument, 'click');
         *
         * clicksInDocument.subscribe(() => console.log('document'));
         * clicksInDiv.subscribe(() => console.log('div'));
         *
         * // By default events bubble UP in DOM tree, so normally
         * // when we would click on div in document
         * // "div" would be logged first and then "document".
         * // Since we specified optional `capture` option, document
         * // will catch event when it goes DOWN DOM tree, so console
         * // will log "document" and then "div".
         *
         * @see {@link bindCallback}
         * @see {@link bindNodeCallback}
         * @see {@link fromEventPattern}
         *
         * @param {EventTargetLike} target The DOM EventTarget, Node.js
         * EventEmitter, JQuery-like event target, NodeList or HTMLCollection to attach the event handler to.
         * @param {string} eventName The event name of interest, being emitted by the
         * `target`.
         * @param {EventListenerOptions} [options] Options to pass through to addEventListener
         * @param {SelectorMethodSignature<T>} [selector] An optional function to
         * post-process results. It takes the arguments from the event handler and
         * should return a single value.
         * @return {Observable<T>}
         * @static true
         * @name fromEvent
         * @owner Observable
         */
        FromEventObservable.create = function (target, eventName, options, selector) {
            if (isFunction_1.isFunction(options)) {
                selector = options;
                options = undefined;
            }
            return new FromEventObservable(target, eventName, selector, options);
        };
        FromEventObservable.setupSubscription = function (sourceObj, eventName, handler, subscriber, options) {
            var unsubscribe;
            if (isNodeList(sourceObj) || isHTMLCollection(sourceObj)) {
                for (var i = 0, len = sourceObj.length; i < len; i++) {
                    FromEventObservable.setupSubscription(sourceObj[i], eventName, handler, subscriber, options);
                }
            }
            else if (isEventTarget(sourceObj)) {
                var source_1 = sourceObj;
                sourceObj.addEventListener(eventName, handler, options);
                unsubscribe = function () { return source_1.removeEventListener(eventName, handler, options); };
            }
            else if (isJQueryStyleEventEmitter(sourceObj)) {
                var source_2 = sourceObj;
                sourceObj.on(eventName, handler);
                unsubscribe = function () { return source_2.off(eventName, handler); };
            }
            else if (isNodeStyleEventEmitter(sourceObj)) {
                var source_3 = sourceObj;
                sourceObj.addListener(eventName, handler);
                unsubscribe = function () { return source_3.removeListener(eventName, handler); };
            }
            else {
                throw new TypeError('Invalid event target');
            }
            subscriber.add(new Subscription_1.Subscription(unsubscribe));
        };
        /** @deprecated internal use only */ FromEventObservable.prototype._subscribe = function (subscriber) {
            var sourceObj = this.sourceObj;
            var eventName = this.eventName;
            var options = this.options;
            var selector = this.selector;
            var handler = selector ? function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i - 0] = arguments[_i];
                }
                var result = tryCatch_1.tryCatch(selector).apply(void 0, args);
                if (result === errorObject.errorObject) {
                    subscriber.error(errorObject.errorObject.e);
                }
                else {
                    subscriber.next(result);
                }
            } : function (e) { return subscriber.next(e); };
            FromEventObservable.setupSubscription(sourceObj, eventName, handler, subscriber, options);
        };
        return FromEventObservable;
    }(Observable_1.Observable));
    var FromEventObservable_2 = FromEventObservable;


    var FromEventObservable_1 = {
    	FromEventObservable: FromEventObservable_2
    };

    var fromEvent_1 = FromEventObservable_1.FromEventObservable.create;


    var fromEvent = {
    	fromEvent: fromEvent_1
    };

    Observable_1.Observable.fromEvent = fromEvent.fromEvent;

    var __extends$G = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };



    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @extends {Ignored}
     * @hide true
     */
    var FromEventPatternObservable = (function (_super) {
        __extends$G(FromEventPatternObservable, _super);
        function FromEventPatternObservable(addHandler, removeHandler, selector) {
            _super.call(this);
            this.addHandler = addHandler;
            this.removeHandler = removeHandler;
            this.selector = selector;
        }
        /**
         * Creates an Observable from an API based on addHandler/removeHandler
         * functions.
         *
         * <span class="informal">Converts any addHandler/removeHandler API to an
         * Observable.</span>
         *
         * <img src="./img/fromEventPattern.png" width="100%">
         *
         * Creates an Observable by using the `addHandler` and `removeHandler`
         * functions to add and remove the handlers, with an optional selector
         * function to project the event arguments to a result. The `addHandler` is
         * called when the output Observable is subscribed, and `removeHandler` is
         * called when the Subscription is unsubscribed.
         *
         * @example <caption>Emits clicks happening on the DOM document</caption>
         * function addClickHandler(handler) {
         *   document.addEventListener('click', handler);
         * }
         *
         * function removeClickHandler(handler) {
         *   document.removeEventListener('click', handler);
         * }
         *
         * var clicks = Rx.Observable.fromEventPattern(
         *   addClickHandler,
         *   removeClickHandler
         * );
         * clicks.subscribe(x => console.log(x));
         *
         * @see {@link from}
         * @see {@link fromEvent}
         *
         * @param {function(handler: Function): any} addHandler A function that takes
         * a `handler` function as argument and attaches it somehow to the actual
         * source of events.
         * @param {function(handler: Function, signal?: any): void} [removeHandler] An optional function that
         * takes a `handler` function as argument and removes it in case it was
         * previously attached using `addHandler`. if addHandler returns signal to teardown when remove,
         * removeHandler function will forward it.
         * @param {function(...args: any): T} [selector] An optional function to
         * post-process results. It takes the arguments from the event handler and
         * should return a single value.
         * @return {Observable<T>}
         * @static true
         * @name fromEventPattern
         * @owner Observable
         */
        FromEventPatternObservable.create = function (addHandler, removeHandler, selector) {
            return new FromEventPatternObservable(addHandler, removeHandler, selector);
        };
        /** @deprecated internal use only */ FromEventPatternObservable.prototype._subscribe = function (subscriber) {
            var _this = this;
            var removeHandler = this.removeHandler;
            var handler = !!this.selector ? function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i - 0] = arguments[_i];
                }
                _this._callSelector(subscriber, args);
            } : function (e) { subscriber.next(e); };
            var retValue = this._callAddHandler(handler, subscriber);
            if (!isFunction_1.isFunction(removeHandler)) {
                return;
            }
            subscriber.add(new Subscription_1.Subscription(function () {
                //TODO: determine whether or not to forward to error handler
                removeHandler(handler, retValue);
            }));
        };
        FromEventPatternObservable.prototype._callSelector = function (subscriber, args) {
            try {
                var result = this.selector.apply(this, args);
                subscriber.next(result);
            }
            catch (e) {
                subscriber.error(e);
            }
        };
        FromEventPatternObservable.prototype._callAddHandler = function (handler, errorSubscriber) {
            try {
                return this.addHandler(handler) || null;
            }
            catch (e) {
                errorSubscriber.error(e);
            }
        };
        return FromEventPatternObservable;
    }(Observable_1.Observable));
    var FromEventPatternObservable_2 = FromEventPatternObservable;


    var FromEventPatternObservable_1 = {
    	FromEventPatternObservable: FromEventPatternObservable_2
    };

    var fromEventPattern_1 = FromEventPatternObservable_1.FromEventPatternObservable.create;


    var fromEventPattern = {
    	fromEventPattern: fromEventPattern_1
    };

    Observable_1.Observable.fromEventPattern = fromEventPattern.fromEventPattern;

    var fromPromise_1 = PromiseObservable_1.PromiseObservable.create;


    var fromPromise = {
    	fromPromise: fromPromise_1
    };

    Observable_1.Observable.fromPromise = fromPromise.fromPromise;

    var __extends$H = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };


    var selfSelector = function (value) { return value; };
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @extends {Ignored}
     * @hide true
     */
    var GenerateObservable = (function (_super) {
        __extends$H(GenerateObservable, _super);
        function GenerateObservable(initialState, condition, iterate, resultSelector, scheduler) {
            _super.call(this);
            this.initialState = initialState;
            this.condition = condition;
            this.iterate = iterate;
            this.resultSelector = resultSelector;
            this.scheduler = scheduler;
        }
        GenerateObservable.create = function (initialStateOrOptions, condition, iterate, resultSelectorOrObservable, scheduler) {
            if (arguments.length == 1) {
                return new GenerateObservable(initialStateOrOptions.initialState, initialStateOrOptions.condition, initialStateOrOptions.iterate, initialStateOrOptions.resultSelector || selfSelector, initialStateOrOptions.scheduler);
            }
            if (resultSelectorOrObservable === undefined || isScheduler_1.isScheduler(resultSelectorOrObservable)) {
                return new GenerateObservable(initialStateOrOptions, condition, iterate, selfSelector, resultSelectorOrObservable);
            }
            return new GenerateObservable(initialStateOrOptions, condition, iterate, resultSelectorOrObservable, scheduler);
        };
        /** @deprecated internal use only */ GenerateObservable.prototype._subscribe = function (subscriber) {
            var state = this.initialState;
            if (this.scheduler) {
                return this.scheduler.schedule(GenerateObservable.dispatch, 0, {
                    subscriber: subscriber,
                    iterate: this.iterate,
                    condition: this.condition,
                    resultSelector: this.resultSelector,
                    state: state });
            }
            var _a = this, condition = _a.condition, resultSelector = _a.resultSelector, iterate = _a.iterate;
            do {
                if (condition) {
                    var conditionResult = void 0;
                    try {
                        conditionResult = condition(state);
                    }
                    catch (err) {
                        subscriber.error(err);
                        return;
                    }
                    if (!conditionResult) {
                        subscriber.complete();
                        break;
                    }
                }
                var value = void 0;
                try {
                    value = resultSelector(state);
                }
                catch (err) {
                    subscriber.error(err);
                    return;
                }
                subscriber.next(value);
                if (subscriber.closed) {
                    break;
                }
                try {
                    state = iterate(state);
                }
                catch (err) {
                    subscriber.error(err);
                    return;
                }
            } while (true);
        };
        GenerateObservable.dispatch = function (state) {
            var subscriber = state.subscriber, condition = state.condition;
            if (subscriber.closed) {
                return;
            }
            if (state.needIterate) {
                try {
                    state.state = state.iterate(state.state);
                }
                catch (err) {
                    subscriber.error(err);
                    return;
                }
            }
            else {
                state.needIterate = true;
            }
            if (condition) {
                var conditionResult = void 0;
                try {
                    conditionResult = condition(state.state);
                }
                catch (err) {
                    subscriber.error(err);
                    return;
                }
                if (!conditionResult) {
                    subscriber.complete();
                    return;
                }
                if (subscriber.closed) {
                    return;
                }
            }
            var value;
            try {
                value = state.resultSelector(state.state);
            }
            catch (err) {
                subscriber.error(err);
                return;
            }
            if (subscriber.closed) {
                return;
            }
            subscriber.next(value);
            if (subscriber.closed) {
                return;
            }
            return this.schedule(state);
        };
        return GenerateObservable;
    }(Observable_1.Observable));
    var GenerateObservable_2 = GenerateObservable;


    var GenerateObservable_1 = {
    	GenerateObservable: GenerateObservable_2
    };

    var generate_1 = GenerateObservable_1.GenerateObservable.create;


    var generate = {
    	generate: generate_1
    };

    Observable_1.Observable.generate = generate.generate;

    var __extends$I = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };



    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @extends {Ignored}
     * @hide true
     */
    var IfObservable = (function (_super) {
        __extends$I(IfObservable, _super);
        function IfObservable(condition, thenSource, elseSource) {
            _super.call(this);
            this.condition = condition;
            this.thenSource = thenSource;
            this.elseSource = elseSource;
        }
        IfObservable.create = function (condition, thenSource, elseSource) {
            return new IfObservable(condition, thenSource, elseSource);
        };
        /** @deprecated internal use only */ IfObservable.prototype._subscribe = function (subscriber) {
            var _a = this, condition = _a.condition, thenSource = _a.thenSource, elseSource = _a.elseSource;
            return new IfSubscriber(subscriber, condition, thenSource, elseSource);
        };
        return IfObservable;
    }(Observable_1.Observable));
    var IfObservable_2 = IfObservable;
    var IfSubscriber = (function (_super) {
        __extends$I(IfSubscriber, _super);
        function IfSubscriber(destination, condition, thenSource, elseSource) {
            _super.call(this, destination);
            this.condition = condition;
            this.thenSource = thenSource;
            this.elseSource = elseSource;
            this.tryIf();
        }
        IfSubscriber.prototype.tryIf = function () {
            var _a = this, condition = _a.condition, thenSource = _a.thenSource, elseSource = _a.elseSource;
            var result;
            try {
                result = condition();
                var source = result ? thenSource : elseSource;
                if (source) {
                    this.add(subscribeToResult_1.subscribeToResult(this, source));
                }
                else {
                    this._complete();
                }
            }
            catch (err) {
                this._error(err);
            }
        };
        return IfSubscriber;
    }(OuterSubscriber_1.OuterSubscriber));


    var IfObservable_1 = {
    	IfObservable: IfObservable_2
    };

    var _if_1 = IfObservable_1.IfObservable.create;


    var _if = {
    	_if: _if_1
    };

    Observable_1.Observable.if = _if._if;

    function isNumeric(val) {
        // parseFloat NaNs numeric-cast false positives (null|true|false|"")
        // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
        // subtraction forces infinities to NaN
        // adding 1 corrects loss of precision from parseFloat (#15100)
        return !isArray.isArray(val) && (val - parseFloat(val) + 1) >= 0;
    }
    var isNumeric_2 = isNumeric;


    var isNumeric_1 = {
    	isNumeric: isNumeric_2
    };

    var __extends$J = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };

    /**
     * A unit of work to be executed in a {@link Scheduler}. An action is typically
     * created from within a Scheduler and an RxJS user does not need to concern
     * themselves about creating and manipulating an Action.
     *
     * ```ts
     * class Action<T> extends Subscription {
     *   new (scheduler: Scheduler, work: (state?: T) => void);
     *   schedule(state?: T, delay: number = 0): Subscription;
     * }
     * ```
     *
     * @class Action<T>
     */
    var Action$1 = (function (_super) {
        __extends$J(Action, _super);
        function Action(scheduler, work) {
            _super.call(this);
        }
        /**
         * Schedules this action on its parent Scheduler for execution. May be passed
         * some context object, `state`. May happen at some point in the future,
         * according to the `delay` parameter, if specified.
         * @param {T} [state] Some contextual data that the `work` function uses when
         * called by the Scheduler.
         * @param {number} [delay] Time to wait before executing the work, where the
         * time unit is implicit and defined by the Scheduler.
         * @return {void}
         */
        Action.prototype.schedule = function (state, delay) {
            if (delay === void 0) { delay = 0; }
            return this;
        };
        return Action;
    }(Subscription_1.Subscription));
    var Action_2 = Action$1;


    var Action_1 = {
    	Action: Action_2
    };

    var __extends$K = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };


    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var AsyncAction = (function (_super) {
        __extends$K(AsyncAction, _super);
        function AsyncAction(scheduler, work) {
            _super.call(this, scheduler, work);
            this.scheduler = scheduler;
            this.work = work;
            this.pending = false;
        }
        AsyncAction.prototype.schedule = function (state, delay) {
            if (delay === void 0) { delay = 0; }
            if (this.closed) {
                return this;
            }
            // Always replace the current state with the new state.
            this.state = state;
            // Set the pending flag indicating that this action has been scheduled, or
            // has recursively rescheduled itself.
            this.pending = true;
            var id = this.id;
            var scheduler = this.scheduler;
            //
            // Important implementation note:
            //
            // Actions only execute once by default, unless rescheduled from within the
            // scheduled callback. This allows us to implement single and repeat
            // actions via the same code path, without adding API surface area, as well
            // as mimic traditional recursion but across asynchronous boundaries.
            //
            // However, JS runtimes and timers distinguish between intervals achieved by
            // serial `setTimeout` calls vs. a single `setInterval` call. An interval of
            // serial `setTimeout` calls can be individually delayed, which delays
            // scheduling the next `setTimeout`, and so on. `setInterval` attempts to
            // guarantee the interval callback will be invoked more precisely to the
            // interval period, regardless of load.
            //
            // Therefore, we use `setInterval` to schedule single and repeat actions.
            // If the action reschedules itself with the same delay, the interval is not
            // canceled. If the action doesn't reschedule, or reschedules with a
            // different delay, the interval will be canceled after scheduled callback
            // execution.
            //
            if (id != null) {
                this.id = this.recycleAsyncId(scheduler, id, delay);
            }
            this.delay = delay;
            // If this action has already an async Id, don't request a new one.
            this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);
            return this;
        };
        AsyncAction.prototype.requestAsyncId = function (scheduler, id, delay) {
            if (delay === void 0) { delay = 0; }
            return root.root.setInterval(scheduler.flush.bind(scheduler, this), delay);
        };
        AsyncAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
            if (delay === void 0) { delay = 0; }
            // If this action is rescheduled with the same delay time, don't clear the interval id.
            if (delay !== null && this.delay === delay && this.pending === false) {
                return id;
            }
            // Otherwise, if the action's delay time is different from the current delay,
            // or the action has been rescheduled before it's executed, clear the interval id
            return root.root.clearInterval(id) && undefined || undefined;
        };
        /**
         * Immediately executes this action and the `work` it contains.
         * @return {any}
         */
        AsyncAction.prototype.execute = function (state, delay) {
            if (this.closed) {
                return new Error('executing a cancelled action');
            }
            this.pending = false;
            var error = this._execute(state, delay);
            if (error) {
                return error;
            }
            else if (this.pending === false && this.id != null) {
                // Dequeue if the action didn't reschedule itself. Don't call
                // unsubscribe(), because the action could reschedule later.
                // For example:
                // ```
                // scheduler.schedule(function doWork(counter) {
                //   /* ... I'm a busy worker bee ... */
                //   var originalAction = this;
                //   /* wait 100ms before rescheduling the action */
                //   setTimeout(function () {
                //     originalAction.schedule(counter + 1);
                //   }, 100);
                // }, 1000);
                // ```
                this.id = this.recycleAsyncId(this.scheduler, this.id, null);
            }
        };
        AsyncAction.prototype._execute = function (state, delay) {
            var errored = false;
            var errorValue = undefined;
            try {
                this.work(state);
            }
            catch (e) {
                errored = true;
                errorValue = !!e && e || new Error(e);
            }
            if (errored) {
                this.unsubscribe();
                return errorValue;
            }
        };
        /** @deprecated internal use only */ AsyncAction.prototype._unsubscribe = function () {
            var id = this.id;
            var scheduler = this.scheduler;
            var actions = scheduler.actions;
            var index = actions.indexOf(this);
            this.work = null;
            this.state = null;
            this.pending = false;
            this.scheduler = null;
            if (index !== -1) {
                actions.splice(index, 1);
            }
            if (id != null) {
                this.id = this.recycleAsyncId(scheduler, id, null);
            }
            this.delay = null;
        };
        return AsyncAction;
    }(Action_1.Action));
    var AsyncAction_2 = AsyncAction;


    var AsyncAction_1 = {
    	AsyncAction: AsyncAction_2
    };

    /**
     * An execution context and a data structure to order tasks and schedule their
     * execution. Provides a notion of (potentially virtual) time, through the
     * `now()` getter method.
     *
     * Each unit of work in a Scheduler is called an {@link Action}.
     *
     * ```ts
     * class Scheduler {
     *   now(): number;
     *   schedule(work, delay?, state?): Subscription;
     * }
     * ```
     *
     * @class Scheduler
     */
    var Scheduler = (function () {
        function Scheduler(SchedulerAction, now) {
            if (now === void 0) { now = Scheduler.now; }
            this.SchedulerAction = SchedulerAction;
            this.now = now;
        }
        /**
         * Schedules a function, `work`, for execution. May happen at some point in
         * the future, according to the `delay` parameter, if specified. May be passed
         * some context object, `state`, which will be passed to the `work` function.
         *
         * The given arguments will be processed an stored as an Action object in a
         * queue of actions.
         *
         * @param {function(state: ?T): ?Subscription} work A function representing a
         * task, or some unit of work to be executed by the Scheduler.
         * @param {number} [delay] Time to wait before executing the work, where the
         * time unit is implicit and defined by the Scheduler itself.
         * @param {T} [state] Some contextual data that the `work` function uses when
         * called by the Scheduler.
         * @return {Subscription} A subscription in order to be able to unsubscribe
         * the scheduled work.
         */
        Scheduler.prototype.schedule = function (work, delay, state) {
            if (delay === void 0) { delay = 0; }
            return new this.SchedulerAction(this, work).schedule(state, delay);
        };
        Scheduler.now = Date.now ? Date.now : function () { return +new Date(); };
        return Scheduler;
    }());
    var Scheduler_2 = Scheduler;


    var Scheduler_1 = {
    	Scheduler: Scheduler_2
    };

    var __extends$L = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };

    var AsyncScheduler = (function (_super) {
        __extends$L(AsyncScheduler, _super);
        function AsyncScheduler() {
            _super.apply(this, arguments);
            this.actions = [];
            /**
             * A flag to indicate whether the Scheduler is currently executing a batch of
             * queued actions.
             * @type {boolean}
             */
            this.active = false;
            /**
             * An internal ID used to track the latest asynchronous task such as those
             * coming from `setTimeout`, `setInterval`, `requestAnimationFrame`, and
             * others.
             * @type {any}
             */
            this.scheduled = undefined;
        }
        AsyncScheduler.prototype.flush = function (action) {
            var actions = this.actions;
            if (this.active) {
                actions.push(action);
                return;
            }
            var error;
            this.active = true;
            do {
                if (error = action.execute(action.state, action.delay)) {
                    break;
                }
            } while (action = actions.shift()); // exhaust the scheduler queue
            this.active = false;
            if (error) {
                while (action = actions.shift()) {
                    action.unsubscribe();
                }
                throw error;
            }
        };
        return AsyncScheduler;
    }(Scheduler_1.Scheduler));
    var AsyncScheduler_2 = AsyncScheduler;


    var AsyncScheduler_1 = {
    	AsyncScheduler: AsyncScheduler_2
    };

    /**
     *
     * Async Scheduler
     *
     * <span class="informal">Schedule task as if you used setTimeout(task, duration)</span>
     *
     * `async` scheduler schedules tasks asynchronously, by putting them on the JavaScript
     * event loop queue. It is best used to delay tasks in time or to schedule tasks repeating
     * in intervals.
     *
     * If you just want to "defer" task, that is to perform it right after currently
     * executing synchronous code ends (commonly achieved by `setTimeout(deferredTask, 0)`),
     * better choice will be the {@link asap} scheduler.
     *
     * @example <caption>Use async scheduler to delay task</caption>
     * const task = () => console.log('it works!');
     *
     * Rx.Scheduler.async.schedule(task, 2000);
     *
     * // After 2 seconds logs:
     * // "it works!"
     *
     *
     * @example <caption>Use async scheduler to repeat task in intervals</caption>
     * function task(state) {
     *   console.log(state);
     *   this.schedule(state + 1, 1000); // `this` references currently executing Action,
     *                                   // which we reschedule with new state and delay
     * }
     *
     * Rx.Scheduler.async.schedule(task, 3000, 0);
     *
     * // Logs:
     * // 0 after 3s
     * // 1 after 4s
     * // 2 after 5s
     * // 3 after 6s
     *
     * @static true
     * @name async
     * @owner Scheduler
     */
    var async_1 = new AsyncScheduler_1.AsyncScheduler(AsyncAction_1.AsyncAction);


    var async = {
    	async: async_1
    };

    var __extends$M = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };



    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @extends {Ignored}
     * @hide true
     */
    var IntervalObservable = (function (_super) {
        __extends$M(IntervalObservable, _super);
        function IntervalObservable(period, scheduler) {
            if (period === void 0) { period = 0; }
            if (scheduler === void 0) { scheduler = async.async; }
            _super.call(this);
            this.period = period;
            this.scheduler = scheduler;
            if (!isNumeric_1.isNumeric(period) || period < 0) {
                this.period = 0;
            }
            if (!scheduler || typeof scheduler.schedule !== 'function') {
                this.scheduler = async.async;
            }
        }
        /**
         * Creates an Observable that emits sequential numbers every specified
         * interval of time, on a specified IScheduler.
         *
         * <span class="informal">Emits incremental numbers periodically in time.
         * </span>
         *
         * <img src="./img/interval.png" width="100%">
         *
         * `interval` returns an Observable that emits an infinite sequence of
         * ascending integers, with a constant interval of time of your choosing
         * between those emissions. The first emission is not sent immediately, but
         * only after the first period has passed. By default, this operator uses the
         * `async` IScheduler to provide a notion of time, but you may pass any
         * IScheduler to it.
         *
         * @example <caption>Emits ascending numbers, one every second (1000ms)</caption>
         * var numbers = Rx.Observable.interval(1000);
         * numbers.subscribe(x => console.log(x));
         *
         * @see {@link timer}
         * @see {@link delay}
         *
         * @param {number} [period=0] The interval size in milliseconds (by default)
         * or the time unit determined by the scheduler's clock.
         * @param {Scheduler} [scheduler=async] The IScheduler to use for scheduling
         * the emission of values, and providing a notion of "time".
         * @return {Observable} An Observable that emits a sequential number each time
         * interval.
         * @static true
         * @name interval
         * @owner Observable
         */
        IntervalObservable.create = function (period, scheduler) {
            if (period === void 0) { period = 0; }
            if (scheduler === void 0) { scheduler = async.async; }
            return new IntervalObservable(period, scheduler);
        };
        IntervalObservable.dispatch = function (state) {
            var index = state.index, subscriber = state.subscriber, period = state.period;
            subscriber.next(index);
            if (subscriber.closed) {
                return;
            }
            state.index += 1;
            this.schedule(state, period);
        };
        /** @deprecated internal use only */ IntervalObservable.prototype._subscribe = function (subscriber) {
            var index = 0;
            var period = this.period;
            var scheduler = this.scheduler;
            subscriber.add(scheduler.schedule(IntervalObservable.dispatch, period, {
                index: index, subscriber: subscriber, period: period
            }));
        };
        return IntervalObservable;
    }(Observable_1.Observable));
    var IntervalObservable_2 = IntervalObservable;


    var IntervalObservable_1 = {
    	IntervalObservable: IntervalObservable_2
    };

    var interval_1 = IntervalObservable_1.IntervalObservable.create;


    var interval = {
    	interval: interval_1
    };

    Observable_1.Observable.interval = interval.interval;

    /* tslint:enable:max-line-length */
    /**
     * Creates an output Observable which concurrently emits all values from every
     * given input Observable.
     *
     * <span class="informal">Flattens multiple Observables together by blending
     * their values into one Observable.</span>
     *
     * <img src="./img/merge.png" width="100%">
     *
     * `merge` subscribes to each given input Observable (as arguments), and simply
     * forwards (without doing any transformation) all the values from all the input
     * Observables to the output Observable. The output Observable only completes
     * once all input Observables have completed. Any error delivered by an input
     * Observable will be immediately emitted on the output Observable.
     *
     * @example <caption>Merge together two Observables: 1s interval and clicks</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var timer = Rx.Observable.interval(1000);
     * var clicksOrTimer = Rx.Observable.merge(clicks, timer);
     * clicksOrTimer.subscribe(x => console.log(x));
     *
     * // Results in the following:
     * // timer will emit ascending values, one every second(1000ms) to console
     * // clicks logs MouseEvents to console everytime the "document" is clicked
     * // Since the two streams are merged you see these happening
     * // as they occur.
     *
     * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>
     * var timer1 = Rx.Observable.interval(1000).take(10);
     * var timer2 = Rx.Observable.interval(2000).take(6);
     * var timer3 = Rx.Observable.interval(500).take(10);
     * var concurrent = 2; // the argument
     * var merged = Rx.Observable.merge(timer1, timer2, timer3, concurrent);
     * merged.subscribe(x => console.log(x));
     *
     * // Results in the following:
     * // - First timer1 and timer2 will run concurrently
     * // - timer1 will emit a value every 1000ms for 10 iterations
     * // - timer2 will emit a value every 2000ms for 6 iterations
     * // - after timer1 hits it's max iteration, timer2 will
     * //   continue, and timer3 will start to run concurrently with timer2
     * // - when timer2 hits it's max iteration it terminates, and
     * //   timer3 will continue to emit a value every 500ms until it is complete
     *
     * @see {@link mergeAll}
     * @see {@link mergeMap}
     * @see {@link mergeMapTo}
     * @see {@link mergeScan}
     *
     * @param {...ObservableInput} observables Input Observables to merge together.
     * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
     * Observables being subscribed to concurrently.
     * @param {Scheduler} [scheduler=null] The IScheduler to use for managing
     * concurrency of input Observables.
     * @return {Observable} an Observable that emits items that are the result of
     * every input Observable.
     * @static true
     * @name merge
     * @owner Observable
     */
    function merge() {
        var observables = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            observables[_i - 0] = arguments[_i];
        }
        var concurrent = Number.POSITIVE_INFINITY;
        var scheduler = null;
        var last = observables[observables.length - 1];
        if (isScheduler_1.isScheduler(last)) {
            scheduler = observables.pop();
            if (observables.length > 1 && typeof observables[observables.length - 1] === 'number') {
                concurrent = observables.pop();
            }
        }
        else if (typeof last === 'number') {
            concurrent = observables.pop();
        }
        if (scheduler === null && observables.length === 1 && observables[0] instanceof Observable_1.Observable) {
            return observables[0];
        }
        return mergeAll_1.mergeAll(concurrent)(new ArrayObservable_1.ArrayObservable(observables, scheduler));
    }
    var merge_2 = merge;


    var merge_1 = {
    	merge: merge_2
    };

    Observable_1.Observable.merge = merge_1.merge;

    var __extends$N = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };




    function race() {
        var observables = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            observables[_i - 0] = arguments[_i];
        }
        // if the only argument is an array, it was most likely called with
        // `race([obs1, obs2, ...])`
        if (observables.length === 1) {
            if (isArray.isArray(observables[0])) {
                observables = observables[0];
            }
            else {
                return observables[0];
            }
        }
        return new ArrayObservable_1.ArrayObservable(observables).lift(new RaceOperator());
    }
    var race_2 = race;
    var RaceOperator = (function () {
        function RaceOperator() {
        }
        RaceOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(new RaceSubscriber(subscriber));
        };
        return RaceOperator;
    }());
    var RaceOperator_1 = RaceOperator;
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var RaceSubscriber = (function (_super) {
        __extends$N(RaceSubscriber, _super);
        function RaceSubscriber(destination) {
            _super.call(this, destination);
            this.hasFirst = false;
            this.observables = [];
            this.subscriptions = [];
        }
        RaceSubscriber.prototype._next = function (observable) {
            this.observables.push(observable);
        };
        RaceSubscriber.prototype._complete = function () {
            var observables = this.observables;
            var len = observables.length;
            if (len === 0) {
                this.destination.complete();
            }
            else {
                for (var i = 0; i < len && !this.hasFirst; i++) {
                    var observable = observables[i];
                    var subscription = subscribeToResult_1.subscribeToResult(this, observable, observable, i);
                    if (this.subscriptions) {
                        this.subscriptions.push(subscription);
                    }
                    this.add(subscription);
                }
                this.observables = null;
            }
        };
        RaceSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
            if (!this.hasFirst) {
                this.hasFirst = true;
                for (var i = 0; i < this.subscriptions.length; i++) {
                    if (i !== outerIndex) {
                        var subscription = this.subscriptions[i];
                        subscription.unsubscribe();
                        this.remove(subscription);
                    }
                }
                this.subscriptions = null;
            }
            this.destination.next(innerValue);
        };
        return RaceSubscriber;
    }(OuterSubscriber_1.OuterSubscriber));
    var RaceSubscriber_1 = RaceSubscriber;


    var race_1 = {
    	race: race_2,
    	RaceOperator: RaceOperator_1,
    	RaceSubscriber: RaceSubscriber_1
    };

    Observable_1.Observable.race = race_1.race;

    var __extends$O = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };


    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @extends {Ignored}
     * @hide true
     */
    var NeverObservable = (function (_super) {
        __extends$O(NeverObservable, _super);
        function NeverObservable() {
            _super.call(this);
        }
        /**
         * Creates an Observable that emits no items to the Observer.
         *
         * <span class="informal">An Observable that never emits anything.</span>
         *
         * <img src="./img/never.png" width="100%">
         *
         * This static operator is useful for creating a simple Observable that emits
         * neither values nor errors nor the completion notification. It can be used
         * for testing purposes or for composing with other Observables. Please note
         * that by never emitting a complete notification, this Observable keeps the
         * subscription from being disposed automatically. Subscriptions need to be
         * manually disposed.
         *
         * @example <caption>Emit the number 7, then never emit anything else (not even complete).</caption>
         * function info() {
         *   console.log('Will not be called');
         * }
         * var result = Rx.Observable.never().startWith(7);
         * result.subscribe(x => console.log(x), info, info);
         *
         * @see {@link create}
         * @see {@link empty}
         * @see {@link of}
         * @see {@link throw}
         *
         * @return {Observable} A "never" Observable: never emits anything.
         * @static true
         * @name never
         * @owner Observable
         */
        NeverObservable.create = function () {
            return new NeverObservable();
        };
        /** @deprecated internal use only */ NeverObservable.prototype._subscribe = function (subscriber) {
        };
        return NeverObservable;
    }(Observable_1.Observable));
    var NeverObservable_2 = NeverObservable;


    var NeverObservable_1 = {
    	NeverObservable: NeverObservable_2
    };

    var never_1 = NeverObservable_1.NeverObservable.create;


    var never = {
    	never: never_1
    };

    Observable_1.Observable.never = never.never;

    Observable_1.Observable.of = of.of;

    var __extends$P = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };




    /* tslint:enable:max-line-length */
    /**
     * When any of the provided Observable emits an complete or error notification, it immediately subscribes to the next one
     * that was passed.
     *
     * <span class="informal">Execute series of Observables no matter what, even if it means swallowing errors.</span>
     *
     * <img src="./img/onErrorResumeNext.png" width="100%">
     *
     * `onErrorResumeNext` is an operator that accepts a series of Observables, provided either directly as
     * arguments or as an array. If no single Observable is provided, returned Observable will simply behave the same
     * as the source.
     *
     * `onErrorResumeNext` returns an Observable that starts by subscribing and re-emitting values from the source Observable.
     * When its stream of values ends - no matter if Observable completed or emitted an error - `onErrorResumeNext`
     * will subscribe to the first Observable that was passed as an argument to the method. It will start re-emitting
     * its values as well and - again - when that stream ends, `onErrorResumeNext` will proceed to subscribing yet another
     * Observable in provided series, no matter if previous Observable completed or ended with an error. This will
     * be happening until there is no more Observables left in the series, at which point returned Observable will
     * complete - even if the last subscribed stream ended with an error.
     *
     * `onErrorResumeNext` can be therefore thought of as version of {@link concat} operator, which is more permissive
     * when it comes to the errors emitted by its input Observables. While `concat` subscribes to the next Observable
     * in series only if previous one successfully completed, `onErrorResumeNext` subscribes even if it ended with
     * an error.
     *
     * Note that you do not get any access to errors emitted by the Observables. In particular do not
     * expect these errors to appear in error callback passed to {@link subscribe}. If you want to take
     * specific actions based on what error was emitted by an Observable, you should try out {@link catch} instead.
     *
     *
     * @example <caption>Subscribe to the next Observable after map fails</caption>
     * Rx.Observable.of(1, 2, 3, 0)
     *   .map(x => {
     *       if (x === 0) { throw Error(); }
             return 10 / x;
     *   })
     *   .onErrorResumeNext(Rx.Observable.of(1, 2, 3))
     *   .subscribe(
     *     val => console.log(val),
     *     err => console.log(err),          // Will never be called.
     *     () => console.log('that\'s it!')
     *   );
     *
     * // Logs:
     * // 10
     * // 5
     * // 3.3333333333333335
     * // 1
     * // 2
     * // 3
     * // "that's it!"
     *
     * @see {@link concat}
     * @see {@link catch}
     *
     * @param {...ObservableInput} observables Observables passed either directly or as an array.
     * @return {Observable} An Observable that emits values from source Observable, but - if it errors - subscribes
     * to the next passed Observable and so on, until it completes or runs out of Observables.
     * @method onErrorResumeNext
     * @owner Observable
     */
    function onErrorResumeNext() {
        var nextSources = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            nextSources[_i - 0] = arguments[_i];
        }
        if (nextSources.length === 1 && isArray.isArray(nextSources[0])) {
            nextSources = nextSources[0];
        }
        return function (source) { return source.lift(new OnErrorResumeNextOperator(nextSources)); };
    }
    var onErrorResumeNext_2 = onErrorResumeNext;
    /* tslint:enable:max-line-length */
    function onErrorResumeNextStatic() {
        var nextSources = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            nextSources[_i - 0] = arguments[_i];
        }
        var source = null;
        if (nextSources.length === 1 && isArray.isArray(nextSources[0])) {
            nextSources = nextSources[0];
        }
        source = nextSources.shift();
        return new FromObservable_1.FromObservable(source, null).lift(new OnErrorResumeNextOperator(nextSources));
    }
    var onErrorResumeNextStatic_1 = onErrorResumeNextStatic;
    var OnErrorResumeNextOperator = (function () {
        function OnErrorResumeNextOperator(nextSources) {
            this.nextSources = nextSources;
        }
        OnErrorResumeNextOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(new OnErrorResumeNextSubscriber(subscriber, this.nextSources));
        };
        return OnErrorResumeNextOperator;
    }());
    var OnErrorResumeNextSubscriber = (function (_super) {
        __extends$P(OnErrorResumeNextSubscriber, _super);
        function OnErrorResumeNextSubscriber(destination, nextSources) {
            _super.call(this, destination);
            this.destination = destination;
            this.nextSources = nextSources;
        }
        OnErrorResumeNextSubscriber.prototype.notifyError = function (error, innerSub) {
            this.subscribeToNextSource();
        };
        OnErrorResumeNextSubscriber.prototype.notifyComplete = function (innerSub) {
            this.subscribeToNextSource();
        };
        OnErrorResumeNextSubscriber.prototype._error = function (err) {
            this.subscribeToNextSource();
        };
        OnErrorResumeNextSubscriber.prototype._complete = function () {
            this.subscribeToNextSource();
        };
        OnErrorResumeNextSubscriber.prototype.subscribeToNextSource = function () {
            var next = this.nextSources.shift();
            if (next) {
                this.add(subscribeToResult_1.subscribeToResult(this, next));
            }
            else {
                this.destination.complete();
            }
        };
        return OnErrorResumeNextSubscriber;
    }(OuterSubscriber_1.OuterSubscriber));


    var onErrorResumeNext_1 = {
    	onErrorResumeNext: onErrorResumeNext_2,
    	onErrorResumeNextStatic: onErrorResumeNextStatic_1
    };

    var onErrorResumeNext_2$1 = onErrorResumeNext_1.onErrorResumeNextStatic;


    var onErrorResumeNext$1 = {
    	onErrorResumeNext: onErrorResumeNext_2$1
    };

    Observable_1.Observable.onErrorResumeNext = onErrorResumeNext$1.onErrorResumeNext;

    var __extends$Q = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };

    function dispatch$1(state) {
        var obj = state.obj, keys = state.keys, length = state.length, index = state.index, subscriber = state.subscriber;
        if (index === length) {
            subscriber.complete();
            return;
        }
        var key = keys[index];
        subscriber.next([key, obj[key]]);
        state.index = index + 1;
        this.schedule(state);
    }
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @extends {Ignored}
     * @hide true
     */
    var PairsObservable = (function (_super) {
        __extends$Q(PairsObservable, _super);
        function PairsObservable(obj, scheduler) {
            _super.call(this);
            this.obj = obj;
            this.scheduler = scheduler;
            this.keys = Object.keys(obj);
        }
        /**
         * Convert an object into an observable sequence of [key, value] pairs
         * using an optional IScheduler to enumerate the object.
         *
         * @example <caption>Converts a javascript object to an Observable</caption>
         * var obj = {
         *   foo: 42,
         *   bar: 56,
         *   baz: 78
         * };
         *
         * var source = Rx.Observable.pairs(obj);
         *
         * var subscription = source.subscribe(
         *   function (x) {
         *     console.log('Next: %s', x);
         *   },
         *   function (err) {
         *     console.log('Error: %s', err);
         *   },
         *   function () {
         *     console.log('Completed');
         *   });
         *
         * @param {Object} obj The object to inspect and turn into an
         * Observable sequence.
         * @param {Scheduler} [scheduler] An optional IScheduler to run the
         * enumeration of the input sequence on.
         * @returns {(Observable<Array<string | T>>)} An observable sequence of
         * [key, value] pairs from the object.
         */
        PairsObservable.create = function (obj, scheduler) {
            return new PairsObservable(obj, scheduler);
        };
        /** @deprecated internal use only */ PairsObservable.prototype._subscribe = function (subscriber) {
            var _a = this, keys = _a.keys, scheduler = _a.scheduler;
            var length = keys.length;
            if (scheduler) {
                return scheduler.schedule(dispatch$1, 0, {
                    obj: this.obj, keys: keys, length: length, index: 0, subscriber: subscriber
                });
            }
            else {
                for (var idx = 0; idx < length; idx++) {
                    var key = keys[idx];
                    subscriber.next([key, this.obj[key]]);
                }
                subscriber.complete();
            }
        };
        return PairsObservable;
    }(Observable_1.Observable));
    var PairsObservable_2 = PairsObservable;


    var PairsObservable_1 = {
    	PairsObservable: PairsObservable_2
    };

    var pairs_1 = PairsObservable_1.PairsObservable.create;


    var pairs = {
    	pairs: pairs_1
    };

    Observable_1.Observable.pairs = pairs.pairs;

    var __extends$R = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };

    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @extends {Ignored}
     * @hide true
     */
    var RangeObservable = (function (_super) {
        __extends$R(RangeObservable, _super);
        function RangeObservable(start, count, scheduler) {
            _super.call(this);
            this.start = start;
            this._count = count;
            this.scheduler = scheduler;
        }
        /**
         * Creates an Observable that emits a sequence of numbers within a specified
         * range.
         *
         * <span class="informal">Emits a sequence of numbers in a range.</span>
         *
         * <img src="./img/range.png" width="100%">
         *
         * `range` operator emits a range of sequential integers, in order, where you
         * select the `start` of the range and its `length`. By default, uses no
         * IScheduler and just delivers the notifications synchronously, but may use
         * an optional IScheduler to regulate those deliveries.
         *
         * @example <caption>Emits the numbers 1 to 10</caption>
         * var numbers = Rx.Observable.range(1, 10);
         * numbers.subscribe(x => console.log(x));
         *
         * @see {@link timer}
         * @see {@link interval}
         *
         * @param {number} [start=0] The value of the first integer in the sequence.
         * @param {number} [count=0] The number of sequential integers to generate.
         * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling
         * the emissions of the notifications.
         * @return {Observable} An Observable of numbers that emits a finite range of
         * sequential integers.
         * @static true
         * @name range
         * @owner Observable
         */
        RangeObservable.create = function (start, count, scheduler) {
            if (start === void 0) { start = 0; }
            if (count === void 0) { count = 0; }
            return new RangeObservable(start, count, scheduler);
        };
        RangeObservable.dispatch = function (state) {
            var start = state.start, index = state.index, count = state.count, subscriber = state.subscriber;
            if (index >= count) {
                subscriber.complete();
                return;
            }
            subscriber.next(start);
            if (subscriber.closed) {
                return;
            }
            state.index = index + 1;
            state.start = start + 1;
            this.schedule(state);
        };
        /** @deprecated internal use only */ RangeObservable.prototype._subscribe = function (subscriber) {
            var index = 0;
            var start = this.start;
            var count = this._count;
            var scheduler = this.scheduler;
            if (scheduler) {
                return scheduler.schedule(RangeObservable.dispatch, 0, {
                    index: index, count: count, start: start, subscriber: subscriber
                });
            }
            else {
                do {
                    if (index++ >= count) {
                        subscriber.complete();
                        break;
                    }
                    subscriber.next(start++);
                    if (subscriber.closed) {
                        break;
                    }
                } while (true);
            }
        };
        return RangeObservable;
    }(Observable_1.Observable));
    var RangeObservable_2 = RangeObservable;


    var RangeObservable_1 = {
    	RangeObservable: RangeObservable_2
    };

    var range_1 = RangeObservable_1.RangeObservable.create;


    var range = {
    	range: range_1
    };

    Observable_1.Observable.range = range.range;

    var __extends$S = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };



    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @extends {Ignored}
     * @hide true
     */
    var UsingObservable = (function (_super) {
        __extends$S(UsingObservable, _super);
        function UsingObservable(resourceFactory, observableFactory) {
            _super.call(this);
            this.resourceFactory = resourceFactory;
            this.observableFactory = observableFactory;
        }
        UsingObservable.create = function (resourceFactory, observableFactory) {
            return new UsingObservable(resourceFactory, observableFactory);
        };
        /** @deprecated internal use only */ UsingObservable.prototype._subscribe = function (subscriber) {
            var _a = this, resourceFactory = _a.resourceFactory, observableFactory = _a.observableFactory;
            var resource;
            try {
                resource = resourceFactory();
                return new UsingSubscriber(subscriber, resource, observableFactory);
            }
            catch (err) {
                subscriber.error(err);
            }
        };
        return UsingObservable;
    }(Observable_1.Observable));
    var UsingObservable_2 = UsingObservable;
    var UsingSubscriber = (function (_super) {
        __extends$S(UsingSubscriber, _super);
        function UsingSubscriber(destination, resource, observableFactory) {
            _super.call(this, destination);
            this.resource = resource;
            this.observableFactory = observableFactory;
            destination.add(resource);
            this.tryUse();
        }
        UsingSubscriber.prototype.tryUse = function () {
            try {
                var source = this.observableFactory.call(this, this.resource);
                if (source) {
                    this.add(subscribeToResult_1.subscribeToResult(this, source));
                }
            }
            catch (err) {
                this._error(err);
            }
        };
        return UsingSubscriber;
    }(OuterSubscriber_1.OuterSubscriber));


    var UsingObservable_1 = {
    	UsingObservable: UsingObservable_2
    };

    var using_1 = UsingObservable_1.UsingObservable.create;


    var using = {
    	using: using_1
    };

    Observable_1.Observable.using = using.using;

    var __extends$T = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };

    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @extends {Ignored}
     * @hide true
     */
    var ErrorObservable = (function (_super) {
        __extends$T(ErrorObservable, _super);
        function ErrorObservable(error, scheduler) {
            _super.call(this);
            this.error = error;
            this.scheduler = scheduler;
        }
        /**
         * Creates an Observable that emits no items to the Observer and immediately
         * emits an error notification.
         *
         * <span class="informal">Just emits 'error', and nothing else.
         * </span>
         *
         * <img src="./img/throw.png" width="100%">
         *
         * This static operator is useful for creating a simple Observable that only
         * emits the error notification. It can be used for composing with other
         * Observables, such as in a {@link mergeMap}.
         *
         * @example <caption>Emit the number 7, then emit an error.</caption>
         * var result = Rx.Observable.throw(new Error('oops!')).startWith(7);
         * result.subscribe(x => console.log(x), e => console.error(e));
         *
         * @example <caption>Map and flatten numbers to the sequence 'a', 'b', 'c', but throw an error for 13</caption>
         * var interval = Rx.Observable.interval(1000);
         * var result = interval.mergeMap(x =>
         *   x === 13 ?
         *     Rx.Observable.throw('Thirteens are bad') :
         *     Rx.Observable.of('a', 'b', 'c')
         * );
         * result.subscribe(x => console.log(x), e => console.error(e));
         *
         * @see {@link create}
         * @see {@link empty}
         * @see {@link never}
         * @see {@link of}
         *
         * @param {any} error The particular Error to pass to the error notification.
         * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling
         * the emission of the error notification.
         * @return {Observable} An error Observable: emits only the error notification
         * using the given error argument.
         * @static true
         * @name throw
         * @owner Observable
         */
        ErrorObservable.create = function (error, scheduler) {
            return new ErrorObservable(error, scheduler);
        };
        ErrorObservable.dispatch = function (arg) {
            var error = arg.error, subscriber = arg.subscriber;
            subscriber.error(error);
        };
        /** @deprecated internal use only */ ErrorObservable.prototype._subscribe = function (subscriber) {
            var error = this.error;
            var scheduler = this.scheduler;
            subscriber.syncErrorThrowable = true;
            if (scheduler) {
                return scheduler.schedule(ErrorObservable.dispatch, 0, {
                    error: error, subscriber: subscriber
                });
            }
            else {
                subscriber.error(error);
            }
        };
        return ErrorObservable;
    }(Observable_1.Observable));
    var ErrorObservable_2 = ErrorObservable;


    var ErrorObservable_1 = {
    	ErrorObservable: ErrorObservable_2
    };

    var _throw_1 = ErrorObservable_1.ErrorObservable.create;


    var _throw = {
    	_throw: _throw_1
    };

    Observable_1.Observable.throw = _throw._throw;

    function isDate(value) {
        return value instanceof Date && !isNaN(+value);
    }
    var isDate_2 = isDate;


    var isDate_1 = {
    	isDate: isDate_2
    };

    var __extends$U = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };





    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @extends {Ignored}
     * @hide true
     */
    var TimerObservable = (function (_super) {
        __extends$U(TimerObservable, _super);
        function TimerObservable(dueTime, period, scheduler) {
            if (dueTime === void 0) { dueTime = 0; }
            _super.call(this);
            this.period = -1;
            this.dueTime = 0;
            if (isNumeric_1.isNumeric(period)) {
                this.period = Number(period) < 1 && 1 || Number(period);
            }
            else if (isScheduler_1.isScheduler(period)) {
                scheduler = period;
            }
            if (!isScheduler_1.isScheduler(scheduler)) {
                scheduler = async.async;
            }
            this.scheduler = scheduler;
            this.dueTime = isDate_1.isDate(dueTime) ?
                (+dueTime - this.scheduler.now()) :
                dueTime;
        }
        /**
         * Creates an Observable that starts emitting after an `initialDelay` and
         * emits ever increasing numbers after each `period` of time thereafter.
         *
         * <span class="informal">Its like {@link interval}, but you can specify when
         * should the emissions start.</span>
         *
         * <img src="./img/timer.png" width="100%">
         *
         * `timer` returns an Observable that emits an infinite sequence of ascending
         * integers, with a constant interval of time, `period` of your choosing
         * between those emissions. The first emission happens after the specified
         * `initialDelay`. The initial delay may be a {@link Date}. By default, this
         * operator uses the `async` IScheduler to provide a notion of time, but you
         * may pass any IScheduler to it. If `period` is not specified, the output
         * Observable emits only one value, `0`. Otherwise, it emits an infinite
         * sequence.
         *
         * @example <caption>Emits ascending numbers, one every second (1000ms), starting after 3 seconds</caption>
         * var numbers = Rx.Observable.timer(3000, 1000);
         * numbers.subscribe(x => console.log(x));
         *
         * @example <caption>Emits one number after five seconds</caption>
         * var numbers = Rx.Observable.timer(5000);
         * numbers.subscribe(x => console.log(x));
         *
         * @see {@link interval}
         * @see {@link delay}
         *
         * @param {number|Date} initialDelay The initial delay time to wait before
         * emitting the first value of `0`.
         * @param {number} [period] The period of time between emissions of the
         * subsequent numbers.
         * @param {Scheduler} [scheduler=async] The IScheduler to use for scheduling
         * the emission of values, and providing a notion of "time".
         * @return {Observable} An Observable that emits a `0` after the
         * `initialDelay` and ever increasing numbers after each `period` of time
         * thereafter.
         * @static true
         * @name timer
         * @owner Observable
         */
        TimerObservable.create = function (initialDelay, period, scheduler) {
            if (initialDelay === void 0) { initialDelay = 0; }
            return new TimerObservable(initialDelay, period, scheduler);
        };
        TimerObservable.dispatch = function (state) {
            var index = state.index, period = state.period, subscriber = state.subscriber;
            var action = this;
            subscriber.next(index);
            if (subscriber.closed) {
                return;
            }
            else if (period === -1) {
                return subscriber.complete();
            }
            state.index = index + 1;
            action.schedule(state, period);
        };
        /** @deprecated internal use only */ TimerObservable.prototype._subscribe = function (subscriber) {
            var index = 0;
            var _a = this, period = _a.period, dueTime = _a.dueTime, scheduler = _a.scheduler;
            return scheduler.schedule(TimerObservable.dispatch, dueTime, {
                index: index, period: period, subscriber: subscriber
            });
        };
        return TimerObservable;
    }(Observable_1.Observable));
    var TimerObservable_2 = TimerObservable;


    var TimerObservable_1 = {
    	TimerObservable: TimerObservable_2
    };

    var timer_1 = TimerObservable_1.TimerObservable.create;


    var timer$1 = {
    	timer: timer_1
    };

    Observable_1.Observable.timer = timer$1.timer;

    var __extends$V = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };






    /* tslint:enable:max-line-length */
    /**
     * @param observables
     * @return {Observable<R>}
     * @method zip
     * @owner Observable
     */
    function zip() {
        var observables = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            observables[_i - 0] = arguments[_i];
        }
        return function zipOperatorFunction(source) {
            return source.lift.call(zipStatic.apply(void 0, [source].concat(observables)));
        };
    }
    var zip_2 = zip;
    /* tslint:enable:max-line-length */
    /**
     * Combines multiple Observables to create an Observable whose values are calculated from the values, in order, of each
     * of its input Observables.
     *
     * If the latest parameter is a function, this function is used to compute the created value from the input values.
     * Otherwise, an array of the input values is returned.
     *
     * @example <caption>Combine age and name from different sources</caption>
     *
     * let age$ = Observable.of<number>(27, 25, 29);
     * let name$ = Observable.of<string>('Foo', 'Bar', 'Beer');
     * let isDev$ = Observable.of<boolean>(true, true, false);
     *
     * Observable
     *     .zip(age$,
     *          name$,
     *          isDev$,
     *          (age: number, name: string, isDev: boolean) => ({ age, name, isDev }))
     *     .subscribe(x => console.log(x));
     *
     * // outputs
     * // { age: 27, name: 'Foo', isDev: true }
     * // { age: 25, name: 'Bar', isDev: true }
     * // { age: 29, name: 'Beer', isDev: false }
     *
     * @param observables
     * @return {Observable<R>}
     * @static true
     * @name zip
     * @owner Observable
     */
    function zipStatic() {
        var observables = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            observables[_i - 0] = arguments[_i];
        }
        var project = observables[observables.length - 1];
        if (typeof project === 'function') {
            observables.pop();
        }
        return new ArrayObservable_1.ArrayObservable(observables).lift(new ZipOperator(project));
    }
    var zipStatic_1 = zipStatic;
    var ZipOperator = (function () {
        function ZipOperator(project) {
            this.project = project;
        }
        ZipOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(new ZipSubscriber(subscriber, this.project));
        };
        return ZipOperator;
    }());
    var ZipOperator_1 = ZipOperator;
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var ZipSubscriber = (function (_super) {
        __extends$V(ZipSubscriber, _super);
        function ZipSubscriber(destination, project, values) {
            if (values === void 0) { values = Object.create(null); }
            _super.call(this, destination);
            this.iterators = [];
            this.active = 0;
            this.project = (typeof project === 'function') ? project : null;
            this.values = values;
        }
        ZipSubscriber.prototype._next = function (value) {
            var iterators = this.iterators;
            if (isArray.isArray(value)) {
                iterators.push(new StaticArrayIterator(value));
            }
            else if (typeof value[iterator.iterator] === 'function') {
                iterators.push(new StaticIterator(value[iterator.iterator]()));
            }
            else {
                iterators.push(new ZipBufferIterator(this.destination, this, value));
            }
        };
        ZipSubscriber.prototype._complete = function () {
            var iterators = this.iterators;
            var len = iterators.length;
            if (len === 0) {
                this.destination.complete();
                return;
            }
            this.active = len;
            for (var i = 0; i < len; i++) {
                var iterator$$1 = iterators[i];
                if (iterator$$1.stillUnsubscribed) {
                    this.add(iterator$$1.subscribe(iterator$$1, i));
                }
                else {
                    this.active--; // not an observable
                }
            }
        };
        ZipSubscriber.prototype.notifyInactive = function () {
            this.active--;
            if (this.active === 0) {
                this.destination.complete();
            }
        };
        ZipSubscriber.prototype.checkIterators = function () {
            var iterators = this.iterators;
            var len = iterators.length;
            var destination = this.destination;
            // abort if not all of them have values
            for (var i = 0; i < len; i++) {
                var iterator$$1 = iterators[i];
                if (typeof iterator$$1.hasValue === 'function' && !iterator$$1.hasValue()) {
                    return;
                }
            }
            var shouldComplete = false;
            var args = [];
            for (var i = 0; i < len; i++) {
                var iterator$$1 = iterators[i];
                var result = iterator$$1.next();
                // check to see if it's completed now that you've gotten
                // the next value.
                if (iterator$$1.hasCompleted()) {
                    shouldComplete = true;
                }
                if (result.done) {
                    destination.complete();
                    return;
                }
                args.push(result.value);
            }
            if (this.project) {
                this._tryProject(args);
            }
            else {
                destination.next(args);
            }
            if (shouldComplete) {
                destination.complete();
            }
        };
        ZipSubscriber.prototype._tryProject = function (args) {
            var result;
            try {
                result = this.project.apply(this, args);
            }
            catch (err) {
                this.destination.error(err);
                return;
            }
            this.destination.next(result);
        };
        return ZipSubscriber;
    }(Subscriber_1.Subscriber));
    var ZipSubscriber_1 = ZipSubscriber;
    var StaticIterator = (function () {
        function StaticIterator(iterator$$1) {
            this.iterator = iterator$$1;
            this.nextResult = iterator$$1.next();
        }
        StaticIterator.prototype.hasValue = function () {
            return true;
        };
        StaticIterator.prototype.next = function () {
            var result = this.nextResult;
            this.nextResult = this.iterator.next();
            return result;
        };
        StaticIterator.prototype.hasCompleted = function () {
            var nextResult = this.nextResult;
            return nextResult && nextResult.done;
        };
        return StaticIterator;
    }());
    var StaticArrayIterator = (function () {
        function StaticArrayIterator(array) {
            this.array = array;
            this.index = 0;
            this.length = 0;
            this.length = array.length;
        }
        StaticArrayIterator.prototype[iterator.iterator] = function () {
            return this;
        };
        StaticArrayIterator.prototype.next = function (value) {
            var i = this.index++;
            var array = this.array;
            return i < this.length ? { value: array[i], done: false } : { value: null, done: true };
        };
        StaticArrayIterator.prototype.hasValue = function () {
            return this.array.length > this.index;
        };
        StaticArrayIterator.prototype.hasCompleted = function () {
            return this.array.length === this.index;
        };
        return StaticArrayIterator;
    }());
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var ZipBufferIterator = (function (_super) {
        __extends$V(ZipBufferIterator, _super);
        function ZipBufferIterator(destination, parent, observable) {
            _super.call(this, destination);
            this.parent = parent;
            this.observable = observable;
            this.stillUnsubscribed = true;
            this.buffer = [];
            this.isComplete = false;
        }
        ZipBufferIterator.prototype[iterator.iterator] = function () {
            return this;
        };
        // NOTE: there is actually a name collision here with Subscriber.next and Iterator.next
        //    this is legit because `next()` will never be called by a subscription in this case.
        ZipBufferIterator.prototype.next = function () {
            var buffer = this.buffer;
            if (buffer.length === 0 && this.isComplete) {
                return { value: null, done: true };
            }
            else {
                return { value: buffer.shift(), done: false };
            }
        };
        ZipBufferIterator.prototype.hasValue = function () {
            return this.buffer.length > 0;
        };
        ZipBufferIterator.prototype.hasCompleted = function () {
            return this.buffer.length === 0 && this.isComplete;
        };
        ZipBufferIterator.prototype.notifyComplete = function () {
            if (this.buffer.length > 0) {
                this.isComplete = true;
                this.parent.notifyInactive();
            }
            else {
                this.destination.complete();
            }
        };
        ZipBufferIterator.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
            this.buffer.push(innerValue);
            this.parent.checkIterators();
        };
        ZipBufferIterator.prototype.subscribe = function (value, index) {
            return subscribeToResult_1.subscribeToResult(this, this.observable, this, index);
        };
        return ZipBufferIterator;
    }(OuterSubscriber_1.OuterSubscriber));


    var zip_1 = {
    	zip: zip_2,
    	zipStatic: zipStatic_1,
    	ZipOperator: ZipOperator_1,
    	ZipSubscriber: ZipSubscriber_1
    };

    var zip_2$1 = zip_1.zipStatic;


    var zip$1 = {
    	zip: zip_2$1
    };

    Observable_1.Observable.zip = zip$1.zip;

    var __extends$W = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };

    /**
     * Applies a given `project` function to each value emitted by the source
     * Observable, and emits the resulting values as an Observable.
     *
     * <span class="informal">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),
     * it passes each source value through a transformation function to get
     * corresponding output values.</span>
     *
     * <img src="./img/map.png" width="100%">
     *
     * Similar to the well known `Array.prototype.map` function, this operator
     * applies a projection to each value and emits that projection in the output
     * Observable.
     *
     * @example <caption>Map every click to the clientX position of that click</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var positions = clicks.map(ev => ev.clientX);
     * positions.subscribe(x => console.log(x));
     *
     * @see {@link mapTo}
     * @see {@link pluck}
     *
     * @param {function(value: T, index: number): R} project The function to apply
     * to each `value` emitted by the source Observable. The `index` parameter is
     * the number `i` for the i-th emission that has happened since the
     * subscription, starting from the number `0`.
     * @param {any} [thisArg] An optional argument to define what `this` is in the
     * `project` function.
     * @return {Observable<R>} An Observable that emits the values from the source
     * Observable transformed by the given `project` function.
     * @method map
     * @owner Observable
     */
    function map(project, thisArg) {
        return function mapOperation(source) {
            if (typeof project !== 'function') {
                throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');
            }
            return source.lift(new MapOperator(project, thisArg));
        };
    }
    var map_2 = map;
    var MapOperator = (function () {
        function MapOperator(project, thisArg) {
            this.project = project;
            this.thisArg = thisArg;
        }
        MapOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
        };
        return MapOperator;
    }());
    var MapOperator_1 = MapOperator;
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var MapSubscriber = (function (_super) {
        __extends$W(MapSubscriber, _super);
        function MapSubscriber(destination, project, thisArg) {
            _super.call(this, destination);
            this.project = project;
            this.count = 0;
            this.thisArg = thisArg || this;
        }
        // NOTE: This looks unoptimized, but it's actually purposefully NOT
        // using try/catch optimizations.
        MapSubscriber.prototype._next = function (value) {
            var result;
            try {
                result = this.project.call(this.thisArg, value, this.count++);
            }
            catch (err) {
                this.destination.error(err);
                return;
            }
            this.destination.next(result);
        };
        return MapSubscriber;
    }(Subscriber_1.Subscriber));


    var map_1 = {
    	map: map_2,
    	MapOperator: MapOperator_1
    };

    var __extends$X = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };






    function getCORSRequest() {
        if (root.root.XMLHttpRequest) {
            return new root.root.XMLHttpRequest();
        }
        else if (!!root.root.XDomainRequest) {
            return new root.root.XDomainRequest();
        }
        else {
            throw new Error('CORS is not supported by your browser');
        }
    }
    function getXMLHttpRequest() {
        if (root.root.XMLHttpRequest) {
            return new root.root.XMLHttpRequest();
        }
        else {
            var progId = void 0;
            try {
                var progIds = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'];
                for (var i = 0; i < 3; i++) {
                    try {
                        progId = progIds[i];
                        if (new root.root.ActiveXObject(progId)) {
                            break;
                        }
                    }
                    catch (e) {
                    }
                }
                return new root.root.ActiveXObject(progId);
            }
            catch (e) {
                throw new Error('XMLHttpRequest is not supported by your browser');
            }
        }
    }
    function ajaxGet(url, headers) {
        if (headers === void 0) { headers = null; }
        return new AjaxObservable({ method: 'GET', url: url, headers: headers });
    }
    var ajaxGet_1 = ajaxGet;
    function ajaxPost(url, body, headers) {
        return new AjaxObservable({ method: 'POST', url: url, body: body, headers: headers });
    }
    var ajaxPost_1 = ajaxPost;
    function ajaxDelete(url, headers) {
        return new AjaxObservable({ method: 'DELETE', url: url, headers: headers });
    }
    var ajaxDelete_1 = ajaxDelete;
    function ajaxPut(url, body, headers) {
        return new AjaxObservable({ method: 'PUT', url: url, body: body, headers: headers });
    }
    var ajaxPut_1 = ajaxPut;
    function ajaxPatch(url, body, headers) {
        return new AjaxObservable({ method: 'PATCH', url: url, body: body, headers: headers });
    }
    var ajaxPatch_1 = ajaxPatch;
    var mapResponse = map_1.map(function (x, index) { return x.response; });
    function ajaxGetJSON(url, headers) {
        return mapResponse(new AjaxObservable({
            method: 'GET',
            url: url,
            responseType: 'json',
            headers: headers
        }));
    }
    var ajaxGetJSON_1 = ajaxGetJSON;
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @extends {Ignored}
     * @hide true
     */
    var AjaxObservable = (function (_super) {
        __extends$X(AjaxObservable, _super);
        function AjaxObservable(urlOrRequest) {
            _super.call(this);
            var request = {
                async: true,
                createXHR: function () {
                    return this.crossDomain ? getCORSRequest.call(this) : getXMLHttpRequest();
                },
                crossDomain: false,
                withCredentials: false,
                headers: {},
                method: 'GET',
                responseType: 'json',
                timeout: 0
            };
            if (typeof urlOrRequest === 'string') {
                request.url = urlOrRequest;
            }
            else {
                for (var prop in urlOrRequest) {
                    if (urlOrRequest.hasOwnProperty(prop)) {
                        request[prop] = urlOrRequest[prop];
                    }
                }
            }
            this.request = request;
        }
        /** @deprecated internal use only */ AjaxObservable.prototype._subscribe = function (subscriber) {
            return new AjaxSubscriber(subscriber, this.request);
        };
        /**
         * Creates an observable for an Ajax request with either a request object with
         * url, headers, etc or a string for a URL.
         *
         * @example
         * source = Rx.Observable.ajax('/products');
         * source = Rx.Observable.ajax({ url: 'products', method: 'GET' });
         *
         * @param {string|Object} request Can be one of the following:
         *   A string of the URL to make the Ajax call.
         *   An object with the following properties
         *   - url: URL of the request
         *   - body: The body of the request
         *   - method: Method of the request, such as GET, POST, PUT, PATCH, DELETE
         *   - async: Whether the request is async
         *   - headers: Optional headers
         *   - crossDomain: true if a cross domain request, else false
         *   - createXHR: a function to override if you need to use an alternate
         *   XMLHttpRequest implementation.
         *   - resultSelector: a function to use to alter the output value type of
         *   the Observable. Gets {@link AjaxResponse} as an argument.
         * @return {Observable} An observable sequence containing the XMLHttpRequest.
         * @static true
         * @name ajax
         * @owner Observable
        */
        AjaxObservable.create = (function () {
            var create = function (urlOrRequest) {
                return new AjaxObservable(urlOrRequest);
            };
            create.get = ajaxGet;
            create.post = ajaxPost;
            create.delete = ajaxDelete;
            create.put = ajaxPut;
            create.patch = ajaxPatch;
            create.getJSON = ajaxGetJSON;
            return create;
        })();
        return AjaxObservable;
    }(Observable_1.Observable));
    var AjaxObservable_2 = AjaxObservable;
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var AjaxSubscriber = (function (_super) {
        __extends$X(AjaxSubscriber, _super);
        function AjaxSubscriber(destination, request) {
            _super.call(this, destination);
            this.request = request;
            this.done = false;
            var headers = request.headers = request.headers || {};
            // force CORS if requested
            if (!request.crossDomain && !headers['X-Requested-With']) {
                headers['X-Requested-With'] = 'XMLHttpRequest';
            }
            // ensure content type is set
            if (!('Content-Type' in headers) && !(root.root.FormData && request.body instanceof root.root.FormData) && typeof request.body !== 'undefined') {
                headers['Content-Type'] = 'application/x-www-form-urlencoded; charset=UTF-8';
            }
            // properly serialize body
            request.body = this.serializeBody(request.body, request.headers['Content-Type']);
            this.send();
        }
        AjaxSubscriber.prototype.next = function (e) {
            this.done = true;
            var _a = this, xhr = _a.xhr, request = _a.request, destination = _a.destination;
            var response = new AjaxResponse(e, xhr, request);
            destination.next(response);
        };
        AjaxSubscriber.prototype.send = function () {
            var _a = this, request = _a.request, _b = _a.request, user = _b.user, method = _b.method, url = _b.url, async = _b.async, password = _b.password, headers = _b.headers, body = _b.body;
            var createXHR = request.createXHR;
            var xhr = tryCatch_1.tryCatch(createXHR).call(request);
            if (xhr === errorObject.errorObject) {
                this.error(errorObject.errorObject.e);
            }
            else {
                this.xhr = xhr;
                // set up the events before open XHR
                // https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest
                // You need to add the event listeners before calling open() on the request.
                // Otherwise the progress events will not fire.
                this.setupEvents(xhr, request);
                // open XHR
                var result = void 0;
                if (user) {
                    result = tryCatch_1.tryCatch(xhr.open).call(xhr, method, url, async, user, password);
                }
                else {
                    result = tryCatch_1.tryCatch(xhr.open).call(xhr, method, url, async);
                }
                if (result === errorObject.errorObject) {
                    this.error(errorObject.errorObject.e);
                    return null;
                }
                // timeout, responseType and withCredentials can be set once the XHR is open
                if (async) {
                    xhr.timeout = request.timeout;
                    xhr.responseType = request.responseType;
                }
                if ('withCredentials' in xhr) {
                    xhr.withCredentials = !!request.withCredentials;
                }
                // set headers
                this.setHeaders(xhr, headers);
                // finally send the request
                result = body ? tryCatch_1.tryCatch(xhr.send).call(xhr, body) : tryCatch_1.tryCatch(xhr.send).call(xhr);
                if (result === errorObject.errorObject) {
                    this.error(errorObject.errorObject.e);
                    return null;
                }
            }
            return xhr;
        };
        AjaxSubscriber.prototype.serializeBody = function (body, contentType) {
            if (!body || typeof body === 'string') {
                return body;
            }
            else if (root.root.FormData && body instanceof root.root.FormData) {
                return body;
            }
            if (contentType) {
                var splitIndex = contentType.indexOf(';');
                if (splitIndex !== -1) {
                    contentType = contentType.substring(0, splitIndex);
                }
            }
            switch (contentType) {
                case 'application/x-www-form-urlencoded':
                    return Object.keys(body).map(function (key) { return (encodeURI(key) + "=" + encodeURI(body[key])); }).join('&');
                case 'application/json':
                    return JSON.stringify(body);
                default:
                    return body;
            }
        };
        AjaxSubscriber.prototype.setHeaders = function (xhr, headers) {
            for (var key in headers) {
                if (headers.hasOwnProperty(key)) {
                    xhr.setRequestHeader(key, headers[key]);
                }
            }
        };
        AjaxSubscriber.prototype.setupEvents = function (xhr, request) {
            var progressSubscriber = request.progressSubscriber;
            function xhrTimeout(e) {
                var _a = xhrTimeout, subscriber = _a.subscriber, progressSubscriber = _a.progressSubscriber, request = _a.request;
                if (progressSubscriber) {
                    progressSubscriber.error(e);
                }
                subscriber.error(new AjaxTimeoutError(this, request)); //TODO: Make betterer.
            }
            xhr.ontimeout = xhrTimeout;
            xhrTimeout.request = request;
            xhrTimeout.subscriber = this;
            xhrTimeout.progressSubscriber = progressSubscriber;
            if (xhr.upload && 'withCredentials' in xhr) {
                if (progressSubscriber) {
                    var xhrProgress_1;
                    xhrProgress_1 = function (e) {
                        var progressSubscriber = xhrProgress_1.progressSubscriber;
                        progressSubscriber.next(e);
                    };
                    if (root.root.XDomainRequest) {
                        xhr.onprogress = xhrProgress_1;
                    }
                    else {
                        xhr.upload.onprogress = xhrProgress_1;
                    }
                    xhrProgress_1.progressSubscriber = progressSubscriber;
                }
                var xhrError_1;
                xhrError_1 = function (e) {
                    var _a = xhrError_1, progressSubscriber = _a.progressSubscriber, subscriber = _a.subscriber, request = _a.request;
                    if (progressSubscriber) {
                        progressSubscriber.error(e);
                    }
                    subscriber.error(new AjaxError('ajax error', this, request));
                };
                xhr.onerror = xhrError_1;
                xhrError_1.request = request;
                xhrError_1.subscriber = this;
                xhrError_1.progressSubscriber = progressSubscriber;
            }
            function xhrReadyStateChange(e) {
                var _a = xhrReadyStateChange, subscriber = _a.subscriber, progressSubscriber = _a.progressSubscriber, request = _a.request;
                if (this.readyState === 4) {
                    // normalize IE9 bug (http://bugs.jquery.com/ticket/1450)
                    var status_1 = this.status === 1223 ? 204 : this.status;
                    var response = (this.responseType === 'text' ? (this.response || this.responseText) : this.response);
                    // fix status code when it is 0 (0 status is undocumented).
                    // Occurs when accessing file resources or on Android 4.1 stock browser
                    // while retrieving files from application cache.
                    if (status_1 === 0) {
                        status_1 = response ? 200 : 0;
                    }
                    if (200 <= status_1 && status_1 < 300) {
                        if (progressSubscriber) {
                            progressSubscriber.complete();
                        }
                        subscriber.next(e);
                        subscriber.complete();
                    }
                    else {
                        if (progressSubscriber) {
                            progressSubscriber.error(e);
                        }
                        subscriber.error(new AjaxError('ajax error ' + status_1, this, request));
                    }
                }
            }
            xhr.onreadystatechange = xhrReadyStateChange;
            xhrReadyStateChange.subscriber = this;
            xhrReadyStateChange.progressSubscriber = progressSubscriber;
            xhrReadyStateChange.request = request;
        };
        AjaxSubscriber.prototype.unsubscribe = function () {
            var _a = this, done = _a.done, xhr = _a.xhr;
            if (!done && xhr && xhr.readyState !== 4 && typeof xhr.abort === 'function') {
                xhr.abort();
            }
            _super.prototype.unsubscribe.call(this);
        };
        return AjaxSubscriber;
    }(Subscriber_1.Subscriber));
    var AjaxSubscriber_1 = AjaxSubscriber;
    /**
     * A normalized AJAX response.
     *
     * @see {@link ajax}
     *
     * @class AjaxResponse
     */
    var AjaxResponse = (function () {
        function AjaxResponse(originalEvent, xhr, request) {
            this.originalEvent = originalEvent;
            this.xhr = xhr;
            this.request = request;
            this.status = xhr.status;
            this.responseType = xhr.responseType || request.responseType;
            this.response = parseXhrResponse(this.responseType, xhr);
        }
        return AjaxResponse;
    }());
    var AjaxResponse_1 = AjaxResponse;
    /**
     * A normalized AJAX error.
     *
     * @see {@link ajax}
     *
     * @class AjaxError
     */
    var AjaxError = (function (_super) {
        __extends$X(AjaxError, _super);
        function AjaxError(message, xhr, request) {
            _super.call(this, message);
            this.message = message;
            this.xhr = xhr;
            this.request = request;
            this.status = xhr.status;
            this.responseType = xhr.responseType || request.responseType;
            this.response = parseXhrResponse(this.responseType, xhr);
        }
        return AjaxError;
    }(Error));
    var AjaxError_1 = AjaxError;
    function parseXhrResponse(responseType, xhr) {
        switch (responseType) {
            case 'json':
                if ('response' in xhr) {
                    //IE does not support json as responseType, parse it internally
                    return xhr.responseType ? xhr.response : JSON.parse(xhr.response || xhr.responseText || 'null');
                }
                else {
                    // HACK(benlesh): TypeScript shennanigans
                    // tslint:disable-next-line:no-any latest TS seems to think xhr is "never" here.
                    return JSON.parse(xhr.responseText || 'null');
                }
            case 'xml':
                return xhr.responseXML;
            case 'text':
            default:
                // HACK(benlesh): TypeScript shennanigans
                // tslint:disable-next-line:no-any latest TS seems to think xhr is "never" here.
                return ('response' in xhr) ? xhr.response : xhr.responseText;
        }
    }
    /**
     * @see {@link ajax}
     *
     * @class AjaxTimeoutError
     */
    var AjaxTimeoutError = (function (_super) {
        __extends$X(AjaxTimeoutError, _super);
        function AjaxTimeoutError(xhr, request) {
            _super.call(this, 'ajax timeout', xhr, request);
        }
        return AjaxTimeoutError;
    }(AjaxError));
    var AjaxTimeoutError_1 = AjaxTimeoutError;


    var AjaxObservable_1 = {
    	ajaxGet: ajaxGet_1,
    	ajaxPost: ajaxPost_1,
    	ajaxDelete: ajaxDelete_1,
    	ajaxPut: ajaxPut_1,
    	ajaxPatch: ajaxPatch_1,
    	ajaxGetJSON: ajaxGetJSON_1,
    	AjaxObservable: AjaxObservable_2,
    	AjaxSubscriber: AjaxSubscriber_1,
    	AjaxResponse: AjaxResponse_1,
    	AjaxError: AjaxError_1,
    	AjaxTimeoutError: AjaxTimeoutError_1
    };

    var ajax_1 = AjaxObservable_1.AjaxObservable.create;


    var ajax = {
    	ajax: ajax_1
    };

    Observable_1.Observable.ajax = ajax.ajax;

    var __extends$Y = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };

    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var QueueAction = (function (_super) {
        __extends$Y(QueueAction, _super);
        function QueueAction(scheduler, work) {
            _super.call(this, scheduler, work);
            this.scheduler = scheduler;
            this.work = work;
        }
        QueueAction.prototype.schedule = function (state, delay) {
            if (delay === void 0) { delay = 0; }
            if (delay > 0) {
                return _super.prototype.schedule.call(this, state, delay);
            }
            this.delay = delay;
            this.state = state;
            this.scheduler.flush(this);
            return this;
        };
        QueueAction.prototype.execute = function (state, delay) {
            return (delay > 0 || this.closed) ?
                _super.prototype.execute.call(this, state, delay) :
                this._execute(state, delay);
        };
        QueueAction.prototype.requestAsyncId = function (scheduler, id, delay) {
            if (delay === void 0) { delay = 0; }
            // If delay exists and is greater than 0, or if the delay is null (the
            // action wasn't rescheduled) but was originally scheduled as an async
            // action, then recycle as an async action.
            if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
                return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
            }
            // Otherwise flush the scheduler starting with this action.
            return scheduler.flush(this);
        };
        return QueueAction;
    }(AsyncAction_1.AsyncAction));
    var QueueAction_2 = QueueAction;


    var QueueAction_1 = {
    	QueueAction: QueueAction_2
    };

    var __extends$Z = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };

    var QueueScheduler = (function (_super) {
        __extends$Z(QueueScheduler, _super);
        function QueueScheduler() {
            _super.apply(this, arguments);
        }
        return QueueScheduler;
    }(AsyncScheduler_1.AsyncScheduler));
    var QueueScheduler_2 = QueueScheduler;


    var QueueScheduler_1 = {
    	QueueScheduler: QueueScheduler_2
    };

    /**
     *
     * Queue Scheduler
     *
     * <span class="informal">Put every next task on a queue, instead of executing it immediately</span>
     *
     * `queue` scheduler, when used with delay, behaves the same as {@link async} scheduler.
     *
     * When used without delay, it schedules given task synchronously - executes it right when
     * it is scheduled. However when called recursively, that is when inside the scheduled task,
     * another task is scheduled with queue scheduler, instead of executing immediately as well,
     * that task will be put on a queue and wait for current one to finish.
     *
     * This means that when you execute task with `queue` scheduler, you are sure it will end
     * before any other task scheduled with that scheduler will start.
     *
     * @examples <caption>Schedule recursively first, then do something</caption>
     *
     * Rx.Scheduler.queue.schedule(() => {
     *   Rx.Scheduler.queue.schedule(() => console.log('second')); // will not happen now, but will be put on a queue
     *
     *   console.log('first');
     * });
     *
     * // Logs:
     * // "first"
     * // "second"
     *
     *
     * @example <caption>Reschedule itself recursively</caption>
     *
     * Rx.Scheduler.queue.schedule(function(state) {
     *   if (state !== 0) {
     *     console.log('before', state);
     *     this.schedule(state - 1); // `this` references currently executing Action,
     *                               // which we reschedule with new state
     *     console.log('after', state);
     *   }
     * }, 0, 3);
     *
     * // In scheduler that runs recursively, you would expect:
     * // "before", 3
     * // "before", 2
     * // "before", 1
     * // "after", 1
     * // "after", 2
     * // "after", 3
     *
     * // But with queue it logs:
     * // "before", 3
     * // "after", 3
     * // "before", 2
     * // "after", 2
     * // "before", 1
     * // "after", 1
     *
     *
     * @static true
     * @name queue
     * @owner Scheduler
     */
    var queue_1 = new QueueScheduler_1.QueueScheduler(QueueAction_1.QueueAction);


    var queue = {
    	queue: queue_1
    };

    var __extends = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };






    /**
     * @class ReplaySubject<T>
     */
    var ReplaySubject = (function (_super) {
        __extends(ReplaySubject, _super);
        function ReplaySubject(bufferSize, windowTime, scheduler) {
            if (bufferSize === void 0) { bufferSize = Number.POSITIVE_INFINITY; }
            if (windowTime === void 0) { windowTime = Number.POSITIVE_INFINITY; }
            _super.call(this);
            this.scheduler = scheduler;
            this._events = [];
            this._bufferSize = bufferSize < 1 ? 1 : bufferSize;
            this._windowTime = windowTime < 1 ? 1 : windowTime;
        }
        ReplaySubject.prototype.next = function (value) {
            var now = this._getNow();
            this._events.push(new ReplayEvent(now, value));
            this._trimBufferThenGetEvents();
            _super.prototype.next.call(this, value);
        };
        /** @deprecated internal use only */ ReplaySubject.prototype._subscribe = function (subscriber) {
            var _events = this._trimBufferThenGetEvents();
            var scheduler = this.scheduler;
            var subscription;
            if (this.closed) {
                throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
            }
            else if (this.hasError) {
                subscription = Subscription_1.Subscription.EMPTY;
            }
            else if (this.isStopped) {
                subscription = Subscription_1.Subscription.EMPTY;
            }
            else {
                this.observers.push(subscriber);
                subscription = new SubjectSubscription_1.SubjectSubscription(this, subscriber);
            }
            if (scheduler) {
                subscriber.add(subscriber = new observeOn_1.ObserveOnSubscriber(subscriber, scheduler));
            }
            var len = _events.length;
            for (var i = 0; i < len && !subscriber.closed; i++) {
                subscriber.next(_events[i].value);
            }
            if (this.hasError) {
                subscriber.error(this.thrownError);
            }
            else if (this.isStopped) {
                subscriber.complete();
            }
            return subscription;
        };
        ReplaySubject.prototype._getNow = function () {
            return (this.scheduler || queue.queue).now();
        };
        ReplaySubject.prototype._trimBufferThenGetEvents = function () {
            var now = this._getNow();
            var _bufferSize = this._bufferSize;
            var _windowTime = this._windowTime;
            var _events = this._events;
            var eventsCount = _events.length;
            var spliceCount = 0;
            // Trim events that fall out of the time window.
            // Start at the front of the list. Break early once
            // we encounter an event that falls within the window.
            while (spliceCount < eventsCount) {
                if ((now - _events[spliceCount].time) < _windowTime) {
                    break;
                }
                spliceCount++;
            }
            if (eventsCount > _bufferSize) {
                spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);
            }
            if (spliceCount > 0) {
                _events.splice(0, spliceCount);
            }
            return _events;
        };
        return ReplaySubject;
    }(Subject_1.Subject));
    var ReplaySubject_2 = ReplaySubject;
    var ReplayEvent = (function () {
        function ReplayEvent(time, value) {
            this.time = time;
            this.value = value;
        }
        return ReplayEvent;
    }());


    var ReplaySubject_1 = {
    	ReplaySubject: ReplaySubject_2
    };

    function assignImpl(target) {
        var sources = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            sources[_i - 1] = arguments[_i];
        }
        var len = sources.length;
        for (var i = 0; i < len; i++) {
            var source = sources[i];
            for (var k in source) {
                if (source.hasOwnProperty(k)) {
                    target[k] = source[k];
                }
            }
        }
        return target;
    }
    var assignImpl_1 = assignImpl;
    function getAssign(root$$1) {
        return root$$1.Object.assign || assignImpl;
    }
    var getAssign_1 = getAssign;
    var assign_1 = getAssign(root.root);


    var assign = {
    	assignImpl: assignImpl_1,
    	getAssign: getAssign_1,
    	assign: assign_1
    };

    var __extends$_ = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };









    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @extends {Ignored}
     * @hide true
     */
    var WebSocketSubject = (function (_super) {
        __extends$_(WebSocketSubject, _super);
        function WebSocketSubject(urlConfigOrSource, destination) {
            if (urlConfigOrSource instanceof Observable_1.Observable) {
                _super.call(this, destination, urlConfigOrSource);
            }
            else {
                _super.call(this);
                this.WebSocketCtor = root.root.WebSocket;
                this._output = new Subject_1.Subject();
                if (typeof urlConfigOrSource === 'string') {
                    this.url = urlConfigOrSource;
                }
                else {
                    // WARNING: config object could override important members here.
                    assign.assign(this, urlConfigOrSource);
                }
                if (!this.WebSocketCtor) {
                    throw new Error('no WebSocket constructor can be found');
                }
                this.destination = new ReplaySubject_1.ReplaySubject();
            }
        }
        WebSocketSubject.prototype.resultSelector = function (e) {
            return JSON.parse(e.data);
        };
        /**
         * Wrapper around the w3c-compatible WebSocket object provided by the browser.
         *
         * @example <caption>Wraps browser WebSocket</caption>
         *
         * let socket$ = Observable.webSocket('ws://localhost:8081');
         *
         * socket$.subscribe(
         *    (msg) => console.log('message received: ' + msg),
         *    (err) => console.log(err),
         *    () => console.log('complete')
         *  );
         *
         * socket$.next(JSON.stringify({ op: 'hello' }));
         *
         * @example <caption>Wraps WebSocket from nodejs-websocket (using node.js)</caption>
         *
         * import { w3cwebsocket } from 'websocket';
         *
         * let socket$ = Observable.webSocket({
         *   url: 'ws://localhost:8081',
         *   WebSocketCtor: w3cwebsocket
         * });
         *
         * socket$.subscribe(
         *    (msg) => console.log('message received: ' + msg),
         *    (err) => console.log(err),
         *    () => console.log('complete')
         *  );
         *
         * socket$.next(JSON.stringify({ op: 'hello' }));
         *
         * @param {string | WebSocketSubjectConfig} urlConfigOrSource the source of the websocket as an url or a structure defining the websocket object
         * @return {WebSocketSubject}
         * @static true
         * @name webSocket
         * @owner Observable
         */
        WebSocketSubject.create = function (urlConfigOrSource) {
            return new WebSocketSubject(urlConfigOrSource);
        };
        WebSocketSubject.prototype.lift = function (operator) {
            var sock = new WebSocketSubject(this, this.destination);
            sock.operator = operator;
            return sock;
        };
        WebSocketSubject.prototype._resetState = function () {
            this.socket = null;
            if (!this.source) {
                this.destination = new ReplaySubject_1.ReplaySubject();
            }
            this._output = new Subject_1.Subject();
        };
        // TODO: factor this out to be a proper Operator/Subscriber implementation and eliminate closures
        WebSocketSubject.prototype.multiplex = function (subMsg, unsubMsg, messageFilter) {
            var self = this;
            return new Observable_1.Observable(function (observer) {
                var result = tryCatch_1.tryCatch(subMsg)();
                if (result === errorObject.errorObject) {
                    observer.error(errorObject.errorObject.e);
                }
                else {
                    self.next(result);
                }
                var subscription = self.subscribe(function (x) {
                    var result = tryCatch_1.tryCatch(messageFilter)(x);
                    if (result === errorObject.errorObject) {
                        observer.error(errorObject.errorObject.e);
                    }
                    else if (result) {
                        observer.next(x);
                    }
                }, function (err) { return observer.error(err); }, function () { return observer.complete(); });
                return function () {
                    var result = tryCatch_1.tryCatch(unsubMsg)();
                    if (result === errorObject.errorObject) {
                        observer.error(errorObject.errorObject.e);
                    }
                    else {
                        self.next(result);
                    }
                    subscription.unsubscribe();
                };
            });
        };
        WebSocketSubject.prototype._connectSocket = function () {
            var _this = this;
            var WebSocketCtor = this.WebSocketCtor;
            var observer = this._output;
            var socket = null;
            try {
                socket = this.protocol ?
                    new WebSocketCtor(this.url, this.protocol) :
                    new WebSocketCtor(this.url);
                this.socket = socket;
                if (this.binaryType) {
                    this.socket.binaryType = this.binaryType;
                }
            }
            catch (e) {
                observer.error(e);
                return;
            }
            var subscription = new Subscription_1.Subscription(function () {
                _this.socket = null;
                if (socket && socket.readyState === 1) {
                    socket.close();
                }
            });
            socket.onopen = function (e) {
                var openObserver = _this.openObserver;
                if (openObserver) {
                    openObserver.next(e);
                }
                var queue = _this.destination;
                _this.destination = Subscriber_1.Subscriber.create(function (x) { return socket.readyState === 1 && socket.send(x); }, function (e) {
                    var closingObserver = _this.closingObserver;
                    if (closingObserver) {
                        closingObserver.next(undefined);
                    }
                    if (e && e.code) {
                        socket.close(e.code, e.reason);
                    }
                    else {
                        observer.error(new TypeError('WebSocketSubject.error must be called with an object with an error code, ' +
                            'and an optional reason: { code: number, reason: string }'));
                    }
                    _this._resetState();
                }, function () {
                    var closingObserver = _this.closingObserver;
                    if (closingObserver) {
                        closingObserver.next(undefined);
                    }
                    socket.close();
                    _this._resetState();
                });
                if (queue && queue instanceof ReplaySubject_1.ReplaySubject) {
                    subscription.add(queue.subscribe(_this.destination));
                }
            };
            socket.onerror = function (e) {
                _this._resetState();
                observer.error(e);
            };
            socket.onclose = function (e) {
                _this._resetState();
                var closeObserver = _this.closeObserver;
                if (closeObserver) {
                    closeObserver.next(e);
                }
                if (e.wasClean) {
                    observer.complete();
                }
                else {
                    observer.error(e);
                }
            };
            socket.onmessage = function (e) {
                var result = tryCatch_1.tryCatch(_this.resultSelector)(e);
                if (result === errorObject.errorObject) {
                    observer.error(errorObject.errorObject.e);
                }
                else {
                    observer.next(result);
                }
            };
        };
        /** @deprecated internal use only */ WebSocketSubject.prototype._subscribe = function (subscriber) {
            var _this = this;
            var source = this.source;
            if (source) {
                return source.subscribe(subscriber);
            }
            if (!this.socket) {
                this._connectSocket();
            }
            var subscription = new Subscription_1.Subscription();
            subscription.add(this._output.subscribe(subscriber));
            subscription.add(function () {
                var socket = _this.socket;
                if (_this._output.observers.length === 0) {
                    if (socket && socket.readyState === 1) {
                        socket.close();
                    }
                    _this._resetState();
                }
            });
            return subscription;
        };
        WebSocketSubject.prototype.unsubscribe = function () {
            var _a = this, source = _a.source, socket = _a.socket;
            if (socket && socket.readyState === 1) {
                socket.close();
                this._resetState();
            }
            _super.prototype.unsubscribe.call(this);
            if (!source) {
                this.destination = new ReplaySubject_1.ReplaySubject();
            }
        };
        return WebSocketSubject;
    }(Subject_1.AnonymousSubject));
    var WebSocketSubject_2 = WebSocketSubject;


    var WebSocketSubject_1 = {
    	WebSocketSubject: WebSocketSubject_2
    };

    var webSocket_1 = WebSocketSubject_1.WebSocketSubject.create;


    var webSocket = {
    	webSocket: webSocket_1
    };

    Observable_1.Observable.webSocket = webSocket.webSocket;

    var __extends$10 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };


    /**
     * Buffers the source Observable values until `closingNotifier` emits.
     *
     * <span class="informal">Collects values from the past as an array, and emits
     * that array only when another Observable emits.</span>
     *
     * <img src="./img/buffer.png" width="100%">
     *
     * Buffers the incoming Observable values until the given `closingNotifier`
     * Observable emits a value, at which point it emits the buffer on the output
     * Observable and starts a new buffer internally, awaiting the next time
     * `closingNotifier` emits.
     *
     * @example <caption>On every click, emit array of most recent interval events</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var interval = Rx.Observable.interval(1000);
     * var buffered = interval.buffer(clicks);
     * buffered.subscribe(x => console.log(x));
     *
     * @see {@link bufferCount}
     * @see {@link bufferTime}
     * @see {@link bufferToggle}
     * @see {@link bufferWhen}
     * @see {@link window}
     *
     * @param {Observable<any>} closingNotifier An Observable that signals the
     * buffer to be emitted on the output Observable.
     * @return {Observable<T[]>} An Observable of buffers, which are arrays of
     * values.
     * @method buffer
     * @owner Observable
     */
    function buffer(closingNotifier) {
        return function bufferOperatorFunction(source) {
            return source.lift(new BufferOperator(closingNotifier));
        };
    }
    var buffer_2 = buffer;
    var BufferOperator = (function () {
        function BufferOperator(closingNotifier) {
            this.closingNotifier = closingNotifier;
        }
        BufferOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(new BufferSubscriber(subscriber, this.closingNotifier));
        };
        return BufferOperator;
    }());
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var BufferSubscriber = (function (_super) {
        __extends$10(BufferSubscriber, _super);
        function BufferSubscriber(destination, closingNotifier) {
            _super.call(this, destination);
            this.buffer = [];
            this.add(subscribeToResult_1.subscribeToResult(this, closingNotifier));
        }
        BufferSubscriber.prototype._next = function (value) {
            this.buffer.push(value);
        };
        BufferSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
            var buffer = this.buffer;
            this.buffer = [];
            this.destination.next(buffer);
        };
        return BufferSubscriber;
    }(OuterSubscriber_1.OuterSubscriber));


    var buffer_1 = {
    	buffer: buffer_2
    };

    /**
     * Buffers the source Observable values until `closingNotifier` emits.
     *
     * <span class="informal">Collects values from the past as an array, and emits
     * that array only when another Observable emits.</span>
     *
     * <img src="./img/buffer.png" width="100%">
     *
     * Buffers the incoming Observable values until the given `closingNotifier`
     * Observable emits a value, at which point it emits the buffer on the output
     * Observable and starts a new buffer internally, awaiting the next time
     * `closingNotifier` emits.
     *
     * @example <caption>On every click, emit array of most recent interval events</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var interval = Rx.Observable.interval(1000);
     * var buffered = interval.buffer(clicks);
     * buffered.subscribe(x => console.log(x));
     *
     * @see {@link bufferCount}
     * @see {@link bufferTime}
     * @see {@link bufferToggle}
     * @see {@link bufferWhen}
     * @see {@link window}
     *
     * @param {Observable<any>} closingNotifier An Observable that signals the
     * buffer to be emitted on the output Observable.
     * @return {Observable<T[]>} An Observable of buffers, which are arrays of
     * values.
     * @method buffer
     * @owner Observable
     */
    function buffer$1(closingNotifier) {
        return buffer_1.buffer(closingNotifier)(this);
    }
    var buffer_3 = buffer$1;


    var buffer_2$1 = {
    	buffer: buffer_3
    };

    Observable_1.Observable.prototype.buffer = buffer_2$1.buffer;

    var __extends$11 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };

    /**
     * Buffers the source Observable values until the size hits the maximum
     * `bufferSize` given.
     *
     * <span class="informal">Collects values from the past as an array, and emits
     * that array only when its size reaches `bufferSize`.</span>
     *
     * <img src="./img/bufferCount.png" width="100%">
     *
     * Buffers a number of values from the source Observable by `bufferSize` then
     * emits the buffer and clears it, and starts a new buffer each
     * `startBufferEvery` values. If `startBufferEvery` is not provided or is
     * `null`, then new buffers are started immediately at the start of the source
     * and when each buffer closes and is emitted.
     *
     * @example <caption>Emit the last two click events as an array</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var buffered = clicks.bufferCount(2);
     * buffered.subscribe(x => console.log(x));
     *
     * @example <caption>On every click, emit the last two click events as an array</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var buffered = clicks.bufferCount(2, 1);
     * buffered.subscribe(x => console.log(x));
     *
     * @see {@link buffer}
     * @see {@link bufferTime}
     * @see {@link bufferToggle}
     * @see {@link bufferWhen}
     * @see {@link pairwise}
     * @see {@link windowCount}
     *
     * @param {number} bufferSize The maximum size of the buffer emitted.
     * @param {number} [startBufferEvery] Interval at which to start a new buffer.
     * For example if `startBufferEvery` is `2`, then a new buffer will be started
     * on every other value from the source. A new buffer is started at the
     * beginning of the source by default.
     * @return {Observable<T[]>} An Observable of arrays of buffered values.
     * @method bufferCount
     * @owner Observable
     */
    function bufferCount(bufferSize, startBufferEvery) {
        if (startBufferEvery === void 0) { startBufferEvery = null; }
        return function bufferCountOperatorFunction(source) {
            return source.lift(new BufferCountOperator(bufferSize, startBufferEvery));
        };
    }
    var bufferCount_2 = bufferCount;
    var BufferCountOperator = (function () {
        function BufferCountOperator(bufferSize, startBufferEvery) {
            this.bufferSize = bufferSize;
            this.startBufferEvery = startBufferEvery;
            if (!startBufferEvery || bufferSize === startBufferEvery) {
                this.subscriberClass = BufferCountSubscriber;
            }
            else {
                this.subscriberClass = BufferSkipCountSubscriber;
            }
        }
        BufferCountOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(new this.subscriberClass(subscriber, this.bufferSize, this.startBufferEvery));
        };
        return BufferCountOperator;
    }());
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var BufferCountSubscriber = (function (_super) {
        __extends$11(BufferCountSubscriber, _super);
        function BufferCountSubscriber(destination, bufferSize) {
            _super.call(this, destination);
            this.bufferSize = bufferSize;
            this.buffer = [];
        }
        BufferCountSubscriber.prototype._next = function (value) {
            var buffer = this.buffer;
            buffer.push(value);
            if (buffer.length == this.bufferSize) {
                this.destination.next(buffer);
                this.buffer = [];
            }
        };
        BufferCountSubscriber.prototype._complete = function () {
            var buffer = this.buffer;
            if (buffer.length > 0) {
                this.destination.next(buffer);
            }
            _super.prototype._complete.call(this);
        };
        return BufferCountSubscriber;
    }(Subscriber_1.Subscriber));
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var BufferSkipCountSubscriber = (function (_super) {
        __extends$11(BufferSkipCountSubscriber, _super);
        function BufferSkipCountSubscriber(destination, bufferSize, startBufferEvery) {
            _super.call(this, destination);
            this.bufferSize = bufferSize;
            this.startBufferEvery = startBufferEvery;
            this.buffers = [];
            this.count = 0;
        }
        BufferSkipCountSubscriber.prototype._next = function (value) {
            var _a = this, bufferSize = _a.bufferSize, startBufferEvery = _a.startBufferEvery, buffers = _a.buffers, count = _a.count;
            this.count++;
            if (count % startBufferEvery === 0) {
                buffers.push([]);
            }
            for (var i = buffers.length; i--;) {
                var buffer = buffers[i];
                buffer.push(value);
                if (buffer.length === bufferSize) {
                    buffers.splice(i, 1);
                    this.destination.next(buffer);
                }
            }
        };
        BufferSkipCountSubscriber.prototype._complete = function () {
            var _a = this, buffers = _a.buffers, destination = _a.destination;
            while (buffers.length > 0) {
                var buffer = buffers.shift();
                if (buffer.length > 0) {
                    destination.next(buffer);
                }
            }
            _super.prototype._complete.call(this);
        };
        return BufferSkipCountSubscriber;
    }(Subscriber_1.Subscriber));


    var bufferCount_1 = {
    	bufferCount: bufferCount_2
    };

    /**
     * Buffers the source Observable values until the size hits the maximum
     * `bufferSize` given.
     *
     * <span class="informal">Collects values from the past as an array, and emits
     * that array only when its size reaches `bufferSize`.</span>
     *
     * <img src="./img/bufferCount.png" width="100%">
     *
     * Buffers a number of values from the source Observable by `bufferSize` then
     * emits the buffer and clears it, and starts a new buffer each
     * `startBufferEvery` values. If `startBufferEvery` is not provided or is
     * `null`, then new buffers are started immediately at the start of the source
     * and when each buffer closes and is emitted.
     *
     * @example <caption>Emit the last two click events as an array</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var buffered = clicks.bufferCount(2);
     * buffered.subscribe(x => console.log(x));
     *
     * @example <caption>On every click, emit the last two click events as an array</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var buffered = clicks.bufferCount(2, 1);
     * buffered.subscribe(x => console.log(x));
     *
     * @see {@link buffer}
     * @see {@link bufferTime}
     * @see {@link bufferToggle}
     * @see {@link bufferWhen}
     * @see {@link pairwise}
     * @see {@link windowCount}
     *
     * @param {number} bufferSize The maximum size of the buffer emitted.
     * @param {number} [startBufferEvery] Interval at which to start a new buffer.
     * For example if `startBufferEvery` is `2`, then a new buffer will be started
     * on every other value from the source. A new buffer is started at the
     * beginning of the source by default.
     * @return {Observable<T[]>} An Observable of arrays of buffered values.
     * @method bufferCount
     * @owner Observable
     */
    function bufferCount$1(bufferSize, startBufferEvery) {
        if (startBufferEvery === void 0) { startBufferEvery = null; }
        return bufferCount_1.bufferCount(bufferSize, startBufferEvery)(this);
    }
    var bufferCount_3 = bufferCount$1;


    var bufferCount_2$1 = {
    	bufferCount: bufferCount_3
    };

    Observable_1.Observable.prototype.bufferCount = bufferCount_2$1.bufferCount;

    var __extends$12 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };



    /* tslint:enable:max-line-length */
    /**
     * Buffers the source Observable values for a specific time period.
     *
     * <span class="informal">Collects values from the past as an array, and emits
     * those arrays periodically in time.</span>
     *
     * <img src="./img/bufferTime.png" width="100%">
     *
     * Buffers values from the source for a specific time duration `bufferTimeSpan`.
     * Unless the optional argument `bufferCreationInterval` is given, it emits and
     * resets the buffer every `bufferTimeSpan` milliseconds. If
     * `bufferCreationInterval` is given, this operator opens the buffer every
     * `bufferCreationInterval` milliseconds and closes (emits and resets) the
     * buffer every `bufferTimeSpan` milliseconds. When the optional argument
     * `maxBufferSize` is specified, the buffer will be closed either after
     * `bufferTimeSpan` milliseconds or when it contains `maxBufferSize` elements.
     *
     * @example <caption>Every second, emit an array of the recent click events</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var buffered = clicks.bufferTime(1000);
     * buffered.subscribe(x => console.log(x));
     *
     * @example <caption>Every 5 seconds, emit the click events from the next 2 seconds</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var buffered = clicks.bufferTime(2000, 5000);
     * buffered.subscribe(x => console.log(x));
     *
     * @see {@link buffer}
     * @see {@link bufferCount}
     * @see {@link bufferToggle}
     * @see {@link bufferWhen}
     * @see {@link windowTime}
     *
     * @param {number} bufferTimeSpan The amount of time to fill each buffer array.
     * @param {number} [bufferCreationInterval] The interval at which to start new
     * buffers.
     * @param {number} [maxBufferSize] The maximum buffer size.
     * @param {Scheduler} [scheduler=async] The scheduler on which to schedule the
     * intervals that determine buffer boundaries.
     * @return {Observable<T[]>} An observable of arrays of buffered values.
     * @method bufferTime
     * @owner Observable
     */
    function bufferTime(bufferTimeSpan) {
        var length = arguments.length;
        var scheduler = async.async;
        if (isScheduler_1.isScheduler(arguments[arguments.length - 1])) {
            scheduler = arguments[arguments.length - 1];
            length--;
        }
        var bufferCreationInterval = null;
        if (length >= 2) {
            bufferCreationInterval = arguments[1];
        }
        var maxBufferSize = Number.POSITIVE_INFINITY;
        if (length >= 3) {
            maxBufferSize = arguments[2];
        }
        return function bufferTimeOperatorFunction(source) {
            return source.lift(new BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler));
        };
    }
    var bufferTime_2 = bufferTime;
    var BufferTimeOperator = (function () {
        function BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {
            this.bufferTimeSpan = bufferTimeSpan;
            this.bufferCreationInterval = bufferCreationInterval;
            this.maxBufferSize = maxBufferSize;
            this.scheduler = scheduler;
        }
        BufferTimeOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(new BufferTimeSubscriber(subscriber, this.bufferTimeSpan, this.bufferCreationInterval, this.maxBufferSize, this.scheduler));
        };
        return BufferTimeOperator;
    }());
    var Context = (function () {
        function Context() {
            this.buffer = [];
        }
        return Context;
    }());
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var BufferTimeSubscriber = (function (_super) {
        __extends$12(BufferTimeSubscriber, _super);
        function BufferTimeSubscriber(destination, bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {
            _super.call(this, destination);
            this.bufferTimeSpan = bufferTimeSpan;
            this.bufferCreationInterval = bufferCreationInterval;
            this.maxBufferSize = maxBufferSize;
            this.scheduler = scheduler;
            this.contexts = [];
            var context = this.openContext();
            this.timespanOnly = bufferCreationInterval == null || bufferCreationInterval < 0;
            if (this.timespanOnly) {
                var timeSpanOnlyState = { subscriber: this, context: context, bufferTimeSpan: bufferTimeSpan };
                this.add(context.closeAction = scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
            }
            else {
                var closeState = { subscriber: this, context: context };
                var creationState = { bufferTimeSpan: bufferTimeSpan, bufferCreationInterval: bufferCreationInterval, subscriber: this, scheduler: scheduler };
                this.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, closeState));
                this.add(scheduler.schedule(dispatchBufferCreation, bufferCreationInterval, creationState));
            }
        }
        BufferTimeSubscriber.prototype._next = function (value) {
            var contexts = this.contexts;
            var len = contexts.length;
            var filledBufferContext;
            for (var i = 0; i < len; i++) {
                var context = contexts[i];
                var buffer = context.buffer;
                buffer.push(value);
                if (buffer.length == this.maxBufferSize) {
                    filledBufferContext = context;
                }
            }
            if (filledBufferContext) {
                this.onBufferFull(filledBufferContext);
            }
        };
        BufferTimeSubscriber.prototype._error = function (err) {
            this.contexts.length = 0;
            _super.prototype._error.call(this, err);
        };
        BufferTimeSubscriber.prototype._complete = function () {
            var _a = this, contexts = _a.contexts, destination = _a.destination;
            while (contexts.length > 0) {
                var context = contexts.shift();
                destination.next(context.buffer);
            }
            _super.prototype._complete.call(this);
        };
        /** @deprecated internal use only */ BufferTimeSubscriber.prototype._unsubscribe = function () {
            this.contexts = null;
        };
        BufferTimeSubscriber.prototype.onBufferFull = function (context) {
            this.closeContext(context);
            var closeAction = context.closeAction;
            closeAction.unsubscribe();
            this.remove(closeAction);
            if (!this.closed && this.timespanOnly) {
                context = this.openContext();
                var bufferTimeSpan = this.bufferTimeSpan;
                var timeSpanOnlyState = { subscriber: this, context: context, bufferTimeSpan: bufferTimeSpan };
                this.add(context.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
            }
        };
        BufferTimeSubscriber.prototype.openContext = function () {
            var context = new Context();
            this.contexts.push(context);
            return context;
        };
        BufferTimeSubscriber.prototype.closeContext = function (context) {
            this.destination.next(context.buffer);
            var contexts = this.contexts;
            var spliceIndex = contexts ? contexts.indexOf(context) : -1;
            if (spliceIndex >= 0) {
                contexts.splice(contexts.indexOf(context), 1);
            }
        };
        return BufferTimeSubscriber;
    }(Subscriber_1.Subscriber));
    function dispatchBufferTimeSpanOnly(state) {
        var subscriber = state.subscriber;
        var prevContext = state.context;
        if (prevContext) {
            subscriber.closeContext(prevContext);
        }
        if (!subscriber.closed) {
            state.context = subscriber.openContext();
            state.context.closeAction = this.schedule(state, state.bufferTimeSpan);
        }
    }
    function dispatchBufferCreation(state) {
        var bufferCreationInterval = state.bufferCreationInterval, bufferTimeSpan = state.bufferTimeSpan, subscriber = state.subscriber, scheduler = state.scheduler;
        var context = subscriber.openContext();
        var action = this;
        if (!subscriber.closed) {
            subscriber.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, { subscriber: subscriber, context: context }));
            action.schedule(state, bufferCreationInterval);
        }
    }
    function dispatchBufferClose(arg) {
        var subscriber = arg.subscriber, context = arg.context;
        subscriber.closeContext(context);
    }


    var bufferTime_1 = {
    	bufferTime: bufferTime_2
    };

    /* tslint:enable:max-line-length */
    /**
     * Buffers the source Observable values for a specific time period.
     *
     * <span class="informal">Collects values from the past as an array, and emits
     * those arrays periodically in time.</span>
     *
     * <img src="./img/bufferTime.png" width="100%">
     *
     * Buffers values from the source for a specific time duration `bufferTimeSpan`.
     * Unless the optional argument `bufferCreationInterval` is given, it emits and
     * resets the buffer every `bufferTimeSpan` milliseconds. If
     * `bufferCreationInterval` is given, this operator opens the buffer every
     * `bufferCreationInterval` milliseconds and closes (emits and resets) the
     * buffer every `bufferTimeSpan` milliseconds. When the optional argument
     * `maxBufferSize` is specified, the buffer will be closed either after
     * `bufferTimeSpan` milliseconds or when it contains `maxBufferSize` elements.
     *
     * @example <caption>Every second, emit an array of the recent click events</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var buffered = clicks.bufferTime(1000);
     * buffered.subscribe(x => console.log(x));
     *
     * @example <caption>Every 5 seconds, emit the click events from the next 2 seconds</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var buffered = clicks.bufferTime(2000, 5000);
     * buffered.subscribe(x => console.log(x));
     *
     * @see {@link buffer}
     * @see {@link bufferCount}
     * @see {@link bufferToggle}
     * @see {@link bufferWhen}
     * @see {@link windowTime}
     *
     * @param {number} bufferTimeSpan The amount of time to fill each buffer array.
     * @param {number} [bufferCreationInterval] The interval at which to start new
     * buffers.
     * @param {number} [maxBufferSize] The maximum buffer size.
     * @param {Scheduler} [scheduler=async] The scheduler on which to schedule the
     * intervals that determine buffer boundaries.
     * @return {Observable<T[]>} An observable of arrays of buffered values.
     * @method bufferTime
     * @owner Observable
     */
    function bufferTime$1(bufferTimeSpan) {
        var length = arguments.length;
        var scheduler = async.async;
        if (isScheduler_1.isScheduler(arguments[arguments.length - 1])) {
            scheduler = arguments[arguments.length - 1];
            length--;
        }
        var bufferCreationInterval = null;
        if (length >= 2) {
            bufferCreationInterval = arguments[1];
        }
        var maxBufferSize = Number.POSITIVE_INFINITY;
        if (length >= 3) {
            maxBufferSize = arguments[2];
        }
        return bufferTime_1.bufferTime(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler)(this);
    }
    var bufferTime_3 = bufferTime$1;


    var bufferTime_2$1 = {
    	bufferTime: bufferTime_3
    };

    Observable_1.Observable.prototype.bufferTime = bufferTime_2$1.bufferTime;

    var __extends$13 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };



    /**
     * Buffers the source Observable values starting from an emission from
     * `openings` and ending when the output of `closingSelector` emits.
     *
     * <span class="informal">Collects values from the past as an array. Starts
     * collecting only when `opening` emits, and calls the `closingSelector`
     * function to get an Observable that tells when to close the buffer.</span>
     *
     * <img src="./img/bufferToggle.png" width="100%">
     *
     * Buffers values from the source by opening the buffer via signals from an
     * Observable provided to `openings`, and closing and sending the buffers when
     * a Subscribable or Promise returned by the `closingSelector` function emits.
     *
     * @example <caption>Every other second, emit the click events from the next 500ms</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var openings = Rx.Observable.interval(1000);
     * var buffered = clicks.bufferToggle(openings, i =>
     *   i % 2 ? Rx.Observable.interval(500) : Rx.Observable.empty()
     * );
     * buffered.subscribe(x => console.log(x));
     *
     * @see {@link buffer}
     * @see {@link bufferCount}
     * @see {@link bufferTime}
     * @see {@link bufferWhen}
     * @see {@link windowToggle}
     *
     * @param {SubscribableOrPromise<O>} openings A Subscribable or Promise of notifications to start new
     * buffers.
     * @param {function(value: O): SubscribableOrPromise} closingSelector A function that takes
     * the value emitted by the `openings` observable and returns a Subscribable or Promise,
     * which, when it emits, signals that the associated buffer should be emitted
     * and cleared.
     * @return {Observable<T[]>} An observable of arrays of buffered values.
     * @method bufferToggle
     * @owner Observable
     */
    function bufferToggle(openings, closingSelector) {
        return function bufferToggleOperatorFunction(source) {
            return source.lift(new BufferToggleOperator(openings, closingSelector));
        };
    }
    var bufferToggle_2 = bufferToggle;
    var BufferToggleOperator = (function () {
        function BufferToggleOperator(openings, closingSelector) {
            this.openings = openings;
            this.closingSelector = closingSelector;
        }
        BufferToggleOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(new BufferToggleSubscriber(subscriber, this.openings, this.closingSelector));
        };
        return BufferToggleOperator;
    }());
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var BufferToggleSubscriber = (function (_super) {
        __extends$13(BufferToggleSubscriber, _super);
        function BufferToggleSubscriber(destination, openings, closingSelector) {
            _super.call(this, destination);
            this.openings = openings;
            this.closingSelector = closingSelector;
            this.contexts = [];
            this.add(subscribeToResult_1.subscribeToResult(this, openings));
        }
        BufferToggleSubscriber.prototype._next = function (value) {
            var contexts = this.contexts;
            var len = contexts.length;
            for (var i = 0; i < len; i++) {
                contexts[i].buffer.push(value);
            }
        };
        BufferToggleSubscriber.prototype._error = function (err) {
            var contexts = this.contexts;
            while (contexts.length > 0) {
                var context = contexts.shift();
                context.subscription.unsubscribe();
                context.buffer = null;
                context.subscription = null;
            }
            this.contexts = null;
            _super.prototype._error.call(this, err);
        };
        BufferToggleSubscriber.prototype._complete = function () {
            var contexts = this.contexts;
            while (contexts.length > 0) {
                var context = contexts.shift();
                this.destination.next(context.buffer);
                context.subscription.unsubscribe();
                context.buffer = null;
                context.subscription = null;
            }
            this.contexts = null;
            _super.prototype._complete.call(this);
        };
        BufferToggleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
            outerValue ? this.closeBuffer(outerValue) : this.openBuffer(innerValue);
        };
        BufferToggleSubscriber.prototype.notifyComplete = function (innerSub) {
            this.closeBuffer(innerSub.context);
        };
        BufferToggleSubscriber.prototype.openBuffer = function (value) {
            try {
                var closingSelector = this.closingSelector;
                var closingNotifier = closingSelector.call(this, value);
                if (closingNotifier) {
                    this.trySubscribe(closingNotifier);
                }
            }
            catch (err) {
                this._error(err);
            }
        };
        BufferToggleSubscriber.prototype.closeBuffer = function (context) {
            var contexts = this.contexts;
            if (contexts && context) {
                var buffer = context.buffer, subscription = context.subscription;
                this.destination.next(buffer);
                contexts.splice(contexts.indexOf(context), 1);
                this.remove(subscription);
                subscription.unsubscribe();
            }
        };
        BufferToggleSubscriber.prototype.trySubscribe = function (closingNotifier) {
            var contexts = this.contexts;
            var buffer = [];
            var subscription = new Subscription_1.Subscription();
            var context = { buffer: buffer, subscription: subscription };
            contexts.push(context);
            var innerSubscription = subscribeToResult_1.subscribeToResult(this, closingNotifier, context);
            if (!innerSubscription || innerSubscription.closed) {
                this.closeBuffer(context);
            }
            else {
                innerSubscription.context = context;
                this.add(innerSubscription);
                subscription.add(innerSubscription);
            }
        };
        return BufferToggleSubscriber;
    }(OuterSubscriber_1.OuterSubscriber));


    var bufferToggle_1 = {
    	bufferToggle: bufferToggle_2
    };

    /**
     * Buffers the source Observable values starting from an emission from
     * `openings` and ending when the output of `closingSelector` emits.
     *
     * <span class="informal">Collects values from the past as an array. Starts
     * collecting only when `opening` emits, and calls the `closingSelector`
     * function to get an Observable that tells when to close the buffer.</span>
     *
     * <img src="./img/bufferToggle.png" width="100%">
     *
     * Buffers values from the source by opening the buffer via signals from an
     * Observable provided to `openings`, and closing and sending the buffers when
     * a Subscribable or Promise returned by the `closingSelector` function emits.
     *
     * @example <caption>Every other second, emit the click events from the next 500ms</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var openings = Rx.Observable.interval(1000);
     * var buffered = clicks.bufferToggle(openings, i =>
     *   i % 2 ? Rx.Observable.interval(500) : Rx.Observable.empty()
     * );
     * buffered.subscribe(x => console.log(x));
     *
     * @see {@link buffer}
     * @see {@link bufferCount}
     * @see {@link bufferTime}
     * @see {@link bufferWhen}
     * @see {@link windowToggle}
     *
     * @param {SubscribableOrPromise<O>} openings A Subscribable or Promise of notifications to start new
     * buffers.
     * @param {function(value: O): SubscribableOrPromise} closingSelector A function that takes
     * the value emitted by the `openings` observable and returns a Subscribable or Promise,
     * which, when it emits, signals that the associated buffer should be emitted
     * and cleared.
     * @return {Observable<T[]>} An observable of arrays of buffered values.
     * @method bufferToggle
     * @owner Observable
     */
    function bufferToggle$1(openings, closingSelector) {
        return bufferToggle_1.bufferToggle(openings, closingSelector)(this);
    }
    var bufferToggle_3 = bufferToggle$1;


    var bufferToggle_2$1 = {
    	bufferToggle: bufferToggle_3
    };

    Observable_1.Observable.prototype.bufferToggle = bufferToggle_2$1.bufferToggle;

    var __extends$14 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };





    /**
     * Buffers the source Observable values, using a factory function of closing
     * Observables to determine when to close, emit, and reset the buffer.
     *
     * <span class="informal">Collects values from the past as an array. When it
     * starts collecting values, it calls a function that returns an Observable that
     * tells when to close the buffer and restart collecting.</span>
     *
     * <img src="./img/bufferWhen.png" width="100%">
     *
     * Opens a buffer immediately, then closes the buffer when the observable
     * returned by calling `closingSelector` function emits a value. When it closes
     * the buffer, it immediately opens a new buffer and repeats the process.
     *
     * @example <caption>Emit an array of the last clicks every [1-5] random seconds</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var buffered = clicks.bufferWhen(() =>
     *   Rx.Observable.interval(1000 + Math.random() * 4000)
     * );
     * buffered.subscribe(x => console.log(x));
     *
     * @see {@link buffer}
     * @see {@link bufferCount}
     * @see {@link bufferTime}
     * @see {@link bufferToggle}
     * @see {@link windowWhen}
     *
     * @param {function(): Observable} closingSelector A function that takes no
     * arguments and returns an Observable that signals buffer closure.
     * @return {Observable<T[]>} An observable of arrays of buffered values.
     * @method bufferWhen
     * @owner Observable
     */
    function bufferWhen(closingSelector) {
        return function (source) {
            return source.lift(new BufferWhenOperator(closingSelector));
        };
    }
    var bufferWhen_2 = bufferWhen;
    var BufferWhenOperator = (function () {
        function BufferWhenOperator(closingSelector) {
            this.closingSelector = closingSelector;
        }
        BufferWhenOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(new BufferWhenSubscriber(subscriber, this.closingSelector));
        };
        return BufferWhenOperator;
    }());
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var BufferWhenSubscriber = (function (_super) {
        __extends$14(BufferWhenSubscriber, _super);
        function BufferWhenSubscriber(destination, closingSelector) {
            _super.call(this, destination);
            this.closingSelector = closingSelector;
            this.subscribing = false;
            this.openBuffer();
        }
        BufferWhenSubscriber.prototype._next = function (value) {
            this.buffer.push(value);
        };
        BufferWhenSubscriber.prototype._complete = function () {
            var buffer = this.buffer;
            if (buffer) {
                this.destination.next(buffer);
            }
            _super.prototype._complete.call(this);
        };
        /** @deprecated internal use only */ BufferWhenSubscriber.prototype._unsubscribe = function () {
            this.buffer = null;
            this.subscribing = false;
        };
        BufferWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
            this.openBuffer();
        };
        BufferWhenSubscriber.prototype.notifyComplete = function () {
            if (this.subscribing) {
                this.complete();
            }
            else {
                this.openBuffer();
            }
        };
        BufferWhenSubscriber.prototype.openBuffer = function () {
            var closingSubscription = this.closingSubscription;
            if (closingSubscription) {
                this.remove(closingSubscription);
                closingSubscription.unsubscribe();
            }
            var buffer = this.buffer;
            if (this.buffer) {
                this.destination.next(buffer);
            }
            this.buffer = [];
            var closingNotifier = tryCatch_1.tryCatch(this.closingSelector)();
            if (closingNotifier === errorObject.errorObject) {
                this.error(errorObject.errorObject.e);
            }
            else {
                closingSubscription = new Subscription_1.Subscription();
                this.closingSubscription = closingSubscription;
                this.add(closingSubscription);
                this.subscribing = true;
                closingSubscription.add(subscribeToResult_1.subscribeToResult(this, closingNotifier));
                this.subscribing = false;
            }
        };
        return BufferWhenSubscriber;
    }(OuterSubscriber_1.OuterSubscriber));


    var bufferWhen_1 = {
    	bufferWhen: bufferWhen_2
    };

    /**
     * Buffers the source Observable values, using a factory function of closing
     * Observables to determine when to close, emit, and reset the buffer.
     *
     * <span class="informal">Collects values from the past as an array. When it
     * starts collecting values, it calls a function that returns an Observable that
     * tells when to close the buffer and restart collecting.</span>
     *
     * <img src="./img/bufferWhen.png" width="100%">
     *
     * Opens a buffer immediately, then closes the buffer when the observable
     * returned by calling `closingSelector` function emits a value. When it closes
     * the buffer, it immediately opens a new buffer and repeats the process.
     *
     * @example <caption>Emit an array of the last clicks every [1-5] random seconds</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var buffered = clicks.bufferWhen(() =>
     *   Rx.Observable.interval(1000 + Math.random() * 4000)
     * );
     * buffered.subscribe(x => console.log(x));
     *
     * @see {@link buffer}
     * @see {@link bufferCount}
     * @see {@link bufferTime}
     * @see {@link bufferToggle}
     * @see {@link windowWhen}
     *
     * @param {function(): Observable} closingSelector A function that takes no
     * arguments and returns an Observable that signals buffer closure.
     * @return {Observable<T[]>} An observable of arrays of buffered values.
     * @method bufferWhen
     * @owner Observable
     */
    function bufferWhen$1(closingSelector) {
        return bufferWhen_1.bufferWhen(closingSelector)(this);
    }
    var bufferWhen_3 = bufferWhen$1;


    var bufferWhen_2$1 = {
    	bufferWhen: bufferWhen_3
    };

    Observable_1.Observable.prototype.bufferWhen = bufferWhen_2$1.bufferWhen;

    var __extends$15 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };


    /**
     * Catches errors on the observable to be handled by returning a new observable or throwing an error.
     *
     * <img src="./img/catch.png" width="100%">
     *
     * @example <caption>Continues with a different Observable when there's an error</caption>
     *
     * Observable.of(1, 2, 3, 4, 5)
     *   .map(n => {
     * 	   if (n == 4) {
     * 	     throw 'four!';
     *     }
     *	   return n;
     *   })
     *   .catch(err => Observable.of('I', 'II', 'III', 'IV', 'V'))
     *   .subscribe(x => console.log(x));
     *   // 1, 2, 3, I, II, III, IV, V
     *
     * @example <caption>Retries the caught source Observable again in case of error, similar to retry() operator</caption>
     *
     * Observable.of(1, 2, 3, 4, 5)
     *   .map(n => {
     * 	   if (n === 4) {
     * 	     throw 'four!';
     *     }
     * 	   return n;
     *   })
     *   .catch((err, caught) => caught)
     *   .take(30)
     *   .subscribe(x => console.log(x));
     *   // 1, 2, 3, 1, 2, 3, ...
     *
     * @example <caption>Throws a new error when the source Observable throws an error</caption>
     *
     * Observable.of(1, 2, 3, 4, 5)
     *   .map(n => {
     *     if (n == 4) {
     *       throw 'four!';
     *     }
     *     return n;
     *   })
     *   .catch(err => {
     *     throw 'error in source. Details: ' + err;
     *   })
     *   .subscribe(
     *     x => console.log(x),
     *     err => console.log(err)
     *   );
     *   // 1, 2, 3, error in source. Details: four!
     *
     * @param {function} selector a function that takes as arguments `err`, which is the error, and `caught`, which
     *  is the source observable, in case you'd like to "retry" that observable by returning it again. Whatever observable
     *  is returned by the `selector` will be used to continue the observable chain.
     * @return {Observable} An observable that originates from either the source or the observable returned by the
     *  catch `selector` function.
     * @name catchError
     */
    function catchError(selector) {
        return function catchErrorOperatorFunction(source) {
            var operator = new CatchOperator(selector);
            var caught = source.lift(operator);
            return (operator.caught = caught);
        };
    }
    var catchError_2 = catchError;
    var CatchOperator = (function () {
        function CatchOperator(selector) {
            this.selector = selector;
        }
        CatchOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));
        };
        return CatchOperator;
    }());
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var CatchSubscriber = (function (_super) {
        __extends$15(CatchSubscriber, _super);
        function CatchSubscriber(destination, selector, caught) {
            _super.call(this, destination);
            this.selector = selector;
            this.caught = caught;
        }
        // NOTE: overriding `error` instead of `_error` because we don't want
        // to have this flag this subscriber as `isStopped`. We can mimic the
        // behavior of the RetrySubscriber (from the `retry` operator), where
        // we unsubscribe from our source chain, reset our Subscriber flags,
        // then subscribe to the selector result.
        CatchSubscriber.prototype.error = function (err) {
            if (!this.isStopped) {
                var result = void 0;
                try {
                    result = this.selector(err, this.caught);
                }
                catch (err2) {
                    _super.prototype.error.call(this, err2);
                    return;
                }
                this._unsubscribeAndRecycle();
                this.add(subscribeToResult_1.subscribeToResult(this, result));
            }
        };
        return CatchSubscriber;
    }(OuterSubscriber_1.OuterSubscriber));


    var catchError_1 = {
    	catchError: catchError_2
    };

    /**
     * Catches errors on the observable to be handled by returning a new observable or throwing an error.
     *
     * <img src="./img/catch.png" width="100%">
     *
     * @example <caption>Continues with a different Observable when there's an error</caption>
     *
     * Observable.of(1, 2, 3, 4, 5)
     *   .map(n => {
     * 	   if (n == 4) {
     * 	     throw 'four!';
     *     }
     *	   return n;
     *   })
     *   .catch(err => Observable.of('I', 'II', 'III', 'IV', 'V'))
     *   .subscribe(x => console.log(x));
     *   // 1, 2, 3, I, II, III, IV, V
     *
     * @example <caption>Retries the caught source Observable again in case of error, similar to retry() operator</caption>
     *
     * Observable.of(1, 2, 3, 4, 5)
     *   .map(n => {
     * 	   if (n === 4) {
     * 	     throw 'four!';
     *     }
     * 	   return n;
     *   })
     *   .catch((err, caught) => caught)
     *   .take(30)
     *   .subscribe(x => console.log(x));
     *   // 1, 2, 3, 1, 2, 3, ...
     *
     * @example <caption>Throws a new error when the source Observable throws an error</caption>
     *
     * Observable.of(1, 2, 3, 4, 5)
     *   .map(n => {
     *     if (n == 4) {
     *       throw 'four!';
     *     }
     *     return n;
     *   })
     *   .catch(err => {
     *     throw 'error in source. Details: ' + err;
     *   })
     *   .subscribe(
     *     x => console.log(x),
     *     err => console.log(err)
     *   );
     *   // 1, 2, 3, error in source. Details: four!
     *
     * @param {function} selector a function that takes as arguments `err`, which is the error, and `caught`, which
     *  is the source observable, in case you'd like to "retry" that observable by returning it again. Whatever observable
     *  is returned by the `selector` will be used to continue the observable chain.
     * @return {Observable} An observable that originates from either the source or the observable returned by the
     *  catch `selector` function.
     * @method catch
     * @name catch
     * @owner Observable
     */
    function _catch(selector) {
        return catchError_1.catchError(selector)(this);
    }
    var _catch_2 = _catch;


    var _catch_1 = {
    	_catch: _catch_2
    };

    Observable_1.Observable.prototype.catch = _catch_1._catch;
    Observable_1.Observable.prototype._catch = _catch_1._catch;

    function combineAll(project) {
        return function (source) { return source.lift(new combineLatest_1.CombineLatestOperator(project)); };
    }
    var combineAll_2 = combineAll;


    var combineAll_1 = {
    	combineAll: combineAll_2
    };

    /**
     * Converts a higher-order Observable into a first-order Observable by waiting
     * for the outer Observable to complete, then applying {@link combineLatest}.
     *
     * <span class="informal">Flattens an Observable-of-Observables by applying
     * {@link combineLatest} when the Observable-of-Observables completes.</span>
     *
     * <img src="./img/combineAll.png" width="100%">
     *
     * Takes an Observable of Observables, and collects all Observables from it.
     * Once the outer Observable completes, it subscribes to all collected
     * Observables and combines their values using the {@link combineLatest}
     * strategy, such that:
     * - Every time an inner Observable emits, the output Observable emits.
     * - When the returned observable emits, it emits all of the latest values by:
     *   - If a `project` function is provided, it is called with each recent value
     *     from each inner Observable in whatever order they arrived, and the result
     *     of the `project` function is what is emitted by the output Observable.
     *   - If there is no `project` function, an array of all of the most recent
     *     values is emitted by the output Observable.
     *
     * @example <caption>Map two click events to a finite interval Observable, then apply combineAll</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var higherOrder = clicks.map(ev =>
     *   Rx.Observable.interval(Math.random()*2000).take(3)
     * ).take(2);
     * var result = higherOrder.combineAll();
     * result.subscribe(x => console.log(x));
     *
     * @see {@link combineLatest}
     * @see {@link mergeAll}
     *
     * @param {function} [project] An optional function to map the most recent
     * values from each inner Observable into a new result. Takes each of the most
     * recent values from each collected inner Observable as arguments, in order.
     * @return {Observable} An Observable of projected results or arrays of recent
     * values.
     * @method combineAll
     * @owner Observable
     */
    function combineAll$1(project) {
        return combineAll_1.combineAll(project)(this);
    }
    var combineAll_3 = combineAll$1;


    var combineAll_2$1 = {
    	combineAll: combineAll_3
    };

    Observable_1.Observable.prototype.combineAll = combineAll_2$1.combineAll;

    /* tslint:enable:max-line-length */
    /**
     * Combines multiple Observables to create an Observable whose values are
     * calculated from the latest values of each of its input Observables.
     *
     * <span class="informal">Whenever any input Observable emits a value, it
     * computes a formula using the latest values from all the inputs, then emits
     * the output of that formula.</span>
     *
     * <img src="./img/combineLatest.png" width="100%">
     *
     * `combineLatest` combines the values from this Observable with values from
     * Observables passed as arguments. This is done by subscribing to each
     * Observable, in order, and collecting an array of each of the most recent
     * values any time any of the input Observables emits, then either taking that
     * array and passing it as arguments to an optional `project` function and
     * emitting the return value of that, or just emitting the array of recent
     * values directly if there is no `project` function.
     *
     * @example <caption>Dynamically calculate the Body-Mass Index from an Observable of weight and one for height</caption>
     * var weight = Rx.Observable.of(70, 72, 76, 79, 75);
     * var height = Rx.Observable.of(1.76, 1.77, 1.78);
     * var bmi = weight.combineLatest(height, (w, h) => w / (h * h));
     * bmi.subscribe(x => console.log('BMI is ' + x));
     *
     * // With output to console:
     * // BMI is 24.212293388429753
     * // BMI is 23.93948099205209
     * // BMI is 23.671253629592222
     *
     * @see {@link combineAll}
     * @see {@link merge}
     * @see {@link withLatestFrom}
     *
     * @param {ObservableInput} other An input Observable to combine with the source
     * Observable. More than one input Observables may be given as argument.
     * @param {function} [project] An optional function to project the values from
     * the combined latest values into a new value on the output Observable.
     * @return {Observable} An Observable of projected values from the most recent
     * values from each input Observable, or an array of the most recent values from
     * each input Observable.
     * @method combineLatest
     * @owner Observable
     */
    function combineLatest$3() {
        var observables = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            observables[_i - 0] = arguments[_i];
        }
        return combineLatest_1.combineLatest.apply(void 0, observables)(this);
    }
    var combineLatest_3$1 = combineLatest$3;


    var combineLatest_2$2 = {
    	combineLatest: combineLatest_3$1
    };

    Observable_1.Observable.prototype.combineLatest = combineLatest_2$2.combineLatest;

    var concat_2$1 = concat_1;
    var concatStatic = concat_2$1.concat;
    /* tslint:enable:max-line-length */
    /**
     * Creates an output Observable which sequentially emits all values from every
     * given input Observable after the current Observable.
     *
     * <span class="informal">Concatenates multiple Observables together by
     * sequentially emitting their values, one Observable after the other.</span>
     *
     * <img src="./img/concat.png" width="100%">
     *
     * Joins this Observable with multiple other Observables by subscribing to them
     * one at a time, starting with the source, and merging their results into the
     * output Observable. Will wait for each Observable to complete before moving
     * on to the next.
     *
     * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>
     * var timer = Rx.Observable.interval(1000).take(4);
     * var sequence = Rx.Observable.range(1, 10);
     * var result = timer.concat(sequence);
     * result.subscribe(x => console.log(x));
     *
     * // results in:
     * // 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10
     *
     * @example <caption>Concatenate 3 Observables</caption>
     * var timer1 = Rx.Observable.interval(1000).take(10);
     * var timer2 = Rx.Observable.interval(2000).take(6);
     * var timer3 = Rx.Observable.interval(500).take(10);
     * var result = timer1.concat(timer2, timer3);
     * result.subscribe(x => console.log(x));
     *
     * // results in the following:
     * // (Prints to console sequentially)
     * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9
     * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5
     * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9
     *
     * @see {@link concatAll}
     * @see {@link concatMap}
     * @see {@link concatMapTo}
     *
     * @param {ObservableInput} other An input Observable to concatenate after the source
     * Observable. More than one input Observables may be given as argument.
     * @param {Scheduler} [scheduler=null] An optional IScheduler to schedule each
     * Observable subscription on.
     * @return {Observable} All values of each passed Observable merged into a
     * single Observable, in order, in serial fashion.
     * @method concat
     * @owner Observable
     */
    function concat$2() {
        var observables = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            observables[_i - 0] = arguments[_i];
        }
        return function (source) { return source.lift.call(concat_1.concat.apply(void 0, [source].concat(observables))); };
    }
    var concat_4 = concat$2;


    var concat_3 = {
    	concatStatic: concatStatic,
    	concat: concat_4
    };

    var concatStatic$1 = concat_1.concat;
    /* tslint:enable:max-line-length */
    /**
     * Creates an output Observable which sequentially emits all values from every
     * given input Observable after the current Observable.
     *
     * <span class="informal">Concatenates multiple Observables together by
     * sequentially emitting their values, one Observable after the other.</span>
     *
     * <img src="./img/concat.png" width="100%">
     *
     * Joins this Observable with multiple other Observables by subscribing to them
     * one at a time, starting with the source, and merging their results into the
     * output Observable. Will wait for each Observable to complete before moving
     * on to the next.
     *
     * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>
     * var timer = Rx.Observable.interval(1000).take(4);
     * var sequence = Rx.Observable.range(1, 10);
     * var result = timer.concat(sequence);
     * result.subscribe(x => console.log(x));
     *
     * // results in:
     * // 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10
     *
     * @example <caption>Concatenate 3 Observables</caption>
     * var timer1 = Rx.Observable.interval(1000).take(10);
     * var timer2 = Rx.Observable.interval(2000).take(6);
     * var timer3 = Rx.Observable.interval(500).take(10);
     * var result = timer1.concat(timer2, timer3);
     * result.subscribe(x => console.log(x));
     *
     * // results in the following:
     * // (Prints to console sequentially)
     * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9
     * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5
     * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9
     *
     * @see {@link concatAll}
     * @see {@link concatMap}
     * @see {@link concatMapTo}
     *
     * @param {ObservableInput} other An input Observable to concatenate after the source
     * Observable. More than one input Observables may be given as argument.
     * @param {Scheduler} [scheduler=null] An optional IScheduler to schedule each
     * Observable subscription on.
     * @return {Observable} All values of each passed Observable merged into a
     * single Observable, in order, in serial fashion.
     * @method concat
     * @owner Observable
     */
    function concat$3() {
        var observables = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            observables[_i - 0] = arguments[_i];
        }
        return concat_3.concat.apply(void 0, observables)(this);
    }
    var concat_4$1 = concat$3;


    var concat_3$1 = {
    	concatStatic: concatStatic$1,
    	concat: concat_4$1
    };

    Observable_1.Observable.prototype.concat = concat_3$1.concat;

    /* tslint:enable:max-line-length */
    /**
     * Converts a higher-order Observable into a first-order Observable by
     * concatenating the inner Observables in order.
     *
     * <span class="informal">Flattens an Observable-of-Observables by putting one
     * inner Observable after the other.</span>
     *
     * <img src="./img/concatAll.png" width="100%">
     *
     * Joins every Observable emitted by the source (a higher-order Observable), in
     * a serial fashion. It subscribes to each inner Observable only after the
     * previous inner Observable has completed, and merges all of their values into
     * the returned observable.
     *
     * __Warning:__ If the source Observable emits Observables quickly and
     * endlessly, and the inner Observables it emits generally complete slower than
     * the source emits, you can run into memory issues as the incoming Observables
     * collect in an unbounded buffer.
     *
     * Note: `concatAll` is equivalent to `mergeAll` with concurrency parameter set
     * to `1`.
     *
     * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var higherOrder = clicks.map(ev => Rx.Observable.interval(1000).take(4));
     * var firstOrder = higherOrder.concatAll();
     * firstOrder.subscribe(x => console.log(x));
     *
     * // Results in the following:
     * // (results are not concurrent)
     * // For every click on the "document" it will emit values 0 to 3 spaced
     * // on a 1000ms interval
     * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3
     *
     * @see {@link combineAll}
     * @see {@link concat}
     * @see {@link concatMap}
     * @see {@link concatMapTo}
     * @see {@link exhaust}
     * @see {@link mergeAll}
     * @see {@link switch}
     * @see {@link zipAll}
     *
     * @return {Observable} An Observable emitting values from all the inner
     * Observables concatenated.
     * @method concatAll
     * @owner Observable
     */
    function concatAll$1() {
        return concatAll_1.concatAll()(this);
    }
    var concatAll_3 = concatAll$1;


    var concatAll_2$1 = {
    	concatAll: concatAll_3
    };

    Observable_1.Observable.prototype.concatAll = concatAll_2$1.concatAll;

    /* tslint:enable:max-line-length */
    /**
     * Projects each source value to an Observable which is merged in the output
     * Observable, in a serialized fashion waiting for each one to complete before
     * merging the next.
     *
     * <span class="informal">Maps each value to an Observable, then flattens all of
     * these inner Observables using {@link concatAll}.</span>
     *
     * <img src="./img/concatMap.png" width="100%">
     *
     * Returns an Observable that emits items based on applying a function that you
     * supply to each item emitted by the source Observable, where that function
     * returns an (so-called "inner") Observable. Each new inner Observable is
     * concatenated with the previous inner Observable.
     *
     * __Warning:__ if source values arrive endlessly and faster than their
     * corresponding inner Observables can complete, it will result in memory issues
     * as inner Observables amass in an unbounded buffer waiting for their turn to
     * be subscribed to.
     *
     * Note: `concatMap` is equivalent to `mergeMap` with concurrency parameter set
     * to `1`.
     *
     * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var result = clicks.concatMap(ev => Rx.Observable.interval(1000).take(4));
     * result.subscribe(x => console.log(x));
     *
     * // Results in the following:
     * // (results are not concurrent)
     * // For every click on the "document" it will emit values 0 to 3 spaced
     * // on a 1000ms interval
     * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3
     *
     * @see {@link concat}
     * @see {@link concatAll}
     * @see {@link concatMapTo}
     * @see {@link exhaustMap}
     * @see {@link mergeMap}
     * @see {@link switchMap}
     *
     * @param {function(value: T, ?index: number): ObservableInput} project A function
     * that, when applied to an item emitted by the source Observable, returns an
     * Observable.
     * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
     * A function to produce the value on the output Observable based on the values
     * and the indices of the source (outer) emission and the inner Observable
     * emission. The arguments passed to this function are:
     * - `outerValue`: the value that came from the source
     * - `innerValue`: the value that came from the projected Observable
     * - `outerIndex`: the "index" of the value that came from the source
     * - `innerIndex`: the "index" of the value from the projected Observable
     * @return {Observable} An Observable that emits the result of applying the
     * projection function (and the optional `resultSelector`) to each item emitted
     * by the source Observable and taking values from each projected inner
     * Observable sequentially.
     * @method concatMap
     * @owner Observable
     */
    function concatMap(project, resultSelector) {
        return mergeMap_1.mergeMap(project, resultSelector, 1);
    }
    var concatMap_2 = concatMap;


    var concatMap_1 = {
    	concatMap: concatMap_2
    };

    /* tslint:enable:max-line-length */
    /**
     * Projects each source value to an Observable which is merged in the output
     * Observable, in a serialized fashion waiting for each one to complete before
     * merging the next.
     *
     * <span class="informal">Maps each value to an Observable, then flattens all of
     * these inner Observables using {@link concatAll}.</span>
     *
     * <img src="./img/concatMap.png" width="100%">
     *
     * Returns an Observable that emits items based on applying a function that you
     * supply to each item emitted by the source Observable, where that function
     * returns an (so-called "inner") Observable. Each new inner Observable is
     * concatenated with the previous inner Observable.
     *
     * __Warning:__ if source values arrive endlessly and faster than their
     * corresponding inner Observables can complete, it will result in memory issues
     * as inner Observables amass in an unbounded buffer waiting for their turn to
     * be subscribed to.
     *
     * Note: `concatMap` is equivalent to `mergeMap` with concurrency parameter set
     * to `1`.
     *
     * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var result = clicks.concatMap(ev => Rx.Observable.interval(1000).take(4));
     * result.subscribe(x => console.log(x));
     *
     * // Results in the following:
     * // (results are not concurrent)
     * // For every click on the "document" it will emit values 0 to 3 spaced
     * // on a 1000ms interval
     * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3
     *
     * @see {@link concat}
     * @see {@link concatAll}
     * @see {@link concatMapTo}
     * @see {@link exhaustMap}
     * @see {@link mergeMap}
     * @see {@link switchMap}
     *
     * @param {function(value: T, ?index: number): ObservableInput} project A function
     * that, when applied to an item emitted by the source Observable, returns an
     * Observable.
     * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
     * A function to produce the value on the output Observable based on the values
     * and the indices of the source (outer) emission and the inner Observable
     * emission. The arguments passed to this function are:
     * - `outerValue`: the value that came from the source
     * - `innerValue`: the value that came from the projected Observable
     * - `outerIndex`: the "index" of the value that came from the source
     * - `innerIndex`: the "index" of the value from the projected Observable
     * @return {Observable} An Observable that emits the result of applying the
     * projection function (and the optional `resultSelector`) to each item emitted
     * by the source Observable and taking values from each projected inner
     * Observable sequentially.
     * @method concatMap
     * @owner Observable
     */
    function concatMap$1(project, resultSelector) {
        return concatMap_1.concatMap(project, resultSelector)(this);
    }
    var concatMap_3 = concatMap$1;


    var concatMap_2$1 = {
    	concatMap: concatMap_3
    };

    Observable_1.Observable.prototype.concatMap = concatMap_2$1.concatMap;

    /* tslint:enable:max-line-length */
    /**
     * Projects each source value to the same Observable which is merged multiple
     * times in a serialized fashion on the output Observable.
     *
     * <span class="informal">It's like {@link concatMap}, but maps each value
     * always to the same inner Observable.</span>
     *
     * <img src="./img/concatMapTo.png" width="100%">
     *
     * Maps each source value to the given Observable `innerObservable` regardless
     * of the source value, and then flattens those resulting Observables into one
     * single Observable, which is the output Observable. Each new `innerObservable`
     * instance emitted on the output Observable is concatenated with the previous
     * `innerObservable` instance.
     *
     * __Warning:__ if source values arrive endlessly and faster than their
     * corresponding inner Observables can complete, it will result in memory issues
     * as inner Observables amass in an unbounded buffer waiting for their turn to
     * be subscribed to.
     *
     * Note: `concatMapTo` is equivalent to `mergeMapTo` with concurrency parameter
     * set to `1`.
     *
     * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var result = clicks.concatMapTo(Rx.Observable.interval(1000).take(4));
     * result.subscribe(x => console.log(x));
     *
     * // Results in the following:
     * // (results are not concurrent)
     * // For every click on the "document" it will emit values 0 to 3 spaced
     * // on a 1000ms interval
     * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3
     *
     * @see {@link concat}
     * @see {@link concatAll}
     * @see {@link concatMap}
     * @see {@link mergeMapTo}
     * @see {@link switchMapTo}
     *
     * @param {ObservableInput} innerObservable An Observable to replace each value from
     * the source Observable.
     * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
     * A function to produce the value on the output Observable based on the values
     * and the indices of the source (outer) emission and the inner Observable
     * emission. The arguments passed to this function are:
     * - `outerValue`: the value that came from the source
     * - `innerValue`: the value that came from the projected Observable
     * - `outerIndex`: the "index" of the value that came from the source
     * - `innerIndex`: the "index" of the value from the projected Observable
     * @return {Observable} An observable of values merged together by joining the
     * passed observable with itself, one after the other, for each value emitted
     * from the source.
     * @method concatMapTo
     * @owner Observable
     */
    function concatMapTo(innerObservable, resultSelector) {
        return concatMap_1.concatMap(function () { return innerObservable; }, resultSelector);
    }
    var concatMapTo_2 = concatMapTo;


    var concatMapTo_1 = {
    	concatMapTo: concatMapTo_2
    };

    /* tslint:enable:max-line-length */
    /**
     * Projects each source value to the same Observable which is merged multiple
     * times in a serialized fashion on the output Observable.
     *
     * <span class="informal">It's like {@link concatMap}, but maps each value
     * always to the same inner Observable.</span>
     *
     * <img src="./img/concatMapTo.png" width="100%">
     *
     * Maps each source value to the given Observable `innerObservable` regardless
     * of the source value, and then flattens those resulting Observables into one
     * single Observable, which is the output Observable. Each new `innerObservable`
     * instance emitted on the output Observable is concatenated with the previous
     * `innerObservable` instance.
     *
     * __Warning:__ if source values arrive endlessly and faster than their
     * corresponding inner Observables can complete, it will result in memory issues
     * as inner Observables amass in an unbounded buffer waiting for their turn to
     * be subscribed to.
     *
     * Note: `concatMapTo` is equivalent to `mergeMapTo` with concurrency parameter
     * set to `1`.
     *
     * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var result = clicks.concatMapTo(Rx.Observable.interval(1000).take(4));
     * result.subscribe(x => console.log(x));
     *
     * // Results in the following:
     * // (results are not concurrent)
     * // For every click on the "document" it will emit values 0 to 3 spaced
     * // on a 1000ms interval
     * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3
     *
     * @see {@link concat}
     * @see {@link concatAll}
     * @see {@link concatMap}
     * @see {@link mergeMapTo}
     * @see {@link switchMapTo}
     *
     * @param {ObservableInput} innerObservable An Observable to replace each value from
     * the source Observable.
     * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
     * A function to produce the value on the output Observable based on the values
     * and the indices of the source (outer) emission and the inner Observable
     * emission. The arguments passed to this function are:
     * - `outerValue`: the value that came from the source
     * - `innerValue`: the value that came from the projected Observable
     * - `outerIndex`: the "index" of the value that came from the source
     * - `innerIndex`: the "index" of the value from the projected Observable
     * @return {Observable} An observable of values merged together by joining the
     * passed observable with itself, one after the other, for each value emitted
     * from the source.
     * @method concatMapTo
     * @owner Observable
     */
    function concatMapTo$1(innerObservable, resultSelector) {
        return concatMapTo_1.concatMapTo(innerObservable, resultSelector)(this);
    }
    var concatMapTo_3 = concatMapTo$1;


    var concatMapTo_2$1 = {
    	concatMapTo: concatMapTo_3
    };

    Observable_1.Observable.prototype.concatMapTo = concatMapTo_2$1.concatMapTo;

    var __extends$16 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };

    /**
     * Counts the number of emissions on the source and emits that number when the
     * source completes.
     *
     * <span class="informal">Tells how many values were emitted, when the source
     * completes.</span>
     *
     * <img src="./img/count.png" width="100%">
     *
     * `count` transforms an Observable that emits values into an Observable that
     * emits a single value that represents the number of values emitted by the
     * source Observable. If the source Observable terminates with an error, `count`
     * will pass this error notification along without emitting a value first. If
     * the source Observable does not terminate at all, `count` will neither emit
     * a value nor terminate. This operator takes an optional `predicate` function
     * as argument, in which case the output emission will represent the number of
     * source values that matched `true` with the `predicate`.
     *
     * @example <caption>Counts how many seconds have passed before the first click happened</caption>
     * var seconds = Rx.Observable.interval(1000);
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var secondsBeforeClick = seconds.takeUntil(clicks);
     * var result = secondsBeforeClick.count();
     * result.subscribe(x => console.log(x));
     *
     * @example <caption>Counts how many odd numbers are there between 1 and 7</caption>
     * var numbers = Rx.Observable.range(1, 7);
     * var result = numbers.count(i => i % 2 === 1);
     * result.subscribe(x => console.log(x));
     *
     * // Results in:
     * // 4
     *
     * @see {@link max}
     * @see {@link min}
     * @see {@link reduce}
     *
     * @param {function(value: T, i: number, source: Observable<T>): boolean} [predicate] A
     * boolean function to select what values are to be counted. It is provided with
     * arguments of:
     * - `value`: the value from the source Observable.
     * - `index`: the (zero-based) "index" of the value from the source Observable.
     * - `source`: the source Observable instance itself.
     * @return {Observable} An Observable of one number that represents the count as
     * described above.
     * @method count
     * @owner Observable
     */
    function count(predicate) {
        return function (source) { return source.lift(new CountOperator(predicate, source)); };
    }
    var count_2 = count;
    var CountOperator = (function () {
        function CountOperator(predicate, source) {
            this.predicate = predicate;
            this.source = source;
        }
        CountOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(new CountSubscriber(subscriber, this.predicate, this.source));
        };
        return CountOperator;
    }());
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var CountSubscriber = (function (_super) {
        __extends$16(CountSubscriber, _super);
        function CountSubscriber(destination, predicate, source) {
            _super.call(this, destination);
            this.predicate = predicate;
            this.source = source;
            this.count = 0;
            this.index = 0;
        }
        CountSubscriber.prototype._next = function (value) {
            if (this.predicate) {
                this._tryPredicate(value);
            }
            else {
                this.count++;
            }
        };
        CountSubscriber.prototype._tryPredicate = function (value) {
            var result;
            try {
                result = this.predicate(value, this.index++, this.source);
            }
            catch (err) {
                this.destination.error(err);
                return;
            }
            if (result) {
                this.count++;
            }
        };
        CountSubscriber.prototype._complete = function () {
            this.destination.next(this.count);
            this.destination.complete();
        };
        return CountSubscriber;
    }(Subscriber_1.Subscriber));


    var count_1 = {
    	count: count_2
    };

    /**
     * Counts the number of emissions on the source and emits that number when the
     * source completes.
     *
     * <span class="informal">Tells how many values were emitted, when the source
     * completes.</span>
     *
     * <img src="./img/count.png" width="100%">
     *
     * `count` transforms an Observable that emits values into an Observable that
     * emits a single value that represents the number of values emitted by the
     * source Observable. If the source Observable terminates with an error, `count`
     * will pass this error notification along without emitting a value first. If
     * the source Observable does not terminate at all, `count` will neither emit
     * a value nor terminate. This operator takes an optional `predicate` function
     * as argument, in which case the output emission will represent the number of
     * source values that matched `true` with the `predicate`.
     *
     * @example <caption>Counts how many seconds have passed before the first click happened</caption>
     * var seconds = Rx.Observable.interval(1000);
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var secondsBeforeClick = seconds.takeUntil(clicks);
     * var result = secondsBeforeClick.count();
     * result.subscribe(x => console.log(x));
     *
     * @example <caption>Counts how many odd numbers are there between 1 and 7</caption>
     * var numbers = Rx.Observable.range(1, 7);
     * var result = numbers.count(i => i % 2 === 1);
     * result.subscribe(x => console.log(x));
     *
     * // Results in:
     * // 4
     *
     * @see {@link max}
     * @see {@link min}
     * @see {@link reduce}
     *
     * @param {function(value: T, i: number, source: Observable<T>): boolean} [predicate] A
     * boolean function to select what values are to be counted. It is provided with
     * arguments of:
     * - `value`: the value from the source Observable.
     * - `index`: the (zero-based) "index" of the value from the source Observable.
     * - `source`: the source Observable instance itself.
     * @return {Observable} An Observable of one number that represents the count as
     * described above.
     * @method count
     * @owner Observable
     */
    function count$1(predicate) {
        return count_1.count(predicate)(this);
    }
    var count_3 = count$1;


    var count_2$1 = {
    	count: count_3
    };

    Observable_1.Observable.prototype.count = count_2$1.count;

    var __extends$17 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };

    /**
     * Converts an Observable of {@link Notification} objects into the emissions
     * that they represent.
     *
     * <span class="informal">Unwraps {@link Notification} objects as actual `next`,
     * `error` and `complete` emissions. The opposite of {@link materialize}.</span>
     *
     * <img src="./img/dematerialize.png" width="100%">
     *
     * `dematerialize` is assumed to operate an Observable that only emits
     * {@link Notification} objects as `next` emissions, and does not emit any
     * `error`. Such Observable is the output of a `materialize` operation. Those
     * notifications are then unwrapped using the metadata they contain, and emitted
     * as `next`, `error`, and `complete` on the output Observable.
     *
     * Use this operator in conjunction with {@link materialize}.
     *
     * @example <caption>Convert an Observable of Notifications to an actual Observable</caption>
     * var notifA = new Rx.Notification('N', 'A');
     * var notifB = new Rx.Notification('N', 'B');
     * var notifE = new Rx.Notification('E', void 0,
     *   new TypeError('x.toUpperCase is not a function')
     * );
     * var materialized = Rx.Observable.of(notifA, notifB, notifE);
     * var upperCase = materialized.dematerialize();
     * upperCase.subscribe(x => console.log(x), e => console.error(e));
     *
     * // Results in:
     * // A
     * // B
     * // TypeError: x.toUpperCase is not a function
     *
     * @see {@link Notification}
     * @see {@link materialize}
     *
     * @return {Observable} An Observable that emits items and notifications
     * embedded in Notification objects emitted by the source Observable.
     * @method dematerialize
     * @owner Observable
     */
    function dematerialize() {
        return function dematerializeOperatorFunction(source) {
            return source.lift(new DeMaterializeOperator());
        };
    }
    var dematerialize_2 = dematerialize;
    var DeMaterializeOperator = (function () {
        function DeMaterializeOperator() {
        }
        DeMaterializeOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(new DeMaterializeSubscriber(subscriber));
        };
        return DeMaterializeOperator;
    }());
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var DeMaterializeSubscriber = (function (_super) {
        __extends$17(DeMaterializeSubscriber, _super);
        function DeMaterializeSubscriber(destination) {
            _super.call(this, destination);
        }
        DeMaterializeSubscriber.prototype._next = function (value) {
            value.observe(this.destination);
        };
        return DeMaterializeSubscriber;
    }(Subscriber_1.Subscriber));


    var dematerialize_1 = {
    	dematerialize: dematerialize_2
    };

    /**
     * Converts an Observable of {@link Notification} objects into the emissions
     * that they represent.
     *
     * <span class="informal">Unwraps {@link Notification} objects as actual `next`,
     * `error` and `complete` emissions. The opposite of {@link materialize}.</span>
     *
     * <img src="./img/dematerialize.png" width="100%">
     *
     * `dematerialize` is assumed to operate an Observable that only emits
     * {@link Notification} objects as `next` emissions, and does not emit any
     * `error`. Such Observable is the output of a `materialize` operation. Those
     * notifications are then unwrapped using the metadata they contain, and emitted
     * as `next`, `error`, and `complete` on the output Observable.
     *
     * Use this operator in conjunction with {@link materialize}.
     *
     * @example <caption>Convert an Observable of Notifications to an actual Observable</caption>
     * var notifA = new Rx.Notification('N', 'A');
     * var notifB = new Rx.Notification('N', 'B');
     * var notifE = new Rx.Notification('E', void 0,
     *   new TypeError('x.toUpperCase is not a function')
     * );
     * var materialized = Rx.Observable.of(notifA, notifB, notifE);
     * var upperCase = materialized.dematerialize();
     * upperCase.subscribe(x => console.log(x), e => console.error(e));
     *
     * // Results in:
     * // A
     * // B
     * // TypeError: x.toUpperCase is not a function
     *
     * @see {@link Notification}
     * @see {@link materialize}
     *
     * @return {Observable} An Observable that emits items and notifications
     * embedded in Notification objects emitted by the source Observable.
     * @method dematerialize
     * @owner Observable
     */
    function dematerialize$1() {
        return dematerialize_1.dematerialize()(this);
    }
    var dematerialize_3 = dematerialize$1;


    var dematerialize_2$1 = {
    	dematerialize: dematerialize_3
    };

    Observable_1.Observable.prototype.dematerialize = dematerialize_2$1.dematerialize;

    var __extends$18 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };


    /**
     * Emits a value from the source Observable only after a particular time span
     * determined by another Observable has passed without another source emission.
     *
     * <span class="informal">It's like {@link debounceTime}, but the time span of
     * emission silence is determined by a second Observable.</span>
     *
     * <img src="./img/debounce.png" width="100%">
     *
     * `debounce` delays values emitted by the source Observable, but drops previous
     * pending delayed emissions if a new value arrives on the source Observable.
     * This operator keeps track of the most recent value from the source
     * Observable, and spawns a duration Observable by calling the
     * `durationSelector` function. The value is emitted only when the duration
     * Observable emits a value or completes, and if no other value was emitted on
     * the source Observable since the duration Observable was spawned. If a new
     * value appears before the duration Observable emits, the previous value will
     * be dropped and will not be emitted on the output Observable.
     *
     * Like {@link debounceTime}, this is a rate-limiting operator, and also a
     * delay-like operator since output emissions do not necessarily occur at the
     * same time as they did on the source Observable.
     *
     * @example <caption>Emit the most recent click after a burst of clicks</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var result = clicks.debounce(() => Rx.Observable.interval(1000));
     * result.subscribe(x => console.log(x));
     *
     * @see {@link audit}
     * @see {@link debounceTime}
     * @see {@link delayWhen}
     * @see {@link throttle}
     *
     * @param {function(value: T): SubscribableOrPromise} durationSelector A function
     * that receives a value from the source Observable, for computing the timeout
     * duration for each source value, returned as an Observable or a Promise.
     * @return {Observable} An Observable that delays the emissions of the source
     * Observable by the specified duration Observable returned by
     * `durationSelector`, and may drop some values if they occur too frequently.
     * @method debounce
     * @owner Observable
     */
    function debounce(durationSelector) {
        return function (source) { return source.lift(new DebounceOperator(durationSelector)); };
    }
    var debounce_2 = debounce;
    var DebounceOperator = (function () {
        function DebounceOperator(durationSelector) {
            this.durationSelector = durationSelector;
        }
        DebounceOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(new DebounceSubscriber(subscriber, this.durationSelector));
        };
        return DebounceOperator;
    }());
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var DebounceSubscriber = (function (_super) {
        __extends$18(DebounceSubscriber, _super);
        function DebounceSubscriber(destination, durationSelector) {
            _super.call(this, destination);
            this.durationSelector = durationSelector;
            this.hasValue = false;
            this.durationSubscription = null;
        }
        DebounceSubscriber.prototype._next = function (value) {
            try {
                var result = this.durationSelector.call(this, value);
                if (result) {
                    this._tryNext(value, result);
                }
            }
            catch (err) {
                this.destination.error(err);
            }
        };
        DebounceSubscriber.prototype._complete = function () {
            this.emitValue();
            this.destination.complete();
        };
        DebounceSubscriber.prototype._tryNext = function (value, duration) {
            var subscription = this.durationSubscription;
            this.value = value;
            this.hasValue = true;
            if (subscription) {
                subscription.unsubscribe();
                this.remove(subscription);
            }
            subscription = subscribeToResult_1.subscribeToResult(this, duration);
            if (!subscription.closed) {
                this.add(this.durationSubscription = subscription);
            }
        };
        DebounceSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
            this.emitValue();
        };
        DebounceSubscriber.prototype.notifyComplete = function () {
            this.emitValue();
        };
        DebounceSubscriber.prototype.emitValue = function () {
            if (this.hasValue) {
                var value = this.value;
                var subscription = this.durationSubscription;
                if (subscription) {
                    this.durationSubscription = null;
                    subscription.unsubscribe();
                    this.remove(subscription);
                }
                this.value = null;
                this.hasValue = false;
                _super.prototype._next.call(this, value);
            }
        };
        return DebounceSubscriber;
    }(OuterSubscriber_1.OuterSubscriber));


    var debounce_1 = {
    	debounce: debounce_2
    };

    /**
     * Emits a value from the source Observable only after a particular time span
     * determined by another Observable has passed without another source emission.
     *
     * <span class="informal">It's like {@link debounceTime}, but the time span of
     * emission silence is determined by a second Observable.</span>
     *
     * <img src="./img/debounce.png" width="100%">
     *
     * `debounce` delays values emitted by the source Observable, but drops previous
     * pending delayed emissions if a new value arrives on the source Observable.
     * This operator keeps track of the most recent value from the source
     * Observable, and spawns a duration Observable by calling the
     * `durationSelector` function. The value is emitted only when the duration
     * Observable emits a value or completes, and if no other value was emitted on
     * the source Observable since the duration Observable was spawned. If a new
     * value appears before the duration Observable emits, the previous value will
     * be dropped and will not be emitted on the output Observable.
     *
     * Like {@link debounceTime}, this is a rate-limiting operator, and also a
     * delay-like operator since output emissions do not necessarily occur at the
     * same time as they did on the source Observable.
     *
     * @example <caption>Emit the most recent click after a burst of clicks</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var result = clicks.debounce(() => Rx.Observable.interval(1000));
     * result.subscribe(x => console.log(x));
     *
     * @see {@link audit}
     * @see {@link debounceTime}
     * @see {@link delayWhen}
     * @see {@link throttle}
     *
     * @param {function(value: T): SubscribableOrPromise} durationSelector A function
     * that receives a value from the source Observable, for computing the timeout
     * duration for each source value, returned as an Observable or a Promise.
     * @return {Observable} An Observable that delays the emissions of the source
     * Observable by the specified duration Observable returned by
     * `durationSelector`, and may drop some values if they occur too frequently.
     * @method debounce
     * @owner Observable
     */
    function debounce$1(durationSelector) {
        return debounce_1.debounce(durationSelector)(this);
    }
    var debounce_3 = debounce$1;


    var debounce_2$1 = {
    	debounce: debounce_3
    };

    Observable_1.Observable.prototype.debounce = debounce_2$1.debounce;

    var __extends$19 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };


    /**
     * Emits a value from the source Observable only after a particular time span
     * has passed without another source emission.
     *
     * <span class="informal">It's like {@link delay}, but passes only the most
     * recent value from each burst of emissions.</span>
     *
     * <img src="./img/debounceTime.png" width="100%">
     *
     * `debounceTime` delays values emitted by the source Observable, but drops
     * previous pending delayed emissions if a new value arrives on the source
     * Observable. This operator keeps track of the most recent value from the
     * source Observable, and emits that only when `dueTime` enough time has passed
     * without any other value appearing on the source Observable. If a new value
     * appears before `dueTime` silence occurs, the previous value will be dropped
     * and will not be emitted on the output Observable.
     *
     * This is a rate-limiting operator, because it is impossible for more than one
     * value to be emitted in any time window of duration `dueTime`, but it is also
     * a delay-like operator since output emissions do not occur at the same time as
     * they did on the source Observable. Optionally takes a {@link IScheduler} for
     * managing timers.
     *
     * @example <caption>Emit the most recent click after a burst of clicks</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var result = clicks.debounceTime(1000);
     * result.subscribe(x => console.log(x));
     *
     * @see {@link auditTime}
     * @see {@link debounce}
     * @see {@link delay}
     * @see {@link sampleTime}
     * @see {@link throttleTime}
     *
     * @param {number} dueTime The timeout duration in milliseconds (or the time
     * unit determined internally by the optional `scheduler`) for the window of
     * time required to wait for emission silence before emitting the most recent
     * source value.
     * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for
     * managing the timers that handle the timeout for each value.
     * @return {Observable} An Observable that delays the emissions of the source
     * Observable by the specified `dueTime`, and may drop some values if they occur
     * too frequently.
     * @method debounceTime
     * @owner Observable
     */
    function debounceTime(dueTime, scheduler) {
        if (scheduler === void 0) { scheduler = async.async; }
        return function (source) { return source.lift(new DebounceTimeOperator(dueTime, scheduler)); };
    }
    var debounceTime_2 = debounceTime;
    var DebounceTimeOperator = (function () {
        function DebounceTimeOperator(dueTime, scheduler) {
            this.dueTime = dueTime;
            this.scheduler = scheduler;
        }
        DebounceTimeOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));
        };
        return DebounceTimeOperator;
    }());
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var DebounceTimeSubscriber = (function (_super) {
        __extends$19(DebounceTimeSubscriber, _super);
        function DebounceTimeSubscriber(destination, dueTime, scheduler) {
            _super.call(this, destination);
            this.dueTime = dueTime;
            this.scheduler = scheduler;
            this.debouncedSubscription = null;
            this.lastValue = null;
            this.hasValue = false;
        }
        DebounceTimeSubscriber.prototype._next = function (value) {
            this.clearDebounce();
            this.lastValue = value;
            this.hasValue = true;
            this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext$3, this.dueTime, this));
        };
        DebounceTimeSubscriber.prototype._complete = function () {
            this.debouncedNext();
            this.destination.complete();
        };
        DebounceTimeSubscriber.prototype.debouncedNext = function () {
            this.clearDebounce();
            if (this.hasValue) {
                this.destination.next(this.lastValue);
                this.lastValue = null;
                this.hasValue = false;
            }
        };
        DebounceTimeSubscriber.prototype.clearDebounce = function () {
            var debouncedSubscription = this.debouncedSubscription;
            if (debouncedSubscription !== null) {
                this.remove(debouncedSubscription);
                debouncedSubscription.unsubscribe();
                this.debouncedSubscription = null;
            }
        };
        return DebounceTimeSubscriber;
    }(Subscriber_1.Subscriber));
    function dispatchNext$3(subscriber) {
        subscriber.debouncedNext();
    }


    var debounceTime_1 = {
    	debounceTime: debounceTime_2
    };

    /**
     * Emits a value from the source Observable only after a particular time span
     * has passed without another source emission.
     *
     * <span class="informal">It's like {@link delay}, but passes only the most
     * recent value from each burst of emissions.</span>
     *
     * <img src="./img/debounceTime.png" width="100%">
     *
     * `debounceTime` delays values emitted by the source Observable, but drops
     * previous pending delayed emissions if a new value arrives on the source
     * Observable. This operator keeps track of the most recent value from the
     * source Observable, and emits that only when `dueTime` enough time has passed
     * without any other value appearing on the source Observable. If a new value
     * appears before `dueTime` silence occurs, the previous value will be dropped
     * and will not be emitted on the output Observable.
     *
     * This is a rate-limiting operator, because it is impossible for more than one
     * value to be emitted in any time window of duration `dueTime`, but it is also
     * a delay-like operator since output emissions do not occur at the same time as
     * they did on the source Observable. Optionally takes a {@link IScheduler} for
     * managing timers.
     *
     * @example <caption>Emit the most recent click after a burst of clicks</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var result = clicks.debounceTime(1000);
     * result.subscribe(x => console.log(x));
     *
     * @see {@link auditTime}
     * @see {@link debounce}
     * @see {@link delay}
     * @see {@link sampleTime}
     * @see {@link throttleTime}
     *
     * @param {number} dueTime The timeout duration in milliseconds (or the time
     * unit determined internally by the optional `scheduler`) for the window of
     * time required to wait for emission silence before emitting the most recent
     * source value.
     * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for
     * managing the timers that handle the timeout for each value.
     * @return {Observable} An Observable that delays the emissions of the source
     * Observable by the specified `dueTime`, and may drop some values if they occur
     * too frequently.
     * @method debounceTime
     * @owner Observable
     */
    function debounceTime$1(dueTime, scheduler) {
        if (scheduler === void 0) { scheduler = async.async; }
        return debounceTime_1.debounceTime(dueTime, scheduler)(this);
    }
    var debounceTime_3 = debounceTime$1;


    var debounceTime_2$1 = {
    	debounceTime: debounceTime_3
    };

    Observable_1.Observable.prototype.debounceTime = debounceTime_2$1.debounceTime;

    var __extends$1a = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };

    /* tslint:enable:max-line-length */
    /**
     * Emits a given value if the source Observable completes without emitting any
     * `next` value, otherwise mirrors the source Observable.
     *
     * <span class="informal">If the source Observable turns out to be empty, then
     * this operator will emit a default value.</span>
     *
     * <img src="./img/defaultIfEmpty.png" width="100%">
     *
     * `defaultIfEmpty` emits the values emitted by the source Observable or a
     * specified default value if the source Observable is empty (completes without
     * having emitted any `next` value).
     *
     * @example <caption>If no clicks happen in 5 seconds, then emit "no clicks"</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var clicksBeforeFive = clicks.takeUntil(Rx.Observable.interval(5000));
     * var result = clicksBeforeFive.defaultIfEmpty('no clicks');
     * result.subscribe(x => console.log(x));
     *
     * @see {@link empty}
     * @see {@link last}
     *
     * @param {any} [defaultValue=null] The default value used if the source
     * Observable is empty.
     * @return {Observable} An Observable that emits either the specified
     * `defaultValue` if the source Observable emits no items, or the values emitted
     * by the source Observable.
     * @method defaultIfEmpty
     * @owner Observable
     */
    function defaultIfEmpty(defaultValue) {
        if (defaultValue === void 0) { defaultValue = null; }
        return function (source) { return source.lift(new DefaultIfEmptyOperator(defaultValue)); };
    }
    var defaultIfEmpty_2 = defaultIfEmpty;
    var DefaultIfEmptyOperator = (function () {
        function DefaultIfEmptyOperator(defaultValue) {
            this.defaultValue = defaultValue;
        }
        DefaultIfEmptyOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(new DefaultIfEmptySubscriber(subscriber, this.defaultValue));
        };
        return DefaultIfEmptyOperator;
    }());
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var DefaultIfEmptySubscriber = (function (_super) {
        __extends$1a(DefaultIfEmptySubscriber, _super);
        function DefaultIfEmptySubscriber(destination, defaultValue) {
            _super.call(this, destination);
            this.defaultValue = defaultValue;
            this.isEmpty = true;
        }
        DefaultIfEmptySubscriber.prototype._next = function (value) {
            this.isEmpty = false;
            this.destination.next(value);
        };
        DefaultIfEmptySubscriber.prototype._complete = function () {
            if (this.isEmpty) {
                this.destination.next(this.defaultValue);
            }
            this.destination.complete();
        };
        return DefaultIfEmptySubscriber;
    }(Subscriber_1.Subscriber));


    var defaultIfEmpty_1 = {
    	defaultIfEmpty: defaultIfEmpty_2
    };

    /* tslint:enable:max-line-length */
    /**
     * Emits a given value if the source Observable completes without emitting any
     * `next` value, otherwise mirrors the source Observable.
     *
     * <span class="informal">If the source Observable turns out to be empty, then
     * this operator will emit a default value.</span>
     *
     * <img src="./img/defaultIfEmpty.png" width="100%">
     *
     * `defaultIfEmpty` emits the values emitted by the source Observable or a
     * specified default value if the source Observable is empty (completes without
     * having emitted any `next` value).
     *
     * @example <caption>If no clicks happen in 5 seconds, then emit "no clicks"</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var clicksBeforeFive = clicks.takeUntil(Rx.Observable.interval(5000));
     * var result = clicksBeforeFive.defaultIfEmpty('no clicks');
     * result.subscribe(x => console.log(x));
     *
     * @see {@link empty}
     * @see {@link last}
     *
     * @param {any} [defaultValue=null] The default value used if the source
     * Observable is empty.
     * @return {Observable} An Observable that emits either the specified
     * `defaultValue` if the source Observable emits no items, or the values emitted
     * by the source Observable.
     * @method defaultIfEmpty
     * @owner Observable
     */
    function defaultIfEmpty$1(defaultValue) {
        if (defaultValue === void 0) { defaultValue = null; }
        return defaultIfEmpty_1.defaultIfEmpty(defaultValue)(this);
    }
    var defaultIfEmpty_3 = defaultIfEmpty$1;


    var defaultIfEmpty_2$1 = {
    	defaultIfEmpty: defaultIfEmpty_3
    };

    Observable_1.Observable.prototype.defaultIfEmpty = defaultIfEmpty_2$1.defaultIfEmpty;

    var __extends$1b = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };




    /**
     * Delays the emission of items from the source Observable by a given timeout or
     * until a given Date.
     *
     * <span class="informal">Time shifts each item by some specified amount of
     * milliseconds.</span>
     *
     * <img src="./img/delay.png" width="100%">
     *
     * If the delay argument is a Number, this operator time shifts the source
     * Observable by that amount of time expressed in milliseconds. The relative
     * time intervals between the values are preserved.
     *
     * If the delay argument is a Date, this operator time shifts the start of the
     * Observable execution until the given date occurs.
     *
     * @example <caption>Delay each click by one second</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var delayedClicks = clicks.delay(1000); // each click emitted after 1 second
     * delayedClicks.subscribe(x => console.log(x));
     *
     * @example <caption>Delay all clicks until a future date happens</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var date = new Date('March 15, 2050 12:00:00'); // in the future
     * var delayedClicks = clicks.delay(date); // click emitted only after that date
     * delayedClicks.subscribe(x => console.log(x));
     *
     * @see {@link debounceTime}
     * @see {@link delayWhen}
     *
     * @param {number|Date} delay The delay duration in milliseconds (a `number`) or
     * a `Date` until which the emission of the source items is delayed.
     * @param {Scheduler} [scheduler=async] The IScheduler to use for
     * managing the timers that handle the time-shift for each item.
     * @return {Observable} An Observable that delays the emissions of the source
     * Observable by the specified timeout or Date.
     * @method delay
     * @owner Observable
     */
    function delay(delay, scheduler) {
        if (scheduler === void 0) { scheduler = async.async; }
        var absoluteDelay = isDate_1.isDate(delay);
        var delayFor = absoluteDelay ? (+delay - scheduler.now()) : Math.abs(delay);
        return function (source) { return source.lift(new DelayOperator(delayFor, scheduler)); };
    }
    var delay_2 = delay;
    var DelayOperator = (function () {
        function DelayOperator(delay, scheduler) {
            this.delay = delay;
            this.scheduler = scheduler;
        }
        DelayOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(new DelaySubscriber(subscriber, this.delay, this.scheduler));
        };
        return DelayOperator;
    }());
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var DelaySubscriber = (function (_super) {
        __extends$1b(DelaySubscriber, _super);
        function DelaySubscriber(destination, delay, scheduler) {
            _super.call(this, destination);
            this.delay = delay;
            this.scheduler = scheduler;
            this.queue = [];
            this.active = false;
            this.errored = false;
        }
        DelaySubscriber.dispatch = function (state) {
            var source = state.source;
            var queue = source.queue;
            var scheduler = state.scheduler;
            var destination = state.destination;
            while (queue.length > 0 && (queue[0].time - scheduler.now()) <= 0) {
                queue.shift().notification.observe(destination);
            }
            if (queue.length > 0) {
                var delay_1 = Math.max(0, queue[0].time - scheduler.now());
                this.schedule(state, delay_1);
            }
            else {
                source.active = false;
            }
        };
        DelaySubscriber.prototype._schedule = function (scheduler) {
            this.active = true;
            this.add(scheduler.schedule(DelaySubscriber.dispatch, this.delay, {
                source: this, destination: this.destination, scheduler: scheduler
            }));
        };
        DelaySubscriber.prototype.scheduleNotification = function (notification) {
            if (this.errored === true) {
                return;
            }
            var scheduler = this.scheduler;
            var message = new DelayMessage(scheduler.now() + this.delay, notification);
            this.queue.push(message);
            if (this.active === false) {
                this._schedule(scheduler);
            }
        };
        DelaySubscriber.prototype._next = function (value) {
            this.scheduleNotification(Notification_1.Notification.createNext(value));
        };
        DelaySubscriber.prototype._error = function (err) {
            this.errored = true;
            this.queue = [];
            this.destination.error(err);
        };
        DelaySubscriber.prototype._complete = function () {
            this.scheduleNotification(Notification_1.Notification.createComplete());
        };
        return DelaySubscriber;
    }(Subscriber_1.Subscriber));
    var DelayMessage = (function () {
        function DelayMessage(time, notification) {
            this.time = time;
            this.notification = notification;
        }
        return DelayMessage;
    }());


    var delay_1 = {
    	delay: delay_2
    };

    /**
     * Delays the emission of items from the source Observable by a given timeout or
     * until a given Date.
     *
     * <span class="informal">Time shifts each item by some specified amount of
     * milliseconds.</span>
     *
     * <img src="./img/delay.png" width="100%">
     *
     * If the delay argument is a Number, this operator time shifts the source
     * Observable by that amount of time expressed in milliseconds. The relative
     * time intervals between the values are preserved.
     *
     * If the delay argument is a Date, this operator time shifts the start of the
     * Observable execution until the given date occurs.
     *
     * @example <caption>Delay each click by one second</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var delayedClicks = clicks.delay(1000); // each click emitted after 1 second
     * delayedClicks.subscribe(x => console.log(x));
     *
     * @example <caption>Delay all clicks until a future date happens</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var date = new Date('March 15, 2050 12:00:00'); // in the future
     * var delayedClicks = clicks.delay(date); // click emitted only after that date
     * delayedClicks.subscribe(x => console.log(x));
     *
     * @see {@link debounceTime}
     * @see {@link delayWhen}
     *
     * @param {number|Date} delay The delay duration in milliseconds (a `number`) or
     * a `Date` until which the emission of the source items is delayed.
     * @param {Scheduler} [scheduler=async] The IScheduler to use for
     * managing the timers that handle the time-shift for each item.
     * @return {Observable} An Observable that delays the emissions of the source
     * Observable by the specified timeout or Date.
     * @method delay
     * @owner Observable
     */
    function delay$1(delay, scheduler) {
        if (scheduler === void 0) { scheduler = async.async; }
        return delay_1.delay(delay, scheduler)(this);
    }
    var delay_3 = delay$1;


    var delay_2$1 = {
    	delay: delay_3
    };

    Observable_1.Observable.prototype.delay = delay_2$1.delay;

    var __extends$1c = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };




    /**
     * Delays the emission of items from the source Observable by a given time span
     * determined by the emissions of another Observable.
     *
     * <span class="informal">It's like {@link delay}, but the time span of the
     * delay duration is determined by a second Observable.</span>
     *
     * <img src="./img/delayWhen.png" width="100%">
     *
     * `delayWhen` time shifts each emitted value from the source Observable by a
     * time span determined by another Observable. When the source emits a value,
     * the `delayDurationSelector` function is called with the source value as
     * argument, and should return an Observable, called the "duration" Observable.
     * The source value is emitted on the output Observable only when the duration
     * Observable emits a value or completes.
     *
     * Optionally, `delayWhen` takes a second argument, `subscriptionDelay`, which
     * is an Observable. When `subscriptionDelay` emits its first value or
     * completes, the source Observable is subscribed to and starts behaving like
     * described in the previous paragraph. If `subscriptionDelay` is not provided,
     * `delayWhen` will subscribe to the source Observable as soon as the output
     * Observable is subscribed.
     *
     * @example <caption>Delay each click by a random amount of time, between 0 and 5 seconds</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var delayedClicks = clicks.delayWhen(event =>
     *   Rx.Observable.interval(Math.random() * 5000)
     * );
     * delayedClicks.subscribe(x => console.log(x));
     *
     * @see {@link debounce}
     * @see {@link delay}
     *
     * @param {function(value: T): Observable} delayDurationSelector A function that
     * returns an Observable for each value emitted by the source Observable, which
     * is then used to delay the emission of that item on the output Observable
     * until the Observable returned from this function emits a value.
     * @param {Observable} subscriptionDelay An Observable that triggers the
     * subscription to the source Observable once it emits any value.
     * @return {Observable} An Observable that delays the emissions of the source
     * Observable by an amount of time specified by the Observable returned by
     * `delayDurationSelector`.
     * @method delayWhen
     * @owner Observable
     */
    function delayWhen(delayDurationSelector, subscriptionDelay) {
        if (subscriptionDelay) {
            return function (source) {
                return new SubscriptionDelayObservable(source, subscriptionDelay)
                    .lift(new DelayWhenOperator(delayDurationSelector));
            };
        }
        return function (source) { return source.lift(new DelayWhenOperator(delayDurationSelector)); };
    }
    var delayWhen_2 = delayWhen;
    var DelayWhenOperator = (function () {
        function DelayWhenOperator(delayDurationSelector) {
            this.delayDurationSelector = delayDurationSelector;
        }
        DelayWhenOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(new DelayWhenSubscriber(subscriber, this.delayDurationSelector));
        };
        return DelayWhenOperator;
    }());
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var DelayWhenSubscriber = (function (_super) {
        __extends$1c(DelayWhenSubscriber, _super);
        function DelayWhenSubscriber(destination, delayDurationSelector) {
            _super.call(this, destination);
            this.delayDurationSelector = delayDurationSelector;
            this.completed = false;
            this.delayNotifierSubscriptions = [];
            this.values = [];
        }
        DelayWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
            this.destination.next(outerValue);
            this.removeSubscription(innerSub);
            this.tryComplete();
        };
        DelayWhenSubscriber.prototype.notifyError = function (error, innerSub) {
            this._error(error);
        };
        DelayWhenSubscriber.prototype.notifyComplete = function (innerSub) {
            var value = this.removeSubscription(innerSub);
            if (value) {
                this.destination.next(value);
            }
            this.tryComplete();
        };
        DelayWhenSubscriber.prototype._next = function (value) {
            try {
                var delayNotifier = this.delayDurationSelector(value);
                if (delayNotifier) {
                    this.tryDelay(delayNotifier, value);
                }
            }
            catch (err) {
                this.destination.error(err);
            }
        };
        DelayWhenSubscriber.prototype._complete = function () {
            this.completed = true;
            this.tryComplete();
        };
        DelayWhenSubscriber.prototype.removeSubscription = function (subscription) {
            subscription.unsubscribe();
            var subscriptionIdx = this.delayNotifierSubscriptions.indexOf(subscription);
            var value = null;
            if (subscriptionIdx !== -1) {
                value = this.values[subscriptionIdx];
                this.delayNotifierSubscriptions.splice(subscriptionIdx, 1);
                this.values.splice(subscriptionIdx, 1);
            }
            return value;
        };
        DelayWhenSubscriber.prototype.tryDelay = function (delayNotifier, value) {
            var notifierSubscription = subscribeToResult_1.subscribeToResult(this, delayNotifier, value);
            if (notifierSubscription && !notifierSubscription.closed) {
                this.add(notifierSubscription);
                this.delayNotifierSubscriptions.push(notifierSubscription);
            }
            this.values.push(value);
        };
        DelayWhenSubscriber.prototype.tryComplete = function () {
            if (this.completed && this.delayNotifierSubscriptions.length === 0) {
                this.destination.complete();
            }
        };
        return DelayWhenSubscriber;
    }(OuterSubscriber_1.OuterSubscriber));
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var SubscriptionDelayObservable = (function (_super) {
        __extends$1c(SubscriptionDelayObservable, _super);
        function SubscriptionDelayObservable(/** @deprecated internal use only */ source, subscriptionDelay) {
            _super.call(this);
            this.source = source;
            this.subscriptionDelay = subscriptionDelay;
        }
        /** @deprecated internal use only */ SubscriptionDelayObservable.prototype._subscribe = function (subscriber) {
            this.subscriptionDelay.subscribe(new SubscriptionDelaySubscriber(subscriber, this.source));
        };
        return SubscriptionDelayObservable;
    }(Observable_1.Observable));
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var SubscriptionDelaySubscriber = (function (_super) {
        __extends$1c(SubscriptionDelaySubscriber, _super);
        function SubscriptionDelaySubscriber(parent, source) {
            _super.call(this);
            this.parent = parent;
            this.source = source;
            this.sourceSubscribed = false;
        }
        SubscriptionDelaySubscriber.prototype._next = function (unused) {
            this.subscribeToSource();
        };
        SubscriptionDelaySubscriber.prototype._error = function (err) {
            this.unsubscribe();
            this.parent.error(err);
        };
        SubscriptionDelaySubscriber.prototype._complete = function () {
            this.subscribeToSource();
        };
        SubscriptionDelaySubscriber.prototype.subscribeToSource = function () {
            if (!this.sourceSubscribed) {
                this.sourceSubscribed = true;
                this.unsubscribe();
                this.source.subscribe(this.parent);
            }
        };
        return SubscriptionDelaySubscriber;
    }(Subscriber_1.Subscriber));


    var delayWhen_1 = {
    	delayWhen: delayWhen_2
    };

    /**
     * Delays the emission of items from the source Observable by a given time span
     * determined by the emissions of another Observable.
     *
     * <span class="informal">It's like {@link delay}, but the time span of the
     * delay duration is determined by a second Observable.</span>
     *
     * <img src="./img/delayWhen.png" width="100%">
     *
     * `delayWhen` time shifts each emitted value from the source Observable by a
     * time span determined by another Observable. When the source emits a value,
     * the `delayDurationSelector` function is called with the source value as
     * argument, and should return an Observable, called the "duration" Observable.
     * The source value is emitted on the output Observable only when the duration
     * Observable emits a value or completes.
     *
     * Optionally, `delayWhen` takes a second argument, `subscriptionDelay`, which
     * is an Observable. When `subscriptionDelay` emits its first value or
     * completes, the source Observable is subscribed to and starts behaving like
     * described in the previous paragraph. If `subscriptionDelay` is not provided,
     * `delayWhen` will subscribe to the source Observable as soon as the output
     * Observable is subscribed.
     *
     * @example <caption>Delay each click by a random amount of time, between 0 and 5 seconds</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var delayedClicks = clicks.delayWhen(event =>
     *   Rx.Observable.interval(Math.random() * 5000)
     * );
     * delayedClicks.subscribe(x => console.log(x));
     *
     * @see {@link debounce}
     * @see {@link delay}
     *
     * @param {function(value: T): Observable} delayDurationSelector A function that
     * returns an Observable for each value emitted by the source Observable, which
     * is then used to delay the emission of that item on the output Observable
     * until the Observable returned from this function emits a value.
     * @param {Observable} subscriptionDelay An Observable that triggers the
     * subscription to the source Observable once it emits any value.
     * @return {Observable} An Observable that delays the emissions of the source
     * Observable by an amount of time specified by the Observable returned by
     * `delayDurationSelector`.
     * @method delayWhen
     * @owner Observable
     */
    function delayWhen$1(delayDurationSelector, subscriptionDelay) {
        return delayWhen_1.delayWhen(delayDurationSelector, subscriptionDelay)(this);
    }
    var delayWhen_3 = delayWhen$1;


    var delayWhen_2$1 = {
    	delayWhen: delayWhen_3
    };

    Observable_1.Observable.prototype.delayWhen = delayWhen_2$1.delayWhen;

    function minimalSetImpl() {
        // THIS IS NOT a full impl of Set, this is just the minimum
        // bits of functionality we need for this library.
        return (function () {
            function MinimalSet() {
                this._values = [];
            }
            MinimalSet.prototype.add = function (value) {
                if (!this.has(value)) {
                    this._values.push(value);
                }
            };
            MinimalSet.prototype.has = function (value) {
                return this._values.indexOf(value) !== -1;
            };
            Object.defineProperty(MinimalSet.prototype, "size", {
                get: function () {
                    return this._values.length;
                },
                enumerable: true,
                configurable: true
            });
            MinimalSet.prototype.clear = function () {
                this._values.length = 0;
            };
            return MinimalSet;
        }());
    }
    var minimalSetImpl_1 = minimalSetImpl;
    var Set = root.root.Set || minimalSetImpl();


    var _Set = {
    	minimalSetImpl: minimalSetImpl_1,
    	Set: Set
    };

    var __extends$1d = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };



    /**
     * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from previous items.
     *
     * If a keySelector function is provided, then it will project each value from the source observable into a new value that it will
     * check for equality with previously projected values. If a keySelector function is not provided, it will use each value from the
     * source observable directly with an equality check against previous values.
     *
     * In JavaScript runtimes that support `Set`, this operator will use a `Set` to improve performance of the distinct value checking.
     *
     * In other runtimes, this operator will use a minimal implementation of `Set` that relies on an `Array` and `indexOf` under the
     * hood, so performance will degrade as more values are checked for distinction. Even in newer browsers, a long-running `distinct`
     * use might result in memory leaks. To help alleviate this in some scenarios, an optional `flushes` parameter is also provided so
     * that the internal `Set` can be "flushed", basically clearing it of values.
     *
     * @example <caption>A simple example with numbers</caption>
     * Observable.of(1, 1, 2, 2, 2, 1, 2, 3, 4, 3, 2, 1)
     *   .distinct()
     *   .subscribe(x => console.log(x)); // 1, 2, 3, 4
     *
     * @example <caption>An example using a keySelector function</caption>
     * interface Person {
     *    age: number,
     *    name: string
     * }
     *
     * Observable.of<Person>(
     *     { age: 4, name: 'Foo'},
     *     { age: 7, name: 'Bar'},
     *     { age: 5, name: 'Foo'})
     *     .distinct((p: Person) => p.name)
     *     .subscribe(x => console.log(x));
     *
     * // displays:
     * // { age: 4, name: 'Foo' }
     * // { age: 7, name: 'Bar' }
     *
     * @see {@link distinctUntilChanged}
     * @see {@link distinctUntilKeyChanged}
     *
     * @param {function} [keySelector] Optional function to select which value you want to check as distinct.
     * @param {Observable} [flushes] Optional Observable for flushing the internal HashSet of the operator.
     * @return {Observable} An Observable that emits items from the source Observable with distinct values.
     * @method distinct
     * @owner Observable
     */
    function distinct(keySelector, flushes) {
        return function (source) { return source.lift(new DistinctOperator(keySelector, flushes)); };
    }
    var distinct_2 = distinct;
    var DistinctOperator = (function () {
        function DistinctOperator(keySelector, flushes) {
            this.keySelector = keySelector;
            this.flushes = flushes;
        }
        DistinctOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(new DistinctSubscriber(subscriber, this.keySelector, this.flushes));
        };
        return DistinctOperator;
    }());
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var DistinctSubscriber = (function (_super) {
        __extends$1d(DistinctSubscriber, _super);
        function DistinctSubscriber(destination, keySelector, flushes) {
            _super.call(this, destination);
            this.keySelector = keySelector;
            this.values = new _Set.Set();
            if (flushes) {
                this.add(subscribeToResult_1.subscribeToResult(this, flushes));
            }
        }
        DistinctSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
            this.values.clear();
        };
        DistinctSubscriber.prototype.notifyError = function (error, innerSub) {
            this._error(error);
        };
        DistinctSubscriber.prototype._next = function (value) {
            if (this.keySelector) {
                this._useKeySelector(value);
            }
            else {
                this._finalizeNext(value, value);
            }
        };
        DistinctSubscriber.prototype._useKeySelector = function (value) {
            var key;
            var destination = this.destination;
            try {
                key = this.keySelector(value);
            }
            catch (err) {
                destination.error(err);
                return;
            }
            this._finalizeNext(key, value);
        };
        DistinctSubscriber.prototype._finalizeNext = function (key, value) {
            var values = this.values;
            if (!values.has(key)) {
                values.add(key);
                this.destination.next(value);
            }
        };
        return DistinctSubscriber;
    }(OuterSubscriber_1.OuterSubscriber));
    var DistinctSubscriber_1 = DistinctSubscriber;


    var distinct_1 = {
    	distinct: distinct_2,
    	DistinctSubscriber: DistinctSubscriber_1
    };

    /**
     * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from previous items.
     *
     * If a keySelector function is provided, then it will project each value from the source observable into a new value that it will
     * check for equality with previously projected values. If a keySelector function is not provided, it will use each value from the
     * source observable directly with an equality check against previous values.
     *
     * In JavaScript runtimes that support `Set`, this operator will use a `Set` to improve performance of the distinct value checking.
     *
     * In other runtimes, this operator will use a minimal implementation of `Set` that relies on an `Array` and `indexOf` under the
     * hood, so performance will degrade as more values are checked for distinction. Even in newer browsers, a long-running `distinct`
     * use might result in memory leaks. To help alleviate this in some scenarios, an optional `flushes` parameter is also provided so
     * that the internal `Set` can be "flushed", basically clearing it of values.
     *
     * @example <caption>A simple example with numbers</caption>
     * Observable.of(1, 1, 2, 2, 2, 1, 2, 3, 4, 3, 2, 1)
     *   .distinct()
     *   .subscribe(x => console.log(x)); // 1, 2, 3, 4
     *
     * @example <caption>An example using a keySelector function</caption>
     * interface Person {
     *    age: number,
     *    name: string
     * }
     *
     * Observable.of<Person>(
     *     { age: 4, name: 'Foo'},
     *     { age: 7, name: 'Bar'},
     *     { age: 5, name: 'Foo'})
     *     .distinct((p: Person) => p.name)
     *     .subscribe(x => console.log(x));
     *
     * // displays:
     * // { age: 4, name: 'Foo' }
     * // { age: 7, name: 'Bar' }
     *
     * @see {@link distinctUntilChanged}
     * @see {@link distinctUntilKeyChanged}
     *
     * @param {function} [keySelector] Optional function to select which value you want to check as distinct.
     * @param {Observable} [flushes] Optional Observable for flushing the internal HashSet of the operator.
     * @return {Observable} An Observable that emits items from the source Observable with distinct values.
     * @method distinct
     * @owner Observable
     */
    function distinct$1(keySelector, flushes) {
        return distinct_1.distinct(keySelector, flushes)(this);
    }
    var distinct_3 = distinct$1;


    var distinct_2$1 = {
    	distinct: distinct_3
    };

    Observable_1.Observable.prototype.distinct = distinct_2$1.distinct;

    var __extends$1e = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };



    /* tslint:enable:max-line-length */
    /**
     * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from the previous item.
     *
     * If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.
     *
     * If a comparator function is not provided, an equality check is used by default.
     *
     * @example <caption>A simple example with numbers</caption>
     * Observable.of(1, 1, 2, 2, 2, 1, 1, 2, 3, 3, 4)
     *   .distinctUntilChanged()
     *   .subscribe(x => console.log(x)); // 1, 2, 1, 2, 3, 4
     *
     * @example <caption>An example using a compare function</caption>
     * interface Person {
     *    age: number,
     *    name: string
     * }
     *
     * Observable.of<Person>(
     *     { age: 4, name: 'Foo'},
     *     { age: 7, name: 'Bar'},
     *     { age: 5, name: 'Foo'})
     *     { age: 6, name: 'Foo'})
     *     .distinctUntilChanged((p: Person, q: Person) => p.name === q.name)
     *     .subscribe(x => console.log(x));
     *
     * // displays:
     * // { age: 4, name: 'Foo' }
     * // { age: 7, name: 'Bar' }
     * // { age: 5, name: 'Foo' }
     *
     * @see {@link distinct}
     * @see {@link distinctUntilKeyChanged}
     *
     * @param {function} [compare] Optional comparison function called to test if an item is distinct from the previous item in the source.
     * @return {Observable} An Observable that emits items from the source Observable with distinct values.
     * @method distinctUntilChanged
     * @owner Observable
     */
    function distinctUntilChanged(compare, keySelector) {
        return function (source) { return source.lift(new DistinctUntilChangedOperator(compare, keySelector)); };
    }
    var distinctUntilChanged_2 = distinctUntilChanged;
    var DistinctUntilChangedOperator = (function () {
        function DistinctUntilChangedOperator(compare, keySelector) {
            this.compare = compare;
            this.keySelector = keySelector;
        }
        DistinctUntilChangedOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(new DistinctUntilChangedSubscriber(subscriber, this.compare, this.keySelector));
        };
        return DistinctUntilChangedOperator;
    }());
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var DistinctUntilChangedSubscriber = (function (_super) {
        __extends$1e(DistinctUntilChangedSubscriber, _super);
        function DistinctUntilChangedSubscriber(destination, compare, keySelector) {
            _super.call(this, destination);
            this.keySelector = keySelector;
            this.hasKey = false;
            if (typeof compare === 'function') {
                this.compare = compare;
            }
        }
        DistinctUntilChangedSubscriber.prototype.compare = function (x, y) {
            return x === y;
        };
        DistinctUntilChangedSubscriber.prototype._next = function (value) {
            var keySelector = this.keySelector;
            var key = value;
            if (keySelector) {
                key = tryCatch_1.tryCatch(this.keySelector)(value);
                if (key === errorObject.errorObject) {
                    return this.destination.error(errorObject.errorObject.e);
                }
            }
            var result = false;
            if (this.hasKey) {
                result = tryCatch_1.tryCatch(this.compare)(this.key, key);
                if (result === errorObject.errorObject) {
                    return this.destination.error(errorObject.errorObject.e);
                }
            }
            else {
                this.hasKey = true;
            }
            if (Boolean(result) === false) {
                this.key = key;
                this.destination.next(value);
            }
        };
        return DistinctUntilChangedSubscriber;
    }(Subscriber_1.Subscriber));


    var distinctUntilChanged_1 = {
    	distinctUntilChanged: distinctUntilChanged_2
    };

    /* tslint:enable:max-line-length */
    /**
     * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from the previous item.
     *
     * If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.
     *
     * If a comparator function is not provided, an equality check is used by default.
     *
     * @example <caption>A simple example with numbers</caption>
     * Observable.of(1, 1, 2, 2, 2, 1, 1, 2, 3, 3, 4)
     *   .distinctUntilChanged()
     *   .subscribe(x => console.log(x)); // 1, 2, 1, 2, 3, 4
     *
     * @example <caption>An example using a compare function</caption>
     * interface Person {
     *    age: number,
     *    name: string
     * }
     *
     * Observable.of<Person>(
     *     { age: 4, name: 'Foo'},
     *     { age: 7, name: 'Bar'},
     *     { age: 5, name: 'Foo'})
     *     { age: 6, name: 'Foo'})
     *     .distinctUntilChanged((p: Person, q: Person) => p.name === q.name)
     *     .subscribe(x => console.log(x));
     *
     * // displays:
     * // { age: 4, name: 'Foo' }
     * // { age: 7, name: 'Bar' }
     * // { age: 5, name: 'Foo' }
     *
     * @see {@link distinct}
     * @see {@link distinctUntilKeyChanged}
     *
     * @param {function} [compare] Optional comparison function called to test if an item is distinct from the previous item in the source.
     * @return {Observable} An Observable that emits items from the source Observable with distinct values.
     * @method distinctUntilChanged
     * @owner Observable
     */
    function distinctUntilChanged$1(compare, keySelector) {
        return distinctUntilChanged_1.distinctUntilChanged(compare, keySelector)(this);
    }
    var distinctUntilChanged_3 = distinctUntilChanged$1;


    var distinctUntilChanged_2$1 = {
    	distinctUntilChanged: distinctUntilChanged_3
    };

    Observable_1.Observable.prototype.distinctUntilChanged = distinctUntilChanged_2$1.distinctUntilChanged;

    /* tslint:enable:max-line-length */
    /**
     * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from the previous item,
     * using a property accessed by using the key provided to check if the two items are distinct.
     *
     * If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.
     *
     * If a comparator function is not provided, an equality check is used by default.
     *
     * @example <caption>An example comparing the name of persons</caption>
     *
     *  interface Person {
     *     age: number,
     *     name: string
     *  }
     *
     * Observable.of<Person>(
     *     { age: 4, name: 'Foo'},
     *     { age: 7, name: 'Bar'},
     *     { age: 5, name: 'Foo'},
     *     { age: 6, name: 'Foo'})
     *     .distinctUntilKeyChanged('name')
     *     .subscribe(x => console.log(x));
     *
     * // displays:
     * // { age: 4, name: 'Foo' }
     * // { age: 7, name: 'Bar' }
     * // { age: 5, name: 'Foo' }
     *
     * @example <caption>An example comparing the first letters of the name</caption>
     *
     * interface Person {
     *     age: number,
     *     name: string
     *  }
     *
     * Observable.of<Person>(
     *     { age: 4, name: 'Foo1'},
     *     { age: 7, name: 'Bar'},
     *     { age: 5, name: 'Foo2'},
     *     { age: 6, name: 'Foo3'})
     *     .distinctUntilKeyChanged('name', (x: string, y: string) => x.substring(0, 3) === y.substring(0, 3))
     *     .subscribe(x => console.log(x));
     *
     * // displays:
     * // { age: 4, name: 'Foo1' }
     * // { age: 7, name: 'Bar' }
     * // { age: 5, name: 'Foo2' }
     *
     * @see {@link distinct}
     * @see {@link distinctUntilChanged}
     *
     * @param {string} key String key for object property lookup on each item.
     * @param {function} [compare] Optional comparison function called to test if an item is distinct from the previous item in the source.
     * @return {Observable} An Observable that emits items from the source Observable with distinct values based on the key specified.
     * @method distinctUntilKeyChanged
     * @owner Observable
     */
    function distinctUntilKeyChanged(key, compare) {
        return distinctUntilChanged_1.distinctUntilChanged(function (x, y) { return compare ? compare(x[key], y[key]) : x[key] === y[key]; });
    }
    var distinctUntilKeyChanged_2 = distinctUntilKeyChanged;


    var distinctUntilKeyChanged_1 = {
    	distinctUntilKeyChanged: distinctUntilKeyChanged_2
    };

    /* tslint:enable:max-line-length */
    /**
     * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from the previous item,
     * using a property accessed by using the key provided to check if the two items are distinct.
     *
     * If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.
     *
     * If a comparator function is not provided, an equality check is used by default.
     *
     * @example <caption>An example comparing the name of persons</caption>
     *
     *  interface Person {
     *     age: number,
     *     name: string
     *  }
     *
     * Observable.of<Person>(
     *     { age: 4, name: 'Foo'},
     *     { age: 7, name: 'Bar'},
     *     { age: 5, name: 'Foo'},
     *     { age: 6, name: 'Foo'})
     *     .distinctUntilKeyChanged('name')
     *     .subscribe(x => console.log(x));
     *
     * // displays:
     * // { age: 4, name: 'Foo' }
     * // { age: 7, name: 'Bar' }
     * // { age: 5, name: 'Foo' }
     *
     * @example <caption>An example comparing the first letters of the name</caption>
     *
     * interface Person {
     *     age: number,
     *     name: string
     *  }
     *
     * Observable.of<Person>(
     *     { age: 4, name: 'Foo1'},
     *     { age: 7, name: 'Bar'},
     *     { age: 5, name: 'Foo2'},
     *     { age: 6, name: 'Foo3'})
     *     .distinctUntilKeyChanged('name', (x: string, y: string) => x.substring(0, 3) === y.substring(0, 3))
     *     .subscribe(x => console.log(x));
     *
     * // displays:
     * // { age: 4, name: 'Foo1' }
     * // { age: 7, name: 'Bar' }
     * // { age: 5, name: 'Foo2' }
     *
     * @see {@link distinct}
     * @see {@link distinctUntilChanged}
     *
     * @param {string} key String key for object property lookup on each item.
     * @param {function} [compare] Optional comparison function called to test if an item is distinct from the previous item in the source.
     * @return {Observable} An Observable that emits items from the source Observable with distinct values based on the key specified.
     * @method distinctUntilKeyChanged
     * @owner Observable
     */
    function distinctUntilKeyChanged$1(key, compare) {
        return distinctUntilKeyChanged_1.distinctUntilKeyChanged(key, compare)(this);
    }
    var distinctUntilKeyChanged_3 = distinctUntilKeyChanged$1;


    var distinctUntilKeyChanged_2$1 = {
    	distinctUntilKeyChanged: distinctUntilKeyChanged_3
    };

    Observable_1.Observable.prototype.distinctUntilKeyChanged = distinctUntilKeyChanged_2$1.distinctUntilKeyChanged;

    var __extends$1f = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };

    /* tslint:enable:max-line-length */
    /**
     * Perform a side effect for every emission on the source Observable, but return
     * an Observable that is identical to the source.
     *
     * <span class="informal">Intercepts each emission on the source and runs a
     * function, but returns an output which is identical to the source as long as errors don't occur.</span>
     *
     * <img src="./img/do.png" width="100%">
     *
     * Returns a mirrored Observable of the source Observable, but modified so that
     * the provided Observer is called to perform a side effect for every value,
     * error, and completion emitted by the source. Any errors that are thrown in
     * the aforementioned Observer or handlers are safely sent down the error path
     * of the output Observable.
     *
     * This operator is useful for debugging your Observables for the correct values
     * or performing other side effects.
     *
     * Note: this is different to a `subscribe` on the Observable. If the Observable
     * returned by `do` is not subscribed, the side effects specified by the
     * Observer will never happen. `do` therefore simply spies on existing
     * execution, it does not trigger an execution to happen like `subscribe` does.
     *
     * @example <caption>Map every click to the clientX position of that click, while also logging the click event</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var positions = clicks
     *   .do(ev => console.log(ev))
     *   .map(ev => ev.clientX);
     * positions.subscribe(x => console.log(x));
     *
     * @see {@link map}
     * @see {@link subscribe}
     *
     * @param {Observer|function} [nextOrObserver] A normal Observer object or a
     * callback for `next`.
     * @param {function} [error] Callback for errors in the source.
     * @param {function} [complete] Callback for the completion of the source.
     * @return {Observable} An Observable identical to the source, but runs the
     * specified Observer or callback(s) for each item.
     * @name tap
     */
    function tap(nextOrObserver, error, complete) {
        return function tapOperatorFunction(source) {
            return source.lift(new DoOperator(nextOrObserver, error, complete));
        };
    }
    var tap_2 = tap;
    var DoOperator = (function () {
        function DoOperator(nextOrObserver, error, complete) {
            this.nextOrObserver = nextOrObserver;
            this.error = error;
            this.complete = complete;
        }
        DoOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(new DoSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));
        };
        return DoOperator;
    }());
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var DoSubscriber = (function (_super) {
        __extends$1f(DoSubscriber, _super);
        function DoSubscriber(destination, nextOrObserver, error, complete) {
            _super.call(this, destination);
            var safeSubscriber = new Subscriber_1.Subscriber(nextOrObserver, error, complete);
            safeSubscriber.syncErrorThrowable = true;
            this.add(safeSubscriber);
            this.safeSubscriber = safeSubscriber;
        }
        DoSubscriber.prototype._next = function (value) {
            var safeSubscriber = this.safeSubscriber;
            safeSubscriber.next(value);
            if (safeSubscriber.syncErrorThrown) {
                this.destination.error(safeSubscriber.syncErrorValue);
            }
            else {
                this.destination.next(value);
            }
        };
        DoSubscriber.prototype._error = function (err) {
            var safeSubscriber = this.safeSubscriber;
            safeSubscriber.error(err);
            if (safeSubscriber.syncErrorThrown) {
                this.destination.error(safeSubscriber.syncErrorValue);
            }
            else {
                this.destination.error(err);
            }
        };
        DoSubscriber.prototype._complete = function () {
            var safeSubscriber = this.safeSubscriber;
            safeSubscriber.complete();
            if (safeSubscriber.syncErrorThrown) {
                this.destination.error(safeSubscriber.syncErrorValue);
            }
            else {
                this.destination.complete();
            }
        };
        return DoSubscriber;
    }(Subscriber_1.Subscriber));


    var tap_1 = {
    	tap: tap_2
    };

    /* tslint:enable:max-line-length */
    /**
     * Perform a side effect for every emission on the source Observable, but return
     * an Observable that is identical to the source.
     *
     * <span class="informal">Intercepts each emission on the source and runs a
     * function, but returns an output which is identical to the source as long as errors don't occur.</span>
     *
     * <img src="./img/do.png" width="100%">
     *
     * Returns a mirrored Observable of the source Observable, but modified so that
     * the provided Observer is called to perform a side effect for every value,
     * error, and completion emitted by the source. Any errors that are thrown in
     * the aforementioned Observer or handlers are safely sent down the error path
     * of the output Observable.
     *
     * This operator is useful for debugging your Observables for the correct values
     * or performing other side effects.
     *
     * Note: this is different to a `subscribe` on the Observable. If the Observable
     * returned by `do` is not subscribed, the side effects specified by the
     * Observer will never happen. `do` therefore simply spies on existing
     * execution, it does not trigger an execution to happen like `subscribe` does.
     *
     * @example <caption>Map every click to the clientX position of that click, while also logging the click event</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var positions = clicks
     *   .do(ev => console.log(ev))
     *   .map(ev => ev.clientX);
     * positions.subscribe(x => console.log(x));
     *
     * @see {@link map}
     * @see {@link subscribe}
     *
     * @param {Observer|function} [nextOrObserver] A normal Observer object or a
     * callback for `next`.
     * @param {function} [error] Callback for errors in the source.
     * @param {function} [complete] Callback for the completion of the source.
     * @return {Observable} An Observable identical to the source, but runs the
     * specified Observer or callback(s) for each item.
     * @method do
     * @name do
     * @owner Observable
     */
    function _do(nextOrObserver, error, complete) {
        return tap_1.tap(nextOrObserver, error, complete)(this);
    }
    var _do_2 = _do;


    var _do_1 = {
    	_do: _do_2
    };

    Observable_1.Observable.prototype.do = _do_1._do;
    Observable_1.Observable.prototype._do = _do_1._do;

    var __extends$1g = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };


    /**
     * Converts a higher-order Observable into a first-order Observable by dropping
     * inner Observables while the previous inner Observable has not yet completed.
     *
     * <span class="informal">Flattens an Observable-of-Observables by dropping the
     * next inner Observables while the current inner is still executing.</span>
     *
     * <img src="./img/exhaust.png" width="100%">
     *
     * `exhaust` subscribes to an Observable that emits Observables, also known as a
     * higher-order Observable. Each time it observes one of these emitted inner
     * Observables, the output Observable begins emitting the items emitted by that
     * inner Observable. So far, it behaves like {@link mergeAll}. However,
     * `exhaust` ignores every new inner Observable if the previous Observable has
     * not yet completed. Once that one completes, it will accept and flatten the
     * next inner Observable and repeat this process.
     *
     * @example <caption>Run a finite timer for each click, only if there is no currently active timer</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000).take(5));
     * var result = higherOrder.exhaust();
     * result.subscribe(x => console.log(x));
     *
     * @see {@link combineAll}
     * @see {@link concatAll}
     * @see {@link switch}
     * @see {@link mergeAll}
     * @see {@link exhaustMap}
     * @see {@link zipAll}
     *
     * @return {Observable} An Observable that takes a source of Observables and propagates the first observable
     * exclusively until it completes before subscribing to the next.
     * @method exhaust
     * @owner Observable
     */
    function exhaust() {
        return function (source) { return source.lift(new SwitchFirstOperator()); };
    }
    var exhaust_2 = exhaust;
    var SwitchFirstOperator = (function () {
        function SwitchFirstOperator() {
        }
        SwitchFirstOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(new SwitchFirstSubscriber(subscriber));
        };
        return SwitchFirstOperator;
    }());
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var SwitchFirstSubscriber = (function (_super) {
        __extends$1g(SwitchFirstSubscriber, _super);
        function SwitchFirstSubscriber(destination) {
            _super.call(this, destination);
            this.hasCompleted = false;
            this.hasSubscription = false;
        }
        SwitchFirstSubscriber.prototype._next = function (value) {
            if (!this.hasSubscription) {
                this.hasSubscription = true;
                this.add(subscribeToResult_1.subscribeToResult(this, value));
            }
        };
        SwitchFirstSubscriber.prototype._complete = function () {
            this.hasCompleted = true;
            if (!this.hasSubscription) {
                this.destination.complete();
            }
        };
        SwitchFirstSubscriber.prototype.notifyComplete = function (innerSub) {
            this.remove(innerSub);
            this.hasSubscription = false;
            if (this.hasCompleted) {
                this.destination.complete();
            }
        };
        return SwitchFirstSubscriber;
    }(OuterSubscriber_1.OuterSubscriber));


    var exhaust_1 = {
    	exhaust: exhaust_2
    };

    /**
     * Converts a higher-order Observable into a first-order Observable by dropping
     * inner Observables while the previous inner Observable has not yet completed.
     *
     * <span class="informal">Flattens an Observable-of-Observables by dropping the
     * next inner Observables while the current inner is still executing.</span>
     *
     * <img src="./img/exhaust.png" width="100%">
     *
     * `exhaust` subscribes to an Observable that emits Observables, also known as a
     * higher-order Observable. Each time it observes one of these emitted inner
     * Observables, the output Observable begins emitting the items emitted by that
     * inner Observable. So far, it behaves like {@link mergeAll}. However,
     * `exhaust` ignores every new inner Observable if the previous Observable has
     * not yet completed. Once that one completes, it will accept and flatten the
     * next inner Observable and repeat this process.
     *
     * @example <caption>Run a finite timer for each click, only if there is no currently active timer</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000).take(5));
     * var result = higherOrder.exhaust();
     * result.subscribe(x => console.log(x));
     *
     * @see {@link combineAll}
     * @see {@link concatAll}
     * @see {@link switch}
     * @see {@link mergeAll}
     * @see {@link exhaustMap}
     * @see {@link zipAll}
     *
     * @return {Observable} An Observable that takes a source of Observables and propagates the first observable
     * exclusively until it completes before subscribing to the next.
     * @method exhaust
     * @owner Observable
     */
    function exhaust$1() {
        return exhaust_1.exhaust()(this);
    }
    var exhaust_3 = exhaust$1;


    var exhaust_2$1 = {
    	exhaust: exhaust_3
    };

    Observable_1.Observable.prototype.exhaust = exhaust_2$1.exhaust;

    var __extends$1h = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };


    /* tslint:enable:max-line-length */
    /**
     * Projects each source value to an Observable which is merged in the output
     * Observable only if the previous projected Observable has completed.
     *
     * <span class="informal">Maps each value to an Observable, then flattens all of
     * these inner Observables using {@link exhaust}.</span>
     *
     * <img src="./img/exhaustMap.png" width="100%">
     *
     * Returns an Observable that emits items based on applying a function that you
     * supply to each item emitted by the source Observable, where that function
     * returns an (so-called "inner") Observable. When it projects a source value to
     * an Observable, the output Observable begins emitting the items emitted by
     * that projected Observable. However, `exhaustMap` ignores every new projected
     * Observable if the previous projected Observable has not yet completed. Once
     * that one completes, it will accept and flatten the next projected Observable
     * and repeat this process.
     *
     * @example <caption>Run a finite timer for each click, only if there is no currently active timer</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var result = clicks.exhaustMap((ev) => Rx.Observable.interval(1000).take(5));
     * result.subscribe(x => console.log(x));
     *
     * @see {@link concatMap}
     * @see {@link exhaust}
     * @see {@link mergeMap}
     * @see {@link switchMap}
     *
     * @param {function(value: T, ?index: number): ObservableInput} project A function
     * that, when applied to an item emitted by the source Observable, returns an
     * Observable.
     * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
     * A function to produce the value on the output Observable based on the values
     * and the indices of the source (outer) emission and the inner Observable
     * emission. The arguments passed to this function are:
     * - `outerValue`: the value that came from the source
     * - `innerValue`: the value that came from the projected Observable
     * - `outerIndex`: the "index" of the value that came from the source
     * - `innerIndex`: the "index" of the value from the projected Observable
     * @return {Observable} An Observable containing projected Observables
     * of each item of the source, ignoring projected Observables that start before
     * their preceding Observable has completed.
     * @method exhaustMap
     * @owner Observable
     */
    function exhaustMap(project, resultSelector) {
        return function (source) { return source.lift(new SwitchFirstMapOperator(project, resultSelector)); };
    }
    var exhaustMap_2 = exhaustMap;
    var SwitchFirstMapOperator = (function () {
        function SwitchFirstMapOperator(project, resultSelector) {
            this.project = project;
            this.resultSelector = resultSelector;
        }
        SwitchFirstMapOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(new SwitchFirstMapSubscriber(subscriber, this.project, this.resultSelector));
        };
        return SwitchFirstMapOperator;
    }());
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var SwitchFirstMapSubscriber = (function (_super) {
        __extends$1h(SwitchFirstMapSubscriber, _super);
        function SwitchFirstMapSubscriber(destination, project, resultSelector) {
            _super.call(this, destination);
            this.project = project;
            this.resultSelector = resultSelector;
            this.hasSubscription = false;
            this.hasCompleted = false;
            this.index = 0;
        }
        SwitchFirstMapSubscriber.prototype._next = function (value) {
            if (!this.hasSubscription) {
                this.tryNext(value);
            }
        };
        SwitchFirstMapSubscriber.prototype.tryNext = function (value) {
            var index = this.index++;
            var destination = this.destination;
            try {
                var result = this.project(value, index);
                this.hasSubscription = true;
                this.add(subscribeToResult_1.subscribeToResult(this, result, value, index));
            }
            catch (err) {
                destination.error(err);
            }
        };
        SwitchFirstMapSubscriber.prototype._complete = function () {
            this.hasCompleted = true;
            if (!this.hasSubscription) {
                this.destination.complete();
            }
        };
        SwitchFirstMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
            var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;
            if (resultSelector) {
                this.trySelectResult(outerValue, innerValue, outerIndex, innerIndex);
            }
            else {
                destination.next(innerValue);
            }
        };
        SwitchFirstMapSubscriber.prototype.trySelectResult = function (outerValue, innerValue, outerIndex, innerIndex) {
            var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;
            try {
                var result = resultSelector(outerValue, innerValue, outerIndex, innerIndex);
                destination.next(result);
            }
            catch (err) {
                destination.error(err);
            }
        };
        SwitchFirstMapSubscriber.prototype.notifyError = function (err) {
            this.destination.error(err);
        };
        SwitchFirstMapSubscriber.prototype.notifyComplete = function (innerSub) {
            this.remove(innerSub);
            this.hasSubscription = false;
            if (this.hasCompleted) {
                this.destination.complete();
            }
        };
        return SwitchFirstMapSubscriber;
    }(OuterSubscriber_1.OuterSubscriber));


    var exhaustMap_1 = {
    	exhaustMap: exhaustMap_2
    };

    /* tslint:enable:max-line-length */
    /**
     * Projects each source value to an Observable which is merged in the output
     * Observable only if the previous projected Observable has completed.
     *
     * <span class="informal">Maps each value to an Observable, then flattens all of
     * these inner Observables using {@link exhaust}.</span>
     *
     * <img src="./img/exhaustMap.png" width="100%">
     *
     * Returns an Observable that emits items based on applying a function that you
     * supply to each item emitted by the source Observable, where that function
     * returns an (so-called "inner") Observable. When it projects a source value to
     * an Observable, the output Observable begins emitting the items emitted by
     * that projected Observable. However, `exhaustMap` ignores every new projected
     * Observable if the previous projected Observable has not yet completed. Once
     * that one completes, it will accept and flatten the next projected Observable
     * and repeat this process.
     *
     * @example <caption>Run a finite timer for each click, only if there is no currently active timer</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var result = clicks.exhaustMap((ev) => Rx.Observable.interval(1000).take(5));
     * result.subscribe(x => console.log(x));
     *
     * @see {@link concatMap}
     * @see {@link exhaust}
     * @see {@link mergeMap}
     * @see {@link switchMap}
     *
     * @param {function(value: T, ?index: number): ObservableInput} project A function
     * that, when applied to an item emitted by the source Observable, returns an
     * Observable.
     * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
     * A function to produce the value on the output Observable based on the values
     * and the indices of the source (outer) emission and the inner Observable
     * emission. The arguments passed to this function are:
     * - `outerValue`: the value that came from the source
     * - `innerValue`: the value that came from the projected Observable
     * - `outerIndex`: the "index" of the value that came from the source
     * - `innerIndex`: the "index" of the value from the projected Observable
     * @return {Observable} An Observable containing projected Observables
     * of each item of the source, ignoring projected Observables that start before
     * their preceding Observable has completed.
     * @method exhaustMap
     * @owner Observable
     */
    function exhaustMap$1(project, resultSelector) {
        return exhaustMap_1.exhaustMap(project, resultSelector)(this);
    }
    var exhaustMap_3 = exhaustMap$1;


    var exhaustMap_2$1 = {
    	exhaustMap: exhaustMap_3
    };

    Observable_1.Observable.prototype.exhaustMap = exhaustMap_2$1.exhaustMap;

    var __extends$1i = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };




    /* tslint:enable:max-line-length */
    /**
     * Recursively projects each source value to an Observable which is merged in
     * the output Observable.
     *
     * <span class="informal">It's similar to {@link mergeMap}, but applies the
     * projection function to every source value as well as every output value.
     * It's recursive.</span>
     *
     * <img src="./img/expand.png" width="100%">
     *
     * Returns an Observable that emits items based on applying a function that you
     * supply to each item emitted by the source Observable, where that function
     * returns an Observable, and then merging those resulting Observables and
     * emitting the results of this merger. *Expand* will re-emit on the output
     * Observable every source value. Then, each output value is given to the
     * `project` function which returns an inner Observable to be merged on the
     * output Observable. Those output values resulting from the projection are also
     * given to the `project` function to produce new output values. This is how
     * *expand* behaves recursively.
     *
     * @example <caption>Start emitting the powers of two on every click, at most 10 of them</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var powersOfTwo = clicks
     *   .mapTo(1)
     *   .expand(x => Rx.Observable.of(2 * x).delay(1000))
     *   .take(10);
     * powersOfTwo.subscribe(x => console.log(x));
     *
     * @see {@link mergeMap}
     * @see {@link mergeScan}
     *
     * @param {function(value: T, index: number) => Observable} project A function
     * that, when applied to an item emitted by the source or the output Observable,
     * returns an Observable.
     * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
     * Observables being subscribed to concurrently.
     * @param {Scheduler} [scheduler=null] The IScheduler to use for subscribing to
     * each projected inner Observable.
     * @return {Observable} An Observable that emits the source values and also
     * result of applying the projection function to each value emitted on the
     * output Observable and and merging the results of the Observables obtained
     * from this transformation.
     * @method expand
     * @owner Observable
     */
    function expand(project, concurrent, scheduler) {
        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
        if (scheduler === void 0) { scheduler = undefined; }
        concurrent = (concurrent || 0) < 1 ? Number.POSITIVE_INFINITY : concurrent;
        return function (source) { return source.lift(new ExpandOperator(project, concurrent, scheduler)); };
    }
    var expand_2 = expand;
    var ExpandOperator = (function () {
        function ExpandOperator(project, concurrent, scheduler) {
            this.project = project;
            this.concurrent = concurrent;
            this.scheduler = scheduler;
        }
        ExpandOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(new ExpandSubscriber(subscriber, this.project, this.concurrent, this.scheduler));
        };
        return ExpandOperator;
    }());
    var ExpandOperator_1 = ExpandOperator;
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var ExpandSubscriber = (function (_super) {
        __extends$1i(ExpandSubscriber, _super);
        function ExpandSubscriber(destination, project, concurrent, scheduler) {
            _super.call(this, destination);
            this.project = project;
            this.concurrent = concurrent;
            this.scheduler = scheduler;
            this.index = 0;
            this.active = 0;
            this.hasCompleted = false;
            if (concurrent < Number.POSITIVE_INFINITY) {
                this.buffer = [];
            }
        }
        ExpandSubscriber.dispatch = function (arg) {
            var subscriber = arg.subscriber, result = arg.result, value = arg.value, index = arg.index;
            subscriber.subscribeToProjection(result, value, index);
        };
        ExpandSubscriber.prototype._next = function (value) {
            var destination = this.destination;
            if (destination.closed) {
                this._complete();
                return;
            }
            var index = this.index++;
            if (this.active < this.concurrent) {
                destination.next(value);
                var result = tryCatch_1.tryCatch(this.project)(value, index);
                if (result === errorObject.errorObject) {
                    destination.error(errorObject.errorObject.e);
                }
                else if (!this.scheduler) {
                    this.subscribeToProjection(result, value, index);
                }
                else {
                    var state = { subscriber: this, result: result, value: value, index: index };
                    this.add(this.scheduler.schedule(ExpandSubscriber.dispatch, 0, state));
                }
            }
            else {
                this.buffer.push(value);
            }
        };
        ExpandSubscriber.prototype.subscribeToProjection = function (result, value, index) {
            this.active++;
            this.add(subscribeToResult_1.subscribeToResult(this, result, value, index));
        };
        ExpandSubscriber.prototype._complete = function () {
            this.hasCompleted = true;
            if (this.hasCompleted && this.active === 0) {
                this.destination.complete();
            }
        };
        ExpandSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
            this._next(innerValue);
        };
        ExpandSubscriber.prototype.notifyComplete = function (innerSub) {
            var buffer = this.buffer;
            this.remove(innerSub);
            this.active--;
            if (buffer && buffer.length > 0) {
                this._next(buffer.shift());
            }
            if (this.hasCompleted && this.active === 0) {
                this.destination.complete();
            }
        };
        return ExpandSubscriber;
    }(OuterSubscriber_1.OuterSubscriber));
    var ExpandSubscriber_1 = ExpandSubscriber;


    var expand_1 = {
    	expand: expand_2,
    	ExpandOperator: ExpandOperator_1,
    	ExpandSubscriber: ExpandSubscriber_1
    };

    /* tslint:enable:max-line-length */
    /**
     * Recursively projects each source value to an Observable which is merged in
     * the output Observable.
     *
     * <span class="informal">It's similar to {@link mergeMap}, but applies the
     * projection function to every source value as well as every output value.
     * It's recursive.</span>
     *
     * <img src="./img/expand.png" width="100%">
     *
     * Returns an Observable that emits items based on applying a function that you
     * supply to each item emitted by the source Observable, where that function
     * returns an Observable, and then merging those resulting Observables and
     * emitting the results of this merger. *Expand* will re-emit on the output
     * Observable every source value. Then, each output value is given to the
     * `project` function which returns an inner Observable to be merged on the
     * output Observable. Those output values resulting from the projection are also
     * given to the `project` function to produce new output values. This is how
     * *expand* behaves recursively.
     *
     * @example <caption>Start emitting the powers of two on every click, at most 10 of them</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var powersOfTwo = clicks
     *   .mapTo(1)
     *   .expand(x => Rx.Observable.of(2 * x).delay(1000))
     *   .take(10);
     * powersOfTwo.subscribe(x => console.log(x));
     *
     * @see {@link mergeMap}
     * @see {@link mergeScan}
     *
     * @param {function(value: T, index: number) => Observable} project A function
     * that, when applied to an item emitted by the source or the output Observable,
     * returns an Observable.
     * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
     * Observables being subscribed to concurrently.
     * @param {Scheduler} [scheduler=null] The IScheduler to use for subscribing to
     * each projected inner Observable.
     * @return {Observable} An Observable that emits the source values and also
     * result of applying the projection function to each value emitted on the
     * output Observable and and merging the results of the Observables obtained
     * from this transformation.
     * @method expand
     * @owner Observable
     */
    function expand$1(project, concurrent, scheduler) {
        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
        if (scheduler === void 0) { scheduler = undefined; }
        concurrent = (concurrent || 0) < 1 ? Number.POSITIVE_INFINITY : concurrent;
        return expand_1.expand(project, concurrent, scheduler)(this);
    }
    var expand_3 = expand$1;


    var expand_2$1 = {
    	expand: expand_3
    };

    Observable_1.Observable.prototype.expand = expand_2$1.expand;

    var __extends$1j = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    /**
     * An error thrown when an element was queried at a certain index of an
     * Observable, but no such index or position exists in that sequence.
     *
     * @see {@link elementAt}
     * @see {@link take}
     * @see {@link takeLast}
     *
     * @class ArgumentOutOfRangeError
     */
    var ArgumentOutOfRangeError = (function (_super) {
        __extends$1j(ArgumentOutOfRangeError, _super);
        function ArgumentOutOfRangeError() {
            var err = _super.call(this, 'argument out of range');
            this.name = err.name = 'ArgumentOutOfRangeError';
            this.stack = err.stack;
            this.message = err.message;
        }
        return ArgumentOutOfRangeError;
    }(Error));
    var ArgumentOutOfRangeError_2 = ArgumentOutOfRangeError;


    var ArgumentOutOfRangeError_1 = {
    	ArgumentOutOfRangeError: ArgumentOutOfRangeError_2
    };

    var __extends$1k = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };


    /**
     * Emits the single value at the specified `index` in a sequence of emissions
     * from the source Observable.
     *
     * <span class="informal">Emits only the i-th value, then completes.</span>
     *
     * <img src="./img/elementAt.png" width="100%">
     *
     * `elementAt` returns an Observable that emits the item at the specified
     * `index` in the source Observable, or a default value if that `index` is out
     * of range and the `default` argument is provided. If the `default` argument is
     * not given and the `index` is out of range, the output Observable will emit an
     * `ArgumentOutOfRangeError` error.
     *
     * @example <caption>Emit only the third click event</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var result = clicks.elementAt(2);
     * result.subscribe(x => console.log(x));
     *
     * // Results in:
     * // click 1 = nothing
     * // click 2 = nothing
     * // click 3 = MouseEvent object logged to console
     *
     * @see {@link first}
     * @see {@link last}
     * @see {@link skip}
     * @see {@link single}
     * @see {@link take}
     *
     * @throws {ArgumentOutOfRangeError} When using `elementAt(i)`, it delivers an
     * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0` or the
     * Observable has completed before emitting the i-th `next` notification.
     *
     * @param {number} index Is the number `i` for the i-th source emission that has
     * happened since the subscription, starting from the number `0`.
     * @param {T} [defaultValue] The default value returned for missing indices.
     * @return {Observable} An Observable that emits a single item, if it is found.
     * Otherwise, will emit the default value if given. If not, then emits an error.
     * @method elementAt
     * @owner Observable
     */
    function elementAt(index, defaultValue) {
        return function (source) { return source.lift(new ElementAtOperator(index, defaultValue)); };
    }
    var elementAt_2 = elementAt;
    var ElementAtOperator = (function () {
        function ElementAtOperator(index, defaultValue) {
            this.index = index;
            this.defaultValue = defaultValue;
            if (index < 0) {
                throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;
            }
        }
        ElementAtOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(new ElementAtSubscriber(subscriber, this.index, this.defaultValue));
        };
        return ElementAtOperator;
    }());
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var ElementAtSubscriber = (function (_super) {
        __extends$1k(ElementAtSubscriber, _super);
        function ElementAtSubscriber(destination, index, defaultValue) {
            _super.call(this, destination);
            this.index = index;
            this.defaultValue = defaultValue;
        }
        ElementAtSubscriber.prototype._next = function (x) {
            if (this.index-- === 0) {
                this.destination.next(x);
                this.destination.complete();
            }
        };
        ElementAtSubscriber.prototype._complete = function () {
            var destination = this.destination;
            if (this.index >= 0) {
                if (typeof this.defaultValue !== 'undefined') {
                    destination.next(this.defaultValue);
                }
                else {
                    destination.error(new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError);
                }
            }
            destination.complete();
        };
        return ElementAtSubscriber;
    }(Subscriber_1.Subscriber));


    var elementAt_1 = {
    	elementAt: elementAt_2
    };

    /**
     * Emits the single value at the specified `index` in a sequence of emissions
     * from the source Observable.
     *
     * <span class="informal">Emits only the i-th value, then completes.</span>
     *
     * <img src="./img/elementAt.png" width="100%">
     *
     * `elementAt` returns an Observable that emits the item at the specified
     * `index` in the source Observable, or a default value if that `index` is out
     * of range and the `default` argument is provided. If the `default` argument is
     * not given and the `index` is out of range, the output Observable will emit an
     * `ArgumentOutOfRangeError` error.
     *
     * @example <caption>Emit only the third click event</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var result = clicks.elementAt(2);
     * result.subscribe(x => console.log(x));
     *
     * // Results in:
     * // click 1 = nothing
     * // click 2 = nothing
     * // click 3 = MouseEvent object logged to console
     *
     * @see {@link first}
     * @see {@link last}
     * @see {@link skip}
     * @see {@link single}
     * @see {@link take}
     *
     * @throws {ArgumentOutOfRangeError} When using `elementAt(i)`, it delivers an
     * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0` or the
     * Observable has completed before emitting the i-th `next` notification.
     *
     * @param {number} index Is the number `i` for the i-th source emission that has
     * happened since the subscription, starting from the number `0`.
     * @param {T} [defaultValue] The default value returned for missing indices.
     * @return {Observable} An Observable that emits a single item, if it is found.
     * Otherwise, will emit the default value if given. If not, then emits an error.
     * @method elementAt
     * @owner Observable
     */
    function elementAt$1(index, defaultValue) {
        return elementAt_1.elementAt(index, defaultValue)(this);
    }
    var elementAt_3 = elementAt$1;


    var elementAt_2$1 = {
    	elementAt: elementAt_3
    };

    Observable_1.Observable.prototype.elementAt = elementAt_2$1.elementAt;

    var __extends$1l = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };

    /* tslint:enable:max-line-length */
    /**
     * Filter items emitted by the source Observable by only emitting those that
     * satisfy a specified predicate.
     *
     * <span class="informal">Like
     * [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),
     * it only emits a value from the source if it passes a criterion function.</span>
     *
     * <img src="./img/filter.png" width="100%">
     *
     * Similar to the well-known `Array.prototype.filter` method, this operator
     * takes values from the source Observable, passes them through a `predicate`
     * function and only emits those values that yielded `true`.
     *
     * @example <caption>Emit only click events whose target was a DIV element</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var clicksOnDivs = clicks.filter(ev => ev.target.tagName === 'DIV');
     * clicksOnDivs.subscribe(x => console.log(x));
     *
     * @see {@link distinct}
     * @see {@link distinctUntilChanged}
     * @see {@link distinctUntilKeyChanged}
     * @see {@link ignoreElements}
     * @see {@link partition}
     * @see {@link skip}
     *
     * @param {function(value: T, index: number): boolean} predicate A function that
     * evaluates each value emitted by the source Observable. If it returns `true`,
     * the value is emitted, if `false` the value is not passed to the output
     * Observable. The `index` parameter is the number `i` for the i-th source
     * emission that has happened since the subscription, starting from the number
     * `0`.
     * @param {any} [thisArg] An optional argument to determine the value of `this`
     * in the `predicate` function.
     * @return {Observable} An Observable of values from the source that were
     * allowed by the `predicate` function.
     * @method filter
     * @owner Observable
     */
    function filter$1(predicate, thisArg) {
        return function filterOperatorFunction(source) {
            return source.lift(new FilterOperator(predicate, thisArg));
        };
    }
    var filter_2 = filter$1;
    var FilterOperator = (function () {
        function FilterOperator(predicate, thisArg) {
            this.predicate = predicate;
            this.thisArg = thisArg;
        }
        FilterOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));
        };
        return FilterOperator;
    }());
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var FilterSubscriber = (function (_super) {
        __extends$1l(FilterSubscriber, _super);
        function FilterSubscriber(destination, predicate, thisArg) {
            _super.call(this, destination);
            this.predicate = predicate;
            this.thisArg = thisArg;
            this.count = 0;
        }
        // the try catch block below is left specifically for
        // optimization and perf reasons. a tryCatcher is not necessary here.
        FilterSubscriber.prototype._next = function (value) {
            var result;
            try {
                result = this.predicate.call(this.thisArg, value, this.count++);
            }
            catch (err) {
                this.destination.error(err);
                return;
            }
            if (result) {
                this.destination.next(value);
            }
        };
        return FilterSubscriber;
    }(Subscriber_1.Subscriber));


    var filter_1 = {
    	filter: filter_2
    };

    /* tslint:enable:max-line-length */
    /**
     * Filter items emitted by the source Observable by only emitting those that
     * satisfy a specified predicate.
     *
     * <span class="informal">Like
     * [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),
     * it only emits a value from the source if it passes a criterion function.</span>
     *
     * <img src="./img/filter.png" width="100%">
     *
     * Similar to the well-known `Array.prototype.filter` method, this operator
     * takes values from the source Observable, passes them through a `predicate`
     * function and only emits those values that yielded `true`.
     *
     * @example <caption>Emit only click events whose target was a DIV element</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var clicksOnDivs = clicks.filter(ev => ev.target.tagName === 'DIV');
     * clicksOnDivs.subscribe(x => console.log(x));
     *
     * @see {@link distinct}
     * @see {@link distinctUntilChanged}
     * @see {@link distinctUntilKeyChanged}
     * @see {@link ignoreElements}
     * @see {@link partition}
     * @see {@link skip}
     *
     * @param {function(value: T, index: number): boolean} predicate A function that
     * evaluates each value emitted by the source Observable. If it returns `true`,
     * the value is emitted, if `false` the value is not passed to the output
     * Observable. The `index` parameter is the number `i` for the i-th source
     * emission that has happened since the subscription, starting from the number
     * `0`.
     * @param {any} [thisArg] An optional argument to determine the value of `this`
     * in the `predicate` function.
     * @return {Observable} An Observable of values from the source that were
     * allowed by the `predicate` function.
     * @method filter
     * @owner Observable
     */
    function filter$2(predicate, thisArg) {
        return filter_1.filter(predicate, thisArg)(this);
    }
    var filter_3 = filter$2;


    var filter_2$1 = {
    	filter: filter_3
    };

    Observable_1.Observable.prototype.filter = filter_2$1.filter;

    var __extends$1m = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };


    /**
     * Returns an Observable that mirrors the source Observable, but will call a specified function when
     * the source terminates on complete or error.
     * @param {function} callback Function to be called when source terminates.
     * @return {Observable} An Observable that mirrors the source, but will call the specified function on termination.
     * @method finally
     * @owner Observable
     */
    function finalize(callback) {
        return function (source) { return source.lift(new FinallyOperator(callback)); };
    }
    var finalize_2 = finalize;
    var FinallyOperator = (function () {
        function FinallyOperator(callback) {
            this.callback = callback;
        }
        FinallyOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(new FinallySubscriber(subscriber, this.callback));
        };
        return FinallyOperator;
    }());
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var FinallySubscriber = (function (_super) {
        __extends$1m(FinallySubscriber, _super);
        function FinallySubscriber(destination, callback) {
            _super.call(this, destination);
            this.add(new Subscription_1.Subscription(callback));
        }
        return FinallySubscriber;
    }(Subscriber_1.Subscriber));


    var finalize_1 = {
    	finalize: finalize_2
    };

    /**
     * Returns an Observable that mirrors the source Observable, but will call a specified function when
     * the source terminates on complete or error.
     * @param {function} callback Function to be called when source terminates.
     * @return {Observable} An Observable that mirrors the source, but will call the specified function on termination.
     * @method finally
     * @owner Observable
     */
    function _finally(callback) {
        return finalize_1.finalize(callback)(this);
    }
    var _finally_2 = _finally;


    var _finally_1 = {
    	_finally: _finally_2
    };

    Observable_1.Observable.prototype.finally = _finally_1._finally;
    Observable_1.Observable.prototype._finally = _finally_1._finally;

    var __extends$1n = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };

    /**
     * Emits only the first value emitted by the source Observable that meets some
     * condition.
     *
     * <span class="informal">Finds the first value that passes some test and emits
     * that.</span>
     *
     * <img src="./img/find.png" width="100%">
     *
     * `find` searches for the first item in the source Observable that matches the
     * specified condition embodied by the `predicate`, and returns the first
     * occurrence in the source. Unlike {@link first}, the `predicate` is required
     * in `find`, and does not emit an error if a valid value is not found.
     *
     * @example <caption>Find and emit the first click that happens on a DIV element</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var result = clicks.find(ev => ev.target.tagName === 'DIV');
     * result.subscribe(x => console.log(x));
     *
     * @see {@link filter}
     * @see {@link first}
     * @see {@link findIndex}
     * @see {@link take}
     *
     * @param {function(value: T, index: number, source: Observable<T>): boolean} predicate
     * A function called with each item to test for condition matching.
     * @param {any} [thisArg] An optional argument to determine the value of `this`
     * in the `predicate` function.
     * @return {Observable<T>} An Observable of the first item that matches the
     * condition.
     * @method find
     * @owner Observable
     */
    function find(predicate, thisArg) {
        if (typeof predicate !== 'function') {
            throw new TypeError('predicate is not a function');
        }
        return function (source) { return source.lift(new FindValueOperator(predicate, source, false, thisArg)); };
    }
    var find_2 = find;
    var FindValueOperator = (function () {
        function FindValueOperator(predicate, source, yieldIndex, thisArg) {
            this.predicate = predicate;
            this.source = source;
            this.yieldIndex = yieldIndex;
            this.thisArg = thisArg;
        }
        FindValueOperator.prototype.call = function (observer, source) {
            return source.subscribe(new FindValueSubscriber(observer, this.predicate, this.source, this.yieldIndex, this.thisArg));
        };
        return FindValueOperator;
    }());
    var FindValueOperator_1 = FindValueOperator;
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var FindValueSubscriber = (function (_super) {
        __extends$1n(FindValueSubscriber, _super);
        function FindValueSubscriber(destination, predicate, source, yieldIndex, thisArg) {
            _super.call(this, destination);
            this.predicate = predicate;
            this.source = source;
            this.yieldIndex = yieldIndex;
            this.thisArg = thisArg;
            this.index = 0;
        }
        FindValueSubscriber.prototype.notifyComplete = function (value) {
            var destination = this.destination;
            destination.next(value);
            destination.complete();
        };
        FindValueSubscriber.prototype._next = function (value) {
            var _a = this, predicate = _a.predicate, thisArg = _a.thisArg;
            var index = this.index++;
            try {
                var result = predicate.call(thisArg || this, value, index, this.source);
                if (result) {
                    this.notifyComplete(this.yieldIndex ? index : value);
                }
            }
            catch (err) {
                this.destination.error(err);
            }
        };
        FindValueSubscriber.prototype._complete = function () {
            this.notifyComplete(this.yieldIndex ? -1 : undefined);
        };
        return FindValueSubscriber;
    }(Subscriber_1.Subscriber));
    var FindValueSubscriber_1 = FindValueSubscriber;


    var find_1 = {
    	find: find_2,
    	FindValueOperator: FindValueOperator_1,
    	FindValueSubscriber: FindValueSubscriber_1
    };

    /* tslint:enable:max-line-length */
    /**
     * Emits only the first value emitted by the source Observable that meets some
     * condition.
     *
     * <span class="informal">Finds the first value that passes some test and emits
     * that.</span>
     *
     * <img src="./img/find.png" width="100%">
     *
     * `find` searches for the first item in the source Observable that matches the
     * specified condition embodied by the `predicate`, and returns the first
     * occurrence in the source. Unlike {@link first}, the `predicate` is required
     * in `find`, and does not emit an error if a valid value is not found.
     *
     * @example <caption>Find and emit the first click that happens on a DIV element</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var result = clicks.find(ev => ev.target.tagName === 'DIV');
     * result.subscribe(x => console.log(x));
     *
     * @see {@link filter}
     * @see {@link first}
     * @see {@link findIndex}
     * @see {@link take}
     *
     * @param {function(value: T, index: number, source: Observable<T>): boolean} predicate
     * A function called with each item to test for condition matching.
     * @param {any} [thisArg] An optional argument to determine the value of `this`
     * in the `predicate` function.
     * @return {Observable<T>} An Observable of the first item that matches the
     * condition.
     * @method find
     * @owner Observable
     */
    function find$1(predicate, thisArg) {
        return find_1.find(predicate, thisArg)(this);
    }
    var find_3 = find$1;


    var find_2$1 = {
    	find: find_3
    };

    Observable_1.Observable.prototype.find = find_2$1.find;

    /**
     * Emits only the index of the first value emitted by the source Observable that
     * meets some condition.
     *
     * <span class="informal">It's like {@link find}, but emits the index of the
     * found value, not the value itself.</span>
     *
     * <img src="./img/findIndex.png" width="100%">
     *
     * `findIndex` searches for the first item in the source Observable that matches
     * the specified condition embodied by the `predicate`, and returns the
     * (zero-based) index of the first occurrence in the source. Unlike
     * {@link first}, the `predicate` is required in `findIndex`, and does not emit
     * an error if a valid value is not found.
     *
     * @example <caption>Emit the index of first click that happens on a DIV element</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var result = clicks.findIndex(ev => ev.target.tagName === 'DIV');
     * result.subscribe(x => console.log(x));
     *
     * @see {@link filter}
     * @see {@link find}
     * @see {@link first}
     * @see {@link take}
     *
     * @param {function(value: T, index: number, source: Observable<T>): boolean} predicate
     * A function called with each item to test for condition matching.
     * @param {any} [thisArg] An optional argument to determine the value of `this`
     * in the `predicate` function.
     * @return {Observable} An Observable of the index of the first item that
     * matches the condition.
     * @method find
     * @owner Observable
     */
    function findIndex(predicate, thisArg) {
        return function (source) { return source.lift(new find_1.FindValueOperator(predicate, source, true, thisArg)); };
    }
    var findIndex_2 = findIndex;


    var findIndex_1 = {
    	findIndex: findIndex_2
    };

    /**
     * Emits only the index of the first value emitted by the source Observable that
     * meets some condition.
     *
     * <span class="informal">It's like {@link find}, but emits the index of the
     * found value, not the value itself.</span>
     *
     * <img src="./img/findIndex.png" width="100%">
     *
     * `findIndex` searches for the first item in the source Observable that matches
     * the specified condition embodied by the `predicate`, and returns the
     * (zero-based) index of the first occurrence in the source. Unlike
     * {@link first}, the `predicate` is required in `findIndex`, and does not emit
     * an error if a valid value is not found.
     *
     * @example <caption>Emit the index of first click that happens on a DIV element</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var result = clicks.findIndex(ev => ev.target.tagName === 'DIV');
     * result.subscribe(x => console.log(x));
     *
     * @see {@link filter}
     * @see {@link find}
     * @see {@link first}
     * @see {@link take}
     *
     * @param {function(value: T, index: number, source: Observable<T>): boolean} predicate
     * A function called with each item to test for condition matching.
     * @param {any} [thisArg] An optional argument to determine the value of `this`
     * in the `predicate` function.
     * @return {Observable} An Observable of the index of the first item that
     * matches the condition.
     * @method find
     * @owner Observable
     */
    function findIndex$1(predicate, thisArg) {
        return findIndex_1.findIndex(predicate, thisArg)(this);
    }
    var findIndex_3 = findIndex$1;


    var findIndex_2$1 = {
    	findIndex: findIndex_3
    };

    Observable_1.Observable.prototype.findIndex = findIndex_2$1.findIndex;

    var __extends$1o = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    /**
     * An error thrown when an Observable or a sequence was queried but has no
     * elements.
     *
     * @see {@link first}
     * @see {@link last}
     * @see {@link single}
     *
     * @class EmptyError
     */
    var EmptyError = (function (_super) {
        __extends$1o(EmptyError, _super);
        function EmptyError() {
            var err = _super.call(this, 'no elements in sequence');
            this.name = err.name = 'EmptyError';
            this.stack = err.stack;
            this.message = err.message;
        }
        return EmptyError;
    }(Error));
    var EmptyError_2 = EmptyError;


    var EmptyError_1 = {
    	EmptyError: EmptyError_2
    };

    var __extends$1p = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };


    /**
     * Emits only the first value (or the first value that meets some condition)
     * emitted by the source Observable.
     *
     * <span class="informal">Emits only the first value. Or emits only the first
     * value that passes some test.</span>
     *
     * <img src="./img/first.png" width="100%">
     *
     * If called with no arguments, `first` emits the first value of the source
     * Observable, then completes. If called with a `predicate` function, `first`
     * emits the first value of the source that matches the specified condition. It
     * may also take a `resultSelector` function to produce the output value from
     * the input value, and a `defaultValue` to emit in case the source completes
     * before it is able to emit a valid value. Throws an error if `defaultValue`
     * was not provided and a matching element is not found.
     *
     * @example <caption>Emit only the first click that happens on the DOM</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var result = clicks.first();
     * result.subscribe(x => console.log(x));
     *
     * @example <caption>Emits the first click that happens on a DIV</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var result = clicks.first(ev => ev.target.tagName === 'DIV');
     * result.subscribe(x => console.log(x));
     *
     * @see {@link filter}
     * @see {@link find}
     * @see {@link take}
     *
     * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`
     * callback if the Observable completes before any `next` notification was sent.
     *
     * @param {function(value: T, index: number, source: Observable<T>): boolean} [predicate]
     * An optional function called with each item to test for condition matching.
     * @param {function(value: T, index: number): R} [resultSelector] A function to
     * produce the value on the output Observable based on the values
     * and the indices of the source Observable. The arguments passed to this
     * function are:
     * - `value`: the value that was emitted on the source.
     * - `index`: the "index" of the value from the source.
     * @param {R} [defaultValue] The default value emitted in case no valid value
     * was found on the source.
     * @return {Observable<T|R>} An Observable of the first item that matches the
     * condition.
     * @method first
     * @owner Observable
     */
    function first(predicate, resultSelector, defaultValue) {
        return function (source) { return source.lift(new FirstOperator(predicate, resultSelector, defaultValue, source)); };
    }
    var first_2 = first;
    var FirstOperator = (function () {
        function FirstOperator(predicate, resultSelector, defaultValue, source) {
            this.predicate = predicate;
            this.resultSelector = resultSelector;
            this.defaultValue = defaultValue;
            this.source = source;
        }
        FirstOperator.prototype.call = function (observer, source) {
            return source.subscribe(new FirstSubscriber(observer, this.predicate, this.resultSelector, this.defaultValue, this.source));
        };
        return FirstOperator;
    }());
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var FirstSubscriber = (function (_super) {
        __extends$1p(FirstSubscriber, _super);
        function FirstSubscriber(destination, predicate, resultSelector, defaultValue, source) {
            _super.call(this, destination);
            this.predicate = predicate;
            this.resultSelector = resultSelector;
            this.defaultValue = defaultValue;
            this.source = source;
            this.index = 0;
            this.hasCompleted = false;
            this._emitted = false;
        }
        FirstSubscriber.prototype._next = function (value) {
            var index = this.index++;
            if (this.predicate) {
                this._tryPredicate(value, index);
            }
            else {
                this._emit(value, index);
            }
        };
        FirstSubscriber.prototype._tryPredicate = function (value, index) {
            var result;
            try {
                result = this.predicate(value, index, this.source);
            }
            catch (err) {
                this.destination.error(err);
                return;
            }
            if (result) {
                this._emit(value, index);
            }
        };
        FirstSubscriber.prototype._emit = function (value, index) {
            if (this.resultSelector) {
                this._tryResultSelector(value, index);
                return;
            }
            this._emitFinal(value);
        };
        FirstSubscriber.prototype._tryResultSelector = function (value, index) {
            var result;
            try {
                result = this.resultSelector(value, index);
            }
            catch (err) {
                this.destination.error(err);
                return;
            }
            this._emitFinal(result);
        };
        FirstSubscriber.prototype._emitFinal = function (value) {
            var destination = this.destination;
            if (!this._emitted) {
                this._emitted = true;
                destination.next(value);
                destination.complete();
                this.hasCompleted = true;
            }
        };
        FirstSubscriber.prototype._complete = function () {
            var destination = this.destination;
            if (!this.hasCompleted && typeof this.defaultValue !== 'undefined') {
                destination.next(this.defaultValue);
                destination.complete();
            }
            else if (!this.hasCompleted) {
                destination.error(new EmptyError_1.EmptyError);
            }
        };
        return FirstSubscriber;
    }(Subscriber_1.Subscriber));


    var first_1 = {
    	first: first_2
    };

    /**
     * Emits only the first value (or the first value that meets some condition)
     * emitted by the source Observable.
     *
     * <span class="informal">Emits only the first value. Or emits only the first
     * value that passes some test.</span>
     *
     * <img src="./img/first.png" width="100%">
     *
     * If called with no arguments, `first` emits the first value of the source
     * Observable, then completes. If called with a `predicate` function, `first`
     * emits the first value of the source that matches the specified condition. It
     * may also take a `resultSelector` function to produce the output value from
     * the input value, and a `defaultValue` to emit in case the source completes
     * before it is able to emit a valid value. Throws an error if `defaultValue`
     * was not provided and a matching element is not found.
     *
     * @example <caption>Emit only the first click that happens on the DOM</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var result = clicks.first();
     * result.subscribe(x => console.log(x));
     *
     * @example <caption>Emits the first click that happens on a DIV</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var result = clicks.first(ev => ev.target.tagName === 'DIV');
     * result.subscribe(x => console.log(x));
     *
     * @see {@link filter}
     * @see {@link find}
     * @see {@link take}
     *
     * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`
     * callback if the Observable completes before any `next` notification was sent.
     *
     * @param {function(value: T, index: number, source: Observable<T>): boolean} [predicate]
     * An optional function called with each item to test for condition matching.
     * @param {function(value: T, index: number): R} [resultSelector] A function to
     * produce the value on the output Observable based on the values
     * and the indices of the source Observable. The arguments passed to this
     * function are:
     * - `value`: the value that was emitted on the source.
     * - `index`: the "index" of the value from the source.
     * @param {R} [defaultValue] The default value emitted in case no valid value
     * was found on the source.
     * @return {Observable<T|R>} An Observable of the first item that matches the
     * condition.
     * @method first
     * @owner Observable
     */
    function first$1(predicate, resultSelector, defaultValue) {
        return first_1.first(predicate, resultSelector, defaultValue)(this);
    }
    var first_3 = first$1;


    var first_2$1 = {
    	first: first_3
    };

    Observable_1.Observable.prototype.first = first_2$1.first;

    var MapPolyfill = (function () {
        function MapPolyfill() {
            this.size = 0;
            this._values = [];
            this._keys = [];
        }
        MapPolyfill.prototype.get = function (key) {
            var i = this._keys.indexOf(key);
            return i === -1 ? undefined : this._values[i];
        };
        MapPolyfill.prototype.set = function (key, value) {
            var i = this._keys.indexOf(key);
            if (i === -1) {
                this._keys.push(key);
                this._values.push(value);
                this.size++;
            }
            else {
                this._values[i] = value;
            }
            return this;
        };
        MapPolyfill.prototype.delete = function (key) {
            var i = this._keys.indexOf(key);
            if (i === -1) {
                return false;
            }
            this._values.splice(i, 1);
            this._keys.splice(i, 1);
            this.size--;
            return true;
        };
        MapPolyfill.prototype.clear = function () {
            this._keys.length = 0;
            this._values.length = 0;
            this.size = 0;
        };
        MapPolyfill.prototype.forEach = function (cb, thisArg) {
            for (var i = 0; i < this.size; i++) {
                cb.call(thisArg, this._values[i], this._keys[i]);
            }
        };
        return MapPolyfill;
    }());
    var MapPolyfill_2 = MapPolyfill;


    var MapPolyfill_1 = {
    	MapPolyfill: MapPolyfill_2
    };

    var Map = root.root.Map || (function () { return MapPolyfill_1.MapPolyfill; })();


    var _Map = {
    	Map: Map
    };

    var FastMap = (function () {
        function FastMap() {
            this.values = {};
        }
        FastMap.prototype.delete = function (key) {
            this.values[key] = null;
            return true;
        };
        FastMap.prototype.set = function (key, value) {
            this.values[key] = value;
            return this;
        };
        FastMap.prototype.get = function (key) {
            return this.values[key];
        };
        FastMap.prototype.forEach = function (cb, thisArg) {
            var values = this.values;
            for (var key in values) {
                if (values.hasOwnProperty(key) && values[key] !== null) {
                    cb.call(thisArg, values[key], key);
                }
            }
        };
        FastMap.prototype.clear = function () {
            this.values = {};
        };
        return FastMap;
    }());
    var FastMap_2 = FastMap;


    var FastMap_1 = {
    	FastMap: FastMap_2
    };

    var __extends$1q = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };






    /* tslint:enable:max-line-length */
    /**
     * Groups the items emitted by an Observable according to a specified criterion,
     * and emits these grouped items as `GroupedObservables`, one
     * {@link GroupedObservable} per group.
     *
     * <img src="./img/groupBy.png" width="100%">
     *
     * @example <caption>Group objects by id and return as array</caption>
     * Observable.of<Obj>({id: 1, name: 'aze1'},
     *                    {id: 2, name: 'sf2'},
     *                    {id: 2, name: 'dg2'},
     *                    {id: 1, name: 'erg1'},
     *                    {id: 1, name: 'df1'},
     *                    {id: 2, name: 'sfqfb2'},
     *                    {id: 3, name: 'qfs3'},
     *                    {id: 2, name: 'qsgqsfg2'}
     *     )
     *     .groupBy(p => p.id)
     *     .flatMap( (group$) => group$.reduce((acc, cur) => [...acc, cur], []))
     *     .subscribe(p => console.log(p));
     *
     * // displays:
     * // [ { id: 1, name: 'aze1' },
     * //   { id: 1, name: 'erg1' },
     * //   { id: 1, name: 'df1' } ]
     * //
     * // [ { id: 2, name: 'sf2' },
     * //   { id: 2, name: 'dg2' },
     * //   { id: 2, name: 'sfqfb2' },
     * //   { id: 2, name: 'qsgqsfg2' } ]
     * //
     * // [ { id: 3, name: 'qfs3' } ]
     *
     * @example <caption>Pivot data on the id field</caption>
     * Observable.of<Obj>({id: 1, name: 'aze1'},
     *                    {id: 2, name: 'sf2'},
     *                    {id: 2, name: 'dg2'},
     *                    {id: 1, name: 'erg1'},
     *                    {id: 1, name: 'df1'},
     *                    {id: 2, name: 'sfqfb2'},
     *                    {id: 3, name: 'qfs1'},
     *                    {id: 2, name: 'qsgqsfg2'}
     *                   )
     *     .groupBy(p => p.id, p => p.name)
     *     .flatMap( (group$) => group$.reduce((acc, cur) => [...acc, cur], ["" + group$.key]))
     *     .map(arr => ({'id': parseInt(arr[0]), 'values': arr.slice(1)}))
     *     .subscribe(p => console.log(p));
     *
     * // displays:
     * // { id: 1, values: [ 'aze1', 'erg1', 'df1' ] }
     * // { id: 2, values: [ 'sf2', 'dg2', 'sfqfb2', 'qsgqsfg2' ] }
     * // { id: 3, values: [ 'qfs1' ] }
     *
     * @param {function(value: T): K} keySelector A function that extracts the key
     * for each item.
     * @param {function(value: T): R} [elementSelector] A function that extracts the
     * return element for each item.
     * @param {function(grouped: GroupedObservable<K,R>): Observable<any>} [durationSelector]
     * A function that returns an Observable to determine how long each group should
     * exist.
     * @return {Observable<GroupedObservable<K,R>>} An Observable that emits
     * GroupedObservables, each of which corresponds to a unique key value and each
     * of which emits those items from the source Observable that share that key
     * value.
     * @method groupBy
     * @owner Observable
     */
    function groupBy(keySelector, elementSelector, durationSelector, subjectSelector) {
        return function (source) {
            return source.lift(new GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector));
        };
    }
    var groupBy_2 = groupBy;
    var GroupByOperator = (function () {
        function GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector) {
            this.keySelector = keySelector;
            this.elementSelector = elementSelector;
            this.durationSelector = durationSelector;
            this.subjectSelector = subjectSelector;
        }
        GroupByOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(new GroupBySubscriber(subscriber, this.keySelector, this.elementSelector, this.durationSelector, this.subjectSelector));
        };
        return GroupByOperator;
    }());
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var GroupBySubscriber = (function (_super) {
        __extends$1q(GroupBySubscriber, _super);
        function GroupBySubscriber(destination, keySelector, elementSelector, durationSelector, subjectSelector) {
            _super.call(this, destination);
            this.keySelector = keySelector;
            this.elementSelector = elementSelector;
            this.durationSelector = durationSelector;
            this.subjectSelector = subjectSelector;
            this.groups = null;
            this.attemptedToUnsubscribe = false;
            this.count = 0;
        }
        GroupBySubscriber.prototype._next = function (value) {
            var key;
            try {
                key = this.keySelector(value);
            }
            catch (err) {
                this.error(err);
                return;
            }
            this._group(value, key);
        };
        GroupBySubscriber.prototype._group = function (value, key) {
            var groups = this.groups;
            if (!groups) {
                groups = this.groups = typeof key === 'string' ? new FastMap_1.FastMap() : new _Map.Map();
            }
            var group = groups.get(key);
            var element;
            if (this.elementSelector) {
                try {
                    element = this.elementSelector(value);
                }
                catch (err) {
                    this.error(err);
                }
            }
            else {
                element = value;
            }
            if (!group) {
                group = this.subjectSelector ? this.subjectSelector() : new Subject_1.Subject();
                groups.set(key, group);
                var groupedObservable = new GroupedObservable(key, group, this);
                this.destination.next(groupedObservable);
                if (this.durationSelector) {
                    var duration = void 0;
                    try {
                        duration = this.durationSelector(new GroupedObservable(key, group));
                    }
                    catch (err) {
                        this.error(err);
                        return;
                    }
                    this.add(duration.subscribe(new GroupDurationSubscriber(key, group, this)));
                }
            }
            if (!group.closed) {
                group.next(element);
            }
        };
        GroupBySubscriber.prototype._error = function (err) {
            var groups = this.groups;
            if (groups) {
                groups.forEach(function (group, key) {
                    group.error(err);
                });
                groups.clear();
            }
            this.destination.error(err);
        };
        GroupBySubscriber.prototype._complete = function () {
            var groups = this.groups;
            if (groups) {
                groups.forEach(function (group, key) {
                    group.complete();
                });
                groups.clear();
            }
            this.destination.complete();
        };
        GroupBySubscriber.prototype.removeGroup = function (key) {
            this.groups.delete(key);
        };
        GroupBySubscriber.prototype.unsubscribe = function () {
            if (!this.closed) {
                this.attemptedToUnsubscribe = true;
                if (this.count === 0) {
                    _super.prototype.unsubscribe.call(this);
                }
            }
        };
        return GroupBySubscriber;
    }(Subscriber_1.Subscriber));
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var GroupDurationSubscriber = (function (_super) {
        __extends$1q(GroupDurationSubscriber, _super);
        function GroupDurationSubscriber(key, group, parent) {
            _super.call(this, group);
            this.key = key;
            this.group = group;
            this.parent = parent;
        }
        GroupDurationSubscriber.prototype._next = function (value) {
            this.complete();
        };
        /** @deprecated internal use only */ GroupDurationSubscriber.prototype._unsubscribe = function () {
            var _a = this, parent = _a.parent, key = _a.key;
            this.key = this.parent = null;
            if (parent) {
                parent.removeGroup(key);
            }
        };
        return GroupDurationSubscriber;
    }(Subscriber_1.Subscriber));
    /**
     * An Observable representing values belonging to the same group represented by
     * a common key. The values emitted by a GroupedObservable come from the source
     * Observable. The common key is available as the field `key` on a
     * GroupedObservable instance.
     *
     * @class GroupedObservable<K, T>
     */
    var GroupedObservable = (function (_super) {
        __extends$1q(GroupedObservable, _super);
        function GroupedObservable(key, groupSubject, refCountSubscription) {
            _super.call(this);
            this.key = key;
            this.groupSubject = groupSubject;
            this.refCountSubscription = refCountSubscription;
        }
        /** @deprecated internal use only */ GroupedObservable.prototype._subscribe = function (subscriber) {
            var subscription = new Subscription_1.Subscription();
            var _a = this, refCountSubscription = _a.refCountSubscription, groupSubject = _a.groupSubject;
            if (refCountSubscription && !refCountSubscription.closed) {
                subscription.add(new InnerRefCountSubscription(refCountSubscription));
            }
            subscription.add(groupSubject.subscribe(subscriber));
            return subscription;
        };
        return GroupedObservable;
    }(Observable_1.Observable));
    var GroupedObservable_1 = GroupedObservable;
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var InnerRefCountSubscription = (function (_super) {
        __extends$1q(InnerRefCountSubscription, _super);
        function InnerRefCountSubscription(parent) {
            _super.call(this);
            this.parent = parent;
            parent.count++;
        }
        InnerRefCountSubscription.prototype.unsubscribe = function () {
            var parent = this.parent;
            if (!parent.closed && !this.closed) {
                _super.prototype.unsubscribe.call(this);
                parent.count -= 1;
                if (parent.count === 0 && parent.attemptedToUnsubscribe) {
                    parent.unsubscribe();
                }
            }
        };
        return InnerRefCountSubscription;
    }(Subscription_1.Subscription));


    var groupBy_1 = {
    	groupBy: groupBy_2,
    	GroupedObservable: GroupedObservable_1
    };

    var GroupedObservable$1 = groupBy_1.GroupedObservable;
    /* tslint:enable:max-line-length */
    /**
     * Groups the items emitted by an Observable according to a specified criterion,
     * and emits these grouped items as `GroupedObservables`, one
     * {@link GroupedObservable} per group.
     *
     * <img src="./img/groupBy.png" width="100%">
     *
     * @example <caption>Group objects by id and return as array</caption>
     * Observable.of<Obj>({id: 1, name: 'aze1'},
     *                    {id: 2, name: 'sf2'},
     *                    {id: 2, name: 'dg2'},
     *                    {id: 1, name: 'erg1'},
     *                    {id: 1, name: 'df1'},
     *                    {id: 2, name: 'sfqfb2'},
     *                    {id: 3, name: 'qfs3'},
     *                    {id: 2, name: 'qsgqsfg2'}
     *     )
     *     .groupBy(p => p.id)
     *     .flatMap( (group$) => group$.reduce((acc, cur) => [...acc, cur], []))
     *     .subscribe(p => console.log(p));
     *
     * // displays:
     * // [ { id: 1, name: 'aze1' },
     * //   { id: 1, name: 'erg1' },
     * //   { id: 1, name: 'df1' } ]
     * //
     * // [ { id: 2, name: 'sf2' },
     * //   { id: 2, name: 'dg2' },
     * //   { id: 2, name: 'sfqfb2' },
     * //   { id: 2, name: 'qsgqsfg2' } ]
     * //
     * // [ { id: 3, name: 'qfs3' } ]
     *
     * @example <caption>Pivot data on the id field</caption>
     * Observable.of<Obj>({id: 1, name: 'aze1'},
     *                    {id: 2, name: 'sf2'},
     *                    {id: 2, name: 'dg2'},
     *                    {id: 1, name: 'erg1'},
     *                    {id: 1, name: 'df1'},
     *                    {id: 2, name: 'sfqfb2'},
     *                    {id: 3, name: 'qfs1'},
     *                    {id: 2, name: 'qsgqsfg2'}
     *                   )
     *     .groupBy(p => p.id, p => p.name)
     *     .flatMap( (group$) => group$.reduce((acc, cur) => [...acc, cur], ["" + group$.key]))
     *     .map(arr => ({'id': parseInt(arr[0]), 'values': arr.slice(1)}))
     *     .subscribe(p => console.log(p));
     *
     * // displays:
     * // { id: 1, values: [ 'aze1', 'erg1', 'df1' ] }
     * // { id: 2, values: [ 'sf2', 'dg2', 'sfqfb2', 'qsgqsfg2' ] }
     * // { id: 3, values: [ 'qfs1' ] }
     *
     * @param {function(value: T): K} keySelector A function that extracts the key
     * for each item.
     * @param {function(value: T): R} [elementSelector] A function that extracts the
     * return element for each item.
     * @param {function(grouped: GroupedObservable<K,R>): Observable<any>} [durationSelector]
     * A function that returns an Observable to determine how long each group should
     * exist.
     * @return {Observable<GroupedObservable<K,R>>} An Observable that emits
     * GroupedObservables, each of which corresponds to a unique key value and each
     * of which emits those items from the source Observable that share that key
     * value.
     * @method groupBy
     * @owner Observable
     */
    function groupBy$1(keySelector, elementSelector, durationSelector, subjectSelector) {
        return groupBy_1.groupBy(keySelector, elementSelector, durationSelector, subjectSelector)(this);
    }
    var groupBy_3 = groupBy$1;


    var groupBy_2$1 = {
    	GroupedObservable: GroupedObservable$1,
    	groupBy: groupBy_3
    };

    Observable_1.Observable.prototype.groupBy = groupBy_2$1.groupBy;

    var __extends$1r = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };


    /**
     * Ignores all items emitted by the source Observable and only passes calls of `complete` or `error`.
     *
     * <img src="./img/ignoreElements.png" width="100%">
     *
     * @return {Observable} An empty Observable that only calls `complete`
     * or `error`, based on which one is called by the source Observable.
     * @method ignoreElements
     * @owner Observable
     */
    function ignoreElements() {
        return function ignoreElementsOperatorFunction(source) {
            return source.lift(new IgnoreElementsOperator());
        };
    }
    var ignoreElements_2 = ignoreElements;
    var IgnoreElementsOperator = (function () {
        function IgnoreElementsOperator() {
        }
        IgnoreElementsOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(new IgnoreElementsSubscriber(subscriber));
        };
        return IgnoreElementsOperator;
    }());
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var IgnoreElementsSubscriber = (function (_super) {
        __extends$1r(IgnoreElementsSubscriber, _super);
        function IgnoreElementsSubscriber() {
            _super.apply(this, arguments);
        }
        IgnoreElementsSubscriber.prototype._next = function (unused) {
        };
        return IgnoreElementsSubscriber;
    }(Subscriber_1.Subscriber));


    var ignoreElements_1 = {
    	ignoreElements: ignoreElements_2
    };

    /**
     * Ignores all items emitted by the source Observable and only passes calls of `complete` or `error`.
     *
     * <img src="./img/ignoreElements.png" width="100%">
     *
     * @return {Observable} An empty Observable that only calls `complete`
     * or `error`, based on which one is called by the source Observable.
     * @method ignoreElements
     * @owner Observable
     */
    function ignoreElements$1() {
        return ignoreElements_1.ignoreElements()(this);
    }
    var ignoreElements_3 = ignoreElements$1;


    var ignoreElements_2$1 = {
    	ignoreElements: ignoreElements_3
    };

    Observable_1.Observable.prototype.ignoreElements = ignoreElements_2$1.ignoreElements;

    var __extends$1s = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };

    function isEmpty() {
        return function (source) { return source.lift(new IsEmptyOperator()); };
    }
    var isEmpty_2 = isEmpty;
    var IsEmptyOperator = (function () {
        function IsEmptyOperator() {
        }
        IsEmptyOperator.prototype.call = function (observer, source) {
            return source.subscribe(new IsEmptySubscriber(observer));
        };
        return IsEmptyOperator;
    }());
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var IsEmptySubscriber = (function (_super) {
        __extends$1s(IsEmptySubscriber, _super);
        function IsEmptySubscriber(destination) {
            _super.call(this, destination);
        }
        IsEmptySubscriber.prototype.notifyComplete = function (isEmpty) {
            var destination = this.destination;
            destination.next(isEmpty);
            destination.complete();
        };
        IsEmptySubscriber.prototype._next = function (value) {
            this.notifyComplete(false);
        };
        IsEmptySubscriber.prototype._complete = function () {
            this.notifyComplete(true);
        };
        return IsEmptySubscriber;
    }(Subscriber_1.Subscriber));


    var isEmpty_1 = {
    	isEmpty: isEmpty_2
    };

    /**
     * If the source Observable is empty it returns an Observable that emits true, otherwise it emits false.
     *
     * <img src="./img/isEmpty.png" width="100%">
     *
     * @return {Observable} An Observable that emits a Boolean.
     * @method isEmpty
     * @owner Observable
     */
    function isEmpty$1() {
        return isEmpty_1.isEmpty()(this);
    }
    var isEmpty_3 = isEmpty$1;


    var isEmpty_2$1 = {
    	isEmpty: isEmpty_3
    };

    Observable_1.Observable.prototype.isEmpty = isEmpty_2$1.isEmpty;

    var __extends$1t = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };




    /**
     * Ignores source values for a duration determined by another Observable, then
     * emits the most recent value from the source Observable, then repeats this
     * process.
     *
     * <span class="informal">It's like {@link auditTime}, but the silencing
     * duration is determined by a second Observable.</span>
     *
     * <img src="./img/audit.png" width="100%">
     *
     * `audit` is similar to `throttle`, but emits the last value from the silenced
     * time window, instead of the first value. `audit` emits the most recent value
     * from the source Observable on the output Observable as soon as its internal
     * timer becomes disabled, and ignores source values while the timer is enabled.
     * Initially, the timer is disabled. As soon as the first source value arrives,
     * the timer is enabled by calling the `durationSelector` function with the
     * source value, which returns the "duration" Observable. When the duration
     * Observable emits a value or completes, the timer is disabled, then the most
     * recent source value is emitted on the output Observable, and this process
     * repeats for the next source value.
     *
     * @example <caption>Emit clicks at a rate of at most one click per second</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var result = clicks.audit(ev => Rx.Observable.interval(1000));
     * result.subscribe(x => console.log(x));
     *
     * @see {@link auditTime}
     * @see {@link debounce}
     * @see {@link delayWhen}
     * @see {@link sample}
     * @see {@link throttle}
     *
     * @param {function(value: T): SubscribableOrPromise} durationSelector A function
     * that receives a value from the source Observable, for computing the silencing
     * duration, returned as an Observable or a Promise.
     * @return {Observable<T>} An Observable that performs rate-limiting of
     * emissions from the source Observable.
     * @method audit
     * @owner Observable
     */
    function audit(durationSelector) {
        return function auditOperatorFunction(source) {
            return source.lift(new AuditOperator(durationSelector));
        };
    }
    var audit_2 = audit;
    var AuditOperator = (function () {
        function AuditOperator(durationSelector) {
            this.durationSelector = durationSelector;
        }
        AuditOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(new AuditSubscriber(subscriber, this.durationSelector));
        };
        return AuditOperator;
    }());
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var AuditSubscriber = (function (_super) {
        __extends$1t(AuditSubscriber, _super);
        function AuditSubscriber(destination, durationSelector) {
            _super.call(this, destination);
            this.durationSelector = durationSelector;
            this.hasValue = false;
        }
        AuditSubscriber.prototype._next = function (value) {
            this.value = value;
            this.hasValue = true;
            if (!this.throttled) {
                var duration = tryCatch_1.tryCatch(this.durationSelector)(value);
                if (duration === errorObject.errorObject) {
                    this.destination.error(errorObject.errorObject.e);
                }
                else {
                    var innerSubscription = subscribeToResult_1.subscribeToResult(this, duration);
                    if (innerSubscription.closed) {
                        this.clearThrottle();
                    }
                    else {
                        this.add(this.throttled = innerSubscription);
                    }
                }
            }
        };
        AuditSubscriber.prototype.clearThrottle = function () {
            var _a = this, value = _a.value, hasValue = _a.hasValue, throttled = _a.throttled;
            if (throttled) {
                this.remove(throttled);
                this.throttled = null;
                throttled.unsubscribe();
            }
            if (hasValue) {
                this.value = null;
                this.hasValue = false;
                this.destination.next(value);
            }
        };
        AuditSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex) {
            this.clearThrottle();
        };
        AuditSubscriber.prototype.notifyComplete = function () {
            this.clearThrottle();
        };
        return AuditSubscriber;
    }(OuterSubscriber_1.OuterSubscriber));


    var audit_1 = {
    	audit: audit_2
    };

    /**
     * Ignores source values for a duration determined by another Observable, then
     * emits the most recent value from the source Observable, then repeats this
     * process.
     *
     * <span class="informal">It's like {@link auditTime}, but the silencing
     * duration is determined by a second Observable.</span>
     *
     * <img src="./img/audit.png" width="100%">
     *
     * `audit` is similar to `throttle`, but emits the last value from the silenced
     * time window, instead of the first value. `audit` emits the most recent value
     * from the source Observable on the output Observable as soon as its internal
     * timer becomes disabled, and ignores source values while the timer is enabled.
     * Initially, the timer is disabled. As soon as the first source value arrives,
     * the timer is enabled by calling the `durationSelector` function with the
     * source value, which returns the "duration" Observable. When the duration
     * Observable emits a value or completes, the timer is disabled, then the most
     * recent source value is emitted on the output Observable, and this process
     * repeats for the next source value.
     *
     * @example <caption>Emit clicks at a rate of at most one click per second</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var result = clicks.audit(ev => Rx.Observable.interval(1000));
     * result.subscribe(x => console.log(x));
     *
     * @see {@link auditTime}
     * @see {@link debounce}
     * @see {@link delayWhen}
     * @see {@link sample}
     * @see {@link throttle}
     *
     * @param {function(value: T): SubscribableOrPromise} durationSelector A function
     * that receives a value from the source Observable, for computing the silencing
     * duration, returned as an Observable or a Promise.
     * @return {Observable<T>} An Observable that performs rate-limiting of
     * emissions from the source Observable.
     * @method audit
     * @owner Observable
     */
    function audit$1(durationSelector) {
        return audit_1.audit(durationSelector)(this);
    }
    var audit_3 = audit$1;


    var audit_2$1 = {
    	audit: audit_3
    };

    Observable_1.Observable.prototype.audit = audit_2$1.audit;

    /**
     * Ignores source values for `duration` milliseconds, then emits the most recent
     * value from the source Observable, then repeats this process.
     *
     * <span class="informal">When it sees a source values, it ignores that plus
     * the next ones for `duration` milliseconds, and then it emits the most recent
     * value from the source.</span>
     *
     * <img src="./img/auditTime.png" width="100%">
     *
     * `auditTime` is similar to `throttleTime`, but emits the last value from the
     * silenced time window, instead of the first value. `auditTime` emits the most
     * recent value from the source Observable on the output Observable as soon as
     * its internal timer becomes disabled, and ignores source values while the
     * timer is enabled. Initially, the timer is disabled. As soon as the first
     * source value arrives, the timer is enabled. After `duration` milliseconds (or
     * the time unit determined internally by the optional `scheduler`) has passed,
     * the timer is disabled, then the most recent source value is emitted on the
     * output Observable, and this process repeats for the next source value.
     * Optionally takes a {@link IScheduler} for managing timers.
     *
     * @example <caption>Emit clicks at a rate of at most one click per second</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var result = clicks.auditTime(1000);
     * result.subscribe(x => console.log(x));
     *
     * @see {@link audit}
     * @see {@link debounceTime}
     * @see {@link delay}
     * @see {@link sampleTime}
     * @see {@link throttleTime}
     *
     * @param {number} duration Time to wait before emitting the most recent source
     * value, measured in milliseconds or the time unit determined internally
     * by the optional `scheduler`.
     * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for
     * managing the timers that handle the rate-limiting behavior.
     * @return {Observable<T>} An Observable that performs rate-limiting of
     * emissions from the source Observable.
     * @method auditTime
     * @owner Observable
     */
    function auditTime(duration, scheduler) {
        if (scheduler === void 0) { scheduler = async.async; }
        return audit_1.audit(function () { return timer$1.timer(duration, scheduler); });
    }
    var auditTime_2 = auditTime;


    var auditTime_1 = {
    	auditTime: auditTime_2
    };

    /**
     * Ignores source values for `duration` milliseconds, then emits the most recent
     * value from the source Observable, then repeats this process.
     *
     * <span class="informal">When it sees a source values, it ignores that plus
     * the next ones for `duration` milliseconds, and then it emits the most recent
     * value from the source.</span>
     *
     * <img src="./img/auditTime.png" width="100%">
     *
     * `auditTime` is similar to `throttleTime`, but emits the last value from the
     * silenced time window, instead of the first value. `auditTime` emits the most
     * recent value from the source Observable on the output Observable as soon as
     * its internal timer becomes disabled, and ignores source values while the
     * timer is enabled. Initially, the timer is disabled. As soon as the first
     * source value arrives, the timer is enabled. After `duration` milliseconds (or
     * the time unit determined internally by the optional `scheduler`) has passed,
     * the timer is disabled, then the most recent source value is emitted on the
     * output Observable, and this process repeats for the next source value.
     * Optionally takes a {@link IScheduler} for managing timers.
     *
     * @example <caption>Emit clicks at a rate of at most one click per second</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var result = clicks.auditTime(1000);
     * result.subscribe(x => console.log(x));
     *
     * @see {@link audit}
     * @see {@link debounceTime}
     * @see {@link delay}
     * @see {@link sampleTime}
     * @see {@link throttleTime}
     *
     * @param {number} duration Time to wait before emitting the most recent source
     * value, measured in milliseconds or the time unit determined internally
     * by the optional `scheduler`.
     * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for
     * managing the timers that handle the rate-limiting behavior.
     * @return {Observable<T>} An Observable that performs rate-limiting of
     * emissions from the source Observable.
     * @method auditTime
     * @owner Observable
     */
    function auditTime$1(duration, scheduler) {
        if (scheduler === void 0) { scheduler = async.async; }
        return auditTime_1.auditTime(duration, scheduler)(this);
    }
    var auditTime_3 = auditTime$1;


    var auditTime_2$1 = {
    	auditTime: auditTime_3
    };

    Observable_1.Observable.prototype.auditTime = auditTime_2$1.auditTime;

    var __extends$1u = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };


    /* tslint:enable:max-line-length */
    /**
     * Returns an Observable that emits only the last item emitted by the source Observable.
     * It optionally takes a predicate function as a parameter, in which case, rather than emitting
     * the last item from the source Observable, the resulting Observable will emit the last item
     * from the source Observable that satisfies the predicate.
     *
     * <img src="./img/last.png" width="100%">
     *
     * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`
     * callback if the Observable completes before any `next` notification was sent.
     * @param {function} predicate - The condition any source emitted item has to satisfy.
     * @return {Observable} An Observable that emits only the last item satisfying the given condition
     * from the source, or an NoSuchElementException if no such items are emitted.
     * @throws - Throws if no items that match the predicate are emitted by the source Observable.
     * @method last
     * @owner Observable
     */
    function last(predicate, resultSelector, defaultValue) {
        return function (source) { return source.lift(new LastOperator(predicate, resultSelector, defaultValue, source)); };
    }
    var last_2 = last;
    var LastOperator = (function () {
        function LastOperator(predicate, resultSelector, defaultValue, source) {
            this.predicate = predicate;
            this.resultSelector = resultSelector;
            this.defaultValue = defaultValue;
            this.source = source;
        }
        LastOperator.prototype.call = function (observer, source) {
            return source.subscribe(new LastSubscriber(observer, this.predicate, this.resultSelector, this.defaultValue, this.source));
        };
        return LastOperator;
    }());
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var LastSubscriber = (function (_super) {
        __extends$1u(LastSubscriber, _super);
        function LastSubscriber(destination, predicate, resultSelector, defaultValue, source) {
            _super.call(this, destination);
            this.predicate = predicate;
            this.resultSelector = resultSelector;
            this.defaultValue = defaultValue;
            this.source = source;
            this.hasValue = false;
            this.index = 0;
            if (typeof defaultValue !== 'undefined') {
                this.lastValue = defaultValue;
                this.hasValue = true;
            }
        }
        LastSubscriber.prototype._next = function (value) {
            var index = this.index++;
            if (this.predicate) {
                this._tryPredicate(value, index);
            }
            else {
                if (this.resultSelector) {
                    this._tryResultSelector(value, index);
                    return;
                }
                this.lastValue = value;
                this.hasValue = true;
            }
        };
        LastSubscriber.prototype._tryPredicate = function (value, index) {
            var result;
            try {
                result = this.predicate(value, index, this.source);
            }
            catch (err) {
                this.destination.error(err);
                return;
            }
            if (result) {
                if (this.resultSelector) {
                    this._tryResultSelector(value, index);
                    return;
                }
                this.lastValue = value;
                this.hasValue = true;
            }
        };
        LastSubscriber.prototype._tryResultSelector = function (value, index) {
            var result;
            try {
                result = this.resultSelector(value, index);
            }
            catch (err) {
                this.destination.error(err);
                return;
            }
            this.lastValue = result;
            this.hasValue = true;
        };
        LastSubscriber.prototype._complete = function () {
            var destination = this.destination;
            if (this.hasValue) {
                destination.next(this.lastValue);
                destination.complete();
            }
            else {
                destination.error(new EmptyError_1.EmptyError);
            }
        };
        return LastSubscriber;
    }(Subscriber_1.Subscriber));


    var last_1 = {
    	last: last_2
    };

    /* tslint:enable:max-line-length */
    /**
     * Returns an Observable that emits only the last item emitted by the source Observable.
     * It optionally takes a predicate function as a parameter, in which case, rather than emitting
     * the last item from the source Observable, the resulting Observable will emit the last item
     * from the source Observable that satisfies the predicate.
     *
     * <img src="./img/last.png" width="100%">
     *
     * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`
     * callback if the Observable completes before any `next` notification was sent.
     * @param {function} predicate - The condition any source emitted item has to satisfy.
     * @return {Observable} An Observable that emits only the last item satisfying the given condition
     * from the source, or an NoSuchElementException if no such items are emitted.
     * @throws - Throws if no items that match the predicate are emitted by the source Observable.
     * @method last
     * @owner Observable
     */
    function last$1(predicate, resultSelector, defaultValue) {
        return last_1.last(predicate, resultSelector, defaultValue)(this);
    }
    var last_3 = last$1;


    var last_2$1 = {
    	last: last_3
    };

    Observable_1.Observable.prototype.last = last_2$1.last;

    /**
     * @param func
     * @return {Observable<R>}
     * @method let
     * @owner Observable
     */
    function letProto(func) {
        return func(this);
    }
    var letProto_1 = letProto;


    var _let = {
    	letProto: letProto_1
    };

    Observable_1.Observable.prototype.let = _let.letProto;
    Observable_1.Observable.prototype.letBind = _let.letProto;

    var __extends$1v = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };

    /**
     * Returns an Observable that emits whether or not every item of the source satisfies the condition specified.
     *
     * @example <caption>A simple example emitting true if all elements are less than 5, false otherwise</caption>
     *  Observable.of(1, 2, 3, 4, 5, 6)
     *     .every(x => x < 5)
     *     .subscribe(x => console.log(x)); // -> false
     *
     * @param {function} predicate A function for determining if an item meets a specified condition.
     * @param {any} [thisArg] Optional object to use for `this` in the callback.
     * @return {Observable} An Observable of booleans that determines if all items of the source Observable meet the condition specified.
     * @method every
     * @owner Observable
     */
    function every(predicate, thisArg) {
        return function (source) { return source.lift(new EveryOperator(predicate, thisArg, source)); };
    }
    var every_2 = every;
    var EveryOperator = (function () {
        function EveryOperator(predicate, thisArg, source) {
            this.predicate = predicate;
            this.thisArg = thisArg;
            this.source = source;
        }
        EveryOperator.prototype.call = function (observer, source) {
            return source.subscribe(new EverySubscriber(observer, this.predicate, this.thisArg, this.source));
        };
        return EveryOperator;
    }());
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var EverySubscriber = (function (_super) {
        __extends$1v(EverySubscriber, _super);
        function EverySubscriber(destination, predicate, thisArg, source) {
            _super.call(this, destination);
            this.predicate = predicate;
            this.thisArg = thisArg;
            this.source = source;
            this.index = 0;
            this.thisArg = thisArg || this;
        }
        EverySubscriber.prototype.notifyComplete = function (everyValueMatch) {
            this.destination.next(everyValueMatch);
            this.destination.complete();
        };
        EverySubscriber.prototype._next = function (value) {
            var result = false;
            try {
                result = this.predicate.call(this.thisArg, value, this.index++, this.source);
            }
            catch (err) {
                this.destination.error(err);
                return;
            }
            if (!result) {
                this.notifyComplete(false);
            }
        };
        EverySubscriber.prototype._complete = function () {
            this.notifyComplete(true);
        };
        return EverySubscriber;
    }(Subscriber_1.Subscriber));


    var every_1 = {
    	every: every_2
    };

    /**
     * Returns an Observable that emits whether or not every item of the source satisfies the condition specified.
     *
     * @example <caption>A simple example emitting true if all elements are less than 5, false otherwise</caption>
     *  Observable.of(1, 2, 3, 4, 5, 6)
     *     .every(x => x < 5)
     *     .subscribe(x => console.log(x)); // -> false
     *
     * @param {function} predicate A function for determining if an item meets a specified condition.
     * @param {any} [thisArg] Optional object to use for `this` in the callback.
     * @return {Observable} An Observable of booleans that determines if all items of the source Observable meet the condition specified.
     * @method every
     * @owner Observable
     */
    function every$1(predicate, thisArg) {
        return every_1.every(predicate, thisArg)(this);
    }
    var every_3 = every$1;


    var every_2$1 = {
    	every: every_3
    };

    Observable_1.Observable.prototype.every = every_2$1.every;

    /**
     * Applies a given `project` function to each value emitted by the source
     * Observable, and emits the resulting values as an Observable.
     *
     * <span class="informal">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),
     * it passes each source value through a transformation function to get
     * corresponding output values.</span>
     *
     * <img src="./img/map.png" width="100%">
     *
     * Similar to the well known `Array.prototype.map` function, this operator
     * applies a projection to each value and emits that projection in the output
     * Observable.
     *
     * @example <caption>Map every click to the clientX position of that click</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var positions = clicks.map(ev => ev.clientX);
     * positions.subscribe(x => console.log(x));
     *
     * @see {@link mapTo}
     * @see {@link pluck}
     *
     * @param {function(value: T, index: number): R} project The function to apply
     * to each `value` emitted by the source Observable. The `index` parameter is
     * the number `i` for the i-th emission that has happened since the
     * subscription, starting from the number `0`.
     * @param {any} [thisArg] An optional argument to define what `this` is in the
     * `project` function.
     * @return {Observable<R>} An Observable that emits the values from the source
     * Observable transformed by the given `project` function.
     * @method map
     * @owner Observable
     */
    function map$1(project, thisArg) {
        return map_1.map(project, thisArg)(this);
    }
    var map_3 = map$1;


    var map_2$1 = {
    	map: map_3
    };

    Observable_1.Observable.prototype.map = map_2$1.map;

    var __extends$1w = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };

    /**
     * Emits the given constant value on the output Observable every time the source
     * Observable emits a value.
     *
     * <span class="informal">Like {@link map}, but it maps every source value to
     * the same output value every time.</span>
     *
     * <img src="./img/mapTo.png" width="100%">
     *
     * Takes a constant `value` as argument, and emits that whenever the source
     * Observable emits a value. In other words, ignores the actual source value,
     * and simply uses the emission moment to know when to emit the given `value`.
     *
     * @example <caption>Map every click to the string 'Hi'</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var greetings = clicks.mapTo('Hi');
     * greetings.subscribe(x => console.log(x));
     *
     * @see {@link map}
     *
     * @param {any} value The value to map each source value to.
     * @return {Observable} An Observable that emits the given `value` every time
     * the source Observable emits something.
     * @method mapTo
     * @owner Observable
     */
    function mapTo(value) {
        return function (source) { return source.lift(new MapToOperator(value)); };
    }
    var mapTo_2 = mapTo;
    var MapToOperator = (function () {
        function MapToOperator(value) {
            this.value = value;
        }
        MapToOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(new MapToSubscriber(subscriber, this.value));
        };
        return MapToOperator;
    }());
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var MapToSubscriber = (function (_super) {
        __extends$1w(MapToSubscriber, _super);
        function MapToSubscriber(destination, value) {
            _super.call(this, destination);
            this.value = value;
        }
        MapToSubscriber.prototype._next = function (x) {
            this.destination.next(this.value);
        };
        return MapToSubscriber;
    }(Subscriber_1.Subscriber));


    var mapTo_1 = {
    	mapTo: mapTo_2
    };

    /**
     * Emits the given constant value on the output Observable every time the source
     * Observable emits a value.
     *
     * <span class="informal">Like {@link map}, but it maps every source value to
     * the same output value every time.</span>
     *
     * <img src="./img/mapTo.png" width="100%">
     *
     * Takes a constant `value` as argument, and emits that whenever the source
     * Observable emits a value. In other words, ignores the actual source value,
     * and simply uses the emission moment to know when to emit the given `value`.
     *
     * @example <caption>Map every click to the string 'Hi'</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var greetings = clicks.mapTo('Hi');
     * greetings.subscribe(x => console.log(x));
     *
     * @see {@link map}
     *
     * @param {any} value The value to map each source value to.
     * @return {Observable} An Observable that emits the given `value` every time
     * the source Observable emits something.
     * @method mapTo
     * @owner Observable
     */
    function mapTo$1(value) {
        return mapTo_1.mapTo(value)(this);
    }
    var mapTo_3 = mapTo$1;


    var mapTo_2$1 = {
    	mapTo: mapTo_3
    };

    Observable_1.Observable.prototype.mapTo = mapTo_2$1.mapTo;

    var __extends$1x = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };


    /**
     * Represents all of the notifications from the source Observable as `next`
     * emissions marked with their original types within {@link Notification}
     * objects.
     *
     * <span class="informal">Wraps `next`, `error` and `complete` emissions in
     * {@link Notification} objects, emitted as `next` on the output Observable.
     * </span>
     *
     * <img src="./img/materialize.png" width="100%">
     *
     * `materialize` returns an Observable that emits a `next` notification for each
     * `next`, `error`, or `complete` emission of the source Observable. When the
     * source Observable emits `complete`, the output Observable will emit `next` as
     * a Notification of type "complete", and then it will emit `complete` as well.
     * When the source Observable emits `error`, the output will emit `next` as a
     * Notification of type "error", and then `complete`.
     *
     * This operator is useful for producing metadata of the source Observable, to
     * be consumed as `next` emissions. Use it in conjunction with
     * {@link dematerialize}.
     *
     * @example <caption>Convert a faulty Observable to an Observable of Notifications</caption>
     * var letters = Rx.Observable.of('a', 'b', 13, 'd');
     * var upperCase = letters.map(x => x.toUpperCase());
     * var materialized = upperCase.materialize();
     * materialized.subscribe(x => console.log(x));
     *
     * // Results in the following:
     * // - Notification {kind: "N", value: "A", error: undefined, hasValue: true}
     * // - Notification {kind: "N", value: "B", error: undefined, hasValue: true}
     * // - Notification {kind: "E", value: undefined, error: TypeError:
     * //   x.toUpperCase is not a function at MapSubscriber.letters.map.x
     * //   [as project] (http://1…, hasValue: false}
     *
     * @see {@link Notification}
     * @see {@link dematerialize}
     *
     * @return {Observable<Notification<T>>} An Observable that emits
     * {@link Notification} objects that wrap the original emissions from the source
     * Observable with metadata.
     * @method materialize
     * @owner Observable
     */
    function materialize() {
        return function materializeOperatorFunction(source) {
            return source.lift(new MaterializeOperator());
        };
    }
    var materialize_2 = materialize;
    var MaterializeOperator = (function () {
        function MaterializeOperator() {
        }
        MaterializeOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(new MaterializeSubscriber(subscriber));
        };
        return MaterializeOperator;
    }());
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var MaterializeSubscriber = (function (_super) {
        __extends$1x(MaterializeSubscriber, _super);
        function MaterializeSubscriber(destination) {
            _super.call(this, destination);
        }
        MaterializeSubscriber.prototype._next = function (value) {
            this.destination.next(Notification_1.Notification.createNext(value));
        };
        MaterializeSubscriber.prototype._error = function (err) {
            var destination = this.destination;
            destination.next(Notification_1.Notification.createError(err));
            destination.complete();
        };
        MaterializeSubscriber.prototype._complete = function () {
            var destination = this.destination;
            destination.next(Notification_1.Notification.createComplete());
            destination.complete();
        };
        return MaterializeSubscriber;
    }(Subscriber_1.Subscriber));


    var materialize_1 = {
    	materialize: materialize_2
    };

    /**
     * Represents all of the notifications from the source Observable as `next`
     * emissions marked with their original types within {@link Notification}
     * objects.
     *
     * <span class="informal">Wraps `next`, `error` and `complete` emissions in
     * {@link Notification} objects, emitted as `next` on the output Observable.
     * </span>
     *
     * <img src="./img/materialize.png" width="100%">
     *
     * `materialize` returns an Observable that emits a `next` notification for each
     * `next`, `error`, or `complete` emission of the source Observable. When the
     * source Observable emits `complete`, the output Observable will emit `next` as
     * a Notification of type "complete", and then it will emit `complete` as well.
     * When the source Observable emits `error`, the output will emit `next` as a
     * Notification of type "error", and then `complete`.
     *
     * This operator is useful for producing metadata of the source Observable, to
     * be consumed as `next` emissions. Use it in conjunction with
     * {@link dematerialize}.
     *
     * @example <caption>Convert a faulty Observable to an Observable of Notifications</caption>
     * var letters = Rx.Observable.of('a', 'b', 13, 'd');
     * var upperCase = letters.map(x => x.toUpperCase());
     * var materialized = upperCase.materialize();
     * materialized.subscribe(x => console.log(x));
     *
     * // Results in the following:
     * // - Notification {kind: "N", value: "A", error: undefined, hasValue: true}
     * // - Notification {kind: "N", value: "B", error: undefined, hasValue: true}
     * // - Notification {kind: "E", value: undefined, error: TypeError:
     * //   x.toUpperCase is not a function at MapSubscriber.letters.map.x
     * //   [as project] (http://1…, hasValue: false}
     *
     * @see {@link Notification}
     * @see {@link dematerialize}
     *
     * @return {Observable<Notification<T>>} An Observable that emits
     * {@link Notification} objects that wrap the original emissions from the source
     * Observable with metadata.
     * @method materialize
     * @owner Observable
     */
    function materialize$1() {
        return materialize_1.materialize()(this);
    }
    var materialize_3 = materialize$1;


    var materialize_2$1 = {
    	materialize: materialize_3
    };

    Observable_1.Observable.prototype.materialize = materialize_2$1.materialize;

    var __extends$1y = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };

    /* tslint:enable:max-line-length */
    /**
     * Applies an accumulator function over the source Observable, and returns each
     * intermediate result, with an optional seed value.
     *
     * <span class="informal">It's like {@link reduce}, but emits the current
     * accumulation whenever the source emits a value.</span>
     *
     * <img src="./img/scan.png" width="100%">
     *
     * Combines together all values emitted on the source, using an accumulator
     * function that knows how to join a new source value into the accumulation from
     * the past. Is similar to {@link reduce}, but emits the intermediate
     * accumulations.
     *
     * Returns an Observable that applies a specified `accumulator` function to each
     * item emitted by the source Observable. If a `seed` value is specified, then
     * that value will be used as the initial value for the accumulator. If no seed
     * value is specified, the first item of the source is used as the seed.
     *
     * @example <caption>Count the number of click events</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var ones = clicks.mapTo(1);
     * var seed = 0;
     * var count = ones.scan((acc, one) => acc + one, seed);
     * count.subscribe(x => console.log(x));
     *
     * @see {@link expand}
     * @see {@link mergeScan}
     * @see {@link reduce}
     *
     * @param {function(acc: R, value: T, index: number): R} accumulator
     * The accumulator function called on each source value.
     * @param {T|R} [seed] The initial accumulation value.
     * @return {Observable<R>} An observable of the accumulated values.
     * @method scan
     * @owner Observable
     */
    function scan(accumulator, seed) {
        var hasSeed = false;
        // providing a seed of `undefined` *should* be valid and trigger
        // hasSeed! so don't use `seed !== undefined` checks!
        // For this reason, we have to check it here at the original call site
        // otherwise inside Operator/Subscriber we won't know if `undefined`
        // means they didn't provide anything or if they literally provided `undefined`
        if (arguments.length >= 2) {
            hasSeed = true;
        }
        return function scanOperatorFunction(source) {
            return source.lift(new ScanOperator(accumulator, seed, hasSeed));
        };
    }
    var scan_2 = scan;
    var ScanOperator = (function () {
        function ScanOperator(accumulator, seed, hasSeed) {
            if (hasSeed === void 0) { hasSeed = false; }
            this.accumulator = accumulator;
            this.seed = seed;
            this.hasSeed = hasSeed;
        }
        ScanOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(new ScanSubscriber(subscriber, this.accumulator, this.seed, this.hasSeed));
        };
        return ScanOperator;
    }());
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var ScanSubscriber = (function (_super) {
        __extends$1y(ScanSubscriber, _super);
        function ScanSubscriber(destination, accumulator, _seed, hasSeed) {
            _super.call(this, destination);
            this.accumulator = accumulator;
            this._seed = _seed;
            this.hasSeed = hasSeed;
            this.index = 0;
        }
        Object.defineProperty(ScanSubscriber.prototype, "seed", {
            get: function () {
                return this._seed;
            },
            set: function (value) {
                this.hasSeed = true;
                this._seed = value;
            },
            enumerable: true,
            configurable: true
        });
        ScanSubscriber.prototype._next = function (value) {
            if (!this.hasSeed) {
                this.seed = value;
                this.destination.next(value);
            }
            else {
                return this._tryNext(value);
            }
        };
        ScanSubscriber.prototype._tryNext = function (value) {
            var index = this.index++;
            var result;
            try {
                result = this.accumulator(this.seed, value, index);
            }
            catch (err) {
                this.destination.error(err);
            }
            this.seed = result;
            this.destination.next(result);
        };
        return ScanSubscriber;
    }(Subscriber_1.Subscriber));


    var scan_1 = {
    	scan: scan_2
    };

    var __extends$1z = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };



    /**
     * Emits only the last `count` values emitted by the source Observable.
     *
     * <span class="informal">Remembers the latest `count` values, then emits those
     * only when the source completes.</span>
     *
     * <img src="./img/takeLast.png" width="100%">
     *
     * `takeLast` returns an Observable that emits at most the last `count` values
     * emitted by the source Observable. If the source emits fewer than `count`
     * values then all of its values are emitted. This operator must wait until the
     * `complete` notification emission from the source in order to emit the `next`
     * values on the output Observable, because otherwise it is impossible to know
     * whether or not more values will be emitted on the source. For this reason,
     * all values are emitted synchronously, followed by the complete notification.
     *
     * @example <caption>Take the last 3 values of an Observable with many values</caption>
     * var many = Rx.Observable.range(1, 100);
     * var lastThree = many.takeLast(3);
     * lastThree.subscribe(x => console.log(x));
     *
     * @see {@link take}
     * @see {@link takeUntil}
     * @see {@link takeWhile}
     * @see {@link skip}
     *
     * @throws {ArgumentOutOfRangeError} When using `takeLast(i)`, it delivers an
     * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.
     *
     * @param {number} count The maximum number of values to emit from the end of
     * the sequence of values emitted by the source Observable.
     * @return {Observable<T>} An Observable that emits at most the last count
     * values emitted by the source Observable.
     * @method takeLast
     * @owner Observable
     */
    function takeLast(count) {
        return function takeLastOperatorFunction(source) {
            if (count === 0) {
                return new EmptyObservable_1.EmptyObservable();
            }
            else {
                return source.lift(new TakeLastOperator(count));
            }
        };
    }
    var takeLast_2 = takeLast;
    var TakeLastOperator = (function () {
        function TakeLastOperator(total) {
            this.total = total;
            if (this.total < 0) {
                throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;
            }
        }
        TakeLastOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(new TakeLastSubscriber(subscriber, this.total));
        };
        return TakeLastOperator;
    }());
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var TakeLastSubscriber = (function (_super) {
        __extends$1z(TakeLastSubscriber, _super);
        function TakeLastSubscriber(destination, total) {
            _super.call(this, destination);
            this.total = total;
            this.ring = new Array();
            this.count = 0;
        }
        TakeLastSubscriber.prototype._next = function (value) {
            var ring = this.ring;
            var total = this.total;
            var count = this.count++;
            if (ring.length < total) {
                ring.push(value);
            }
            else {
                var index = count % total;
                ring[index] = value;
            }
        };
        TakeLastSubscriber.prototype._complete = function () {
            var destination = this.destination;
            var count = this.count;
            if (count > 0) {
                var total = this.count >= this.total ? this.total : this.count;
                var ring = this.ring;
                for (var i = 0; i < total; i++) {
                    var idx = (count++) % total;
                    destination.next(ring[idx]);
                }
            }
            destination.complete();
        };
        return TakeLastSubscriber;
    }(Subscriber_1.Subscriber));


    var takeLast_1 = {
    	takeLast: takeLast_2
    };

    /* tslint:enable:max-line-length */
    /**
     * Applies an accumulator function over the source Observable, and returns the
     * accumulated result when the source completes, given an optional seed value.
     *
     * <span class="informal">Combines together all values emitted on the source,
     * using an accumulator function that knows how to join a new source value into
     * the accumulation from the past.</span>
     *
     * <img src="./img/reduce.png" width="100%">
     *
     * Like
     * [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce),
     * `reduce` applies an `accumulator` function against an accumulation and each
     * value of the source Observable (from the past) to reduce it to a single
     * value, emitted on the output Observable. Note that `reduce` will only emit
     * one value, only when the source Observable completes. It is equivalent to
     * applying operator {@link scan} followed by operator {@link last}.
     *
     * Returns an Observable that applies a specified `accumulator` function to each
     * item emitted by the source Observable. If a `seed` value is specified, then
     * that value will be used as the initial value for the accumulator. If no seed
     * value is specified, the first item of the source is used as the seed.
     *
     * @example <caption>Count the number of click events that happened in 5 seconds</caption>
     * var clicksInFiveSeconds = Rx.Observable.fromEvent(document, 'click')
     *   .takeUntil(Rx.Observable.interval(5000));
     * var ones = clicksInFiveSeconds.mapTo(1);
     * var seed = 0;
     * var count = ones.reduce((acc, one) => acc + one, seed);
     * count.subscribe(x => console.log(x));
     *
     * @see {@link count}
     * @see {@link expand}
     * @see {@link mergeScan}
     * @see {@link scan}
     *
     * @param {function(acc: R, value: T, index: number): R} accumulator The accumulator function
     * called on each source value.
     * @param {R} [seed] The initial accumulation value.
     * @return {Observable<R>} An Observable that emits a single value that is the
     * result of accumulating the values emitted by the source Observable.
     * @method reduce
     * @owner Observable
     */
    function reduce(accumulator, seed) {
        // providing a seed of `undefined` *should* be valid and trigger
        // hasSeed! so don't use `seed !== undefined` checks!
        // For this reason, we have to check it here at the original call site
        // otherwise inside Operator/Subscriber we won't know if `undefined`
        // means they didn't provide anything or if they literally provided `undefined`
        if (arguments.length >= 2) {
            return function reduceOperatorFunctionWithSeed(source) {
                return pipe_1.pipe(scan_1.scan(accumulator, seed), takeLast_1.takeLast(1), defaultIfEmpty_1.defaultIfEmpty(seed))(source);
            };
        }
        return function reduceOperatorFunction(source) {
            return pipe_1.pipe(scan_1.scan(function (acc, value, index) {
                return accumulator(acc, value, index + 1);
            }), takeLast_1.takeLast(1))(source);
        };
    }
    var reduce_2 = reduce;


    var reduce_1 = {
    	reduce: reduce_2
    };

    /**
     * The Max operator operates on an Observable that emits numbers (or items that can be compared with a provided function),
     * and when source Observable completes it emits a single item: the item with the largest value.
     *
     * <img src="./img/max.png" width="100%">
     *
     * @example <caption>Get the maximal value of a series of numbers</caption>
     * Rx.Observable.of(5, 4, 7, 2, 8)
     *   .max()
     *   .subscribe(x => console.log(x)); // -> 8
     *
     * @example <caption>Use a comparer function to get the maximal item</caption>
     * interface Person {
     *   age: number,
     *   name: string
     * }
     * Observable.of<Person>({age: 7, name: 'Foo'},
     *                       {age: 5, name: 'Bar'},
     *                       {age: 9, name: 'Beer'})
     *           .max<Person>((a: Person, b: Person) => a.age < b.age ? -1 : 1)
     *           .subscribe((x: Person) => console.log(x.name)); // -> 'Beer'
     * }
     *
     * @see {@link min}
     *
     * @param {Function} [comparer] - Optional comparer function that it will use instead of its default to compare the
     * value of two items.
     * @return {Observable} An Observable that emits item with the largest value.
     * @method max
     * @owner Observable
     */
    function max(comparer) {
        var max = (typeof comparer === 'function')
            ? function (x, y) { return comparer(x, y) > 0 ? x : y; }
            : function (x, y) { return x > y ? x : y; };
        return reduce_1.reduce(max);
    }
    var max_2 = max;


    var max_1 = {
    	max: max_2
    };

    /**
     * The Max operator operates on an Observable that emits numbers (or items that can be compared with a provided function),
     * and when source Observable completes it emits a single item: the item with the largest value.
     *
     * <img src="./img/max.png" width="100%">
     *
     * @example <caption>Get the maximal value of a series of numbers</caption>
     * Rx.Observable.of(5, 4, 7, 2, 8)
     *   .max()
     *   .subscribe(x => console.log(x)); // -> 8
     *
     * @example <caption>Use a comparer function to get the maximal item</caption>
     * interface Person {
     *   age: number,
     *   name: string
     * }
     * Observable.of<Person>({age: 7, name: 'Foo'},
     *                       {age: 5, name: 'Bar'},
     *                       {age: 9, name: 'Beer'})
     *           .max<Person>((a: Person, b: Person) => a.age < b.age ? -1 : 1)
     *           .subscribe((x: Person) => console.log(x.name)); // -> 'Beer'
     * }
     *
     * @see {@link min}
     *
     * @param {Function} [comparer] - Optional comparer function that it will use instead of its default to compare the
     * value of two items.
     * @return {Observable} An Observable that emits item with the largest value.
     * @method max
     * @owner Observable
     */
    function max$1(comparer) {
        return max_1.max(comparer)(this);
    }
    var max_3 = max$1;


    var max_2$1 = {
    	max: max_3
    };

    Observable_1.Observable.prototype.max = max_2$1.max;

    var merge_2$1 = merge_1;
    var mergeStatic = merge_2$1.merge;
    /* tslint:enable:max-line-length */
    /**
     * Creates an output Observable which concurrently emits all values from every
     * given input Observable.
     *
     * <span class="informal">Flattens multiple Observables together by blending
     * their values into one Observable.</span>
     *
     * <img src="./img/merge.png" width="100%">
     *
     * `merge` subscribes to each given input Observable (either the source or an
     * Observable given as argument), and simply forwards (without doing any
     * transformation) all the values from all the input Observables to the output
     * Observable. The output Observable only completes once all input Observables
     * have completed. Any error delivered by an input Observable will be immediately
     * emitted on the output Observable.
     *
     * @example <caption>Merge together two Observables: 1s interval and clicks</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var timer = Rx.Observable.interval(1000);
     * var clicksOrTimer = clicks.merge(timer);
     * clicksOrTimer.subscribe(x => console.log(x));
     *
     * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>
     * var timer1 = Rx.Observable.interval(1000).take(10);
     * var timer2 = Rx.Observable.interval(2000).take(6);
     * var timer3 = Rx.Observable.interval(500).take(10);
     * var concurrent = 2; // the argument
     * var merged = timer1.merge(timer2, timer3, concurrent);
     * merged.subscribe(x => console.log(x));
     *
     * @see {@link mergeAll}
     * @see {@link mergeMap}
     * @see {@link mergeMapTo}
     * @see {@link mergeScan}
     *
     * @param {ObservableInput} other An input Observable to merge with the source
     * Observable. More than one input Observables may be given as argument.
     * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
     * Observables being subscribed to concurrently.
     * @param {Scheduler} [scheduler=null] The IScheduler to use for managing
     * concurrency of input Observables.
     * @return {Observable} An Observable that emits items that are the result of
     * every input Observable.
     * @method merge
     * @owner Observable
     */
    function merge$2() {
        var observables = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            observables[_i - 0] = arguments[_i];
        }
        return function (source) { return source.lift.call(merge_1.merge.apply(void 0, [source].concat(observables))); };
    }
    var merge_4 = merge$2;


    var merge_3 = {
    	mergeStatic: mergeStatic,
    	merge: merge_4
    };

    var mergeStatic$1 = merge_1.merge;
    /* tslint:enable:max-line-length */
    /**
     * Creates an output Observable which concurrently emits all values from every
     * given input Observable.
     *
     * <span class="informal">Flattens multiple Observables together by blending
     * their values into one Observable.</span>
     *
     * <img src="./img/merge.png" width="100%">
     *
     * `merge` subscribes to each given input Observable (either the source or an
     * Observable given as argument), and simply forwards (without doing any
     * transformation) all the values from all the input Observables to the output
     * Observable. The output Observable only completes once all input Observables
     * have completed. Any error delivered by an input Observable will be immediately
     * emitted on the output Observable.
     *
     * @example <caption>Merge together two Observables: 1s interval and clicks</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var timer = Rx.Observable.interval(1000);
     * var clicksOrTimer = clicks.merge(timer);
     * clicksOrTimer.subscribe(x => console.log(x));
     *
     * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>
     * var timer1 = Rx.Observable.interval(1000).take(10);
     * var timer2 = Rx.Observable.interval(2000).take(6);
     * var timer3 = Rx.Observable.interval(500).take(10);
     * var concurrent = 2; // the argument
     * var merged = timer1.merge(timer2, timer3, concurrent);
     * merged.subscribe(x => console.log(x));
     *
     * @see {@link mergeAll}
     * @see {@link mergeMap}
     * @see {@link mergeMapTo}
     * @see {@link mergeScan}
     *
     * @param {ObservableInput} other An input Observable to merge with the source
     * Observable. More than one input Observables may be given as argument.
     * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
     * Observables being subscribed to concurrently.
     * @param {Scheduler} [scheduler=null] The IScheduler to use for managing
     * concurrency of input Observables.
     * @return {Observable} An Observable that emits items that are the result of
     * every input Observable.
     * @method merge
     * @owner Observable
     */
    function merge$3() {
        var observables = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            observables[_i - 0] = arguments[_i];
        }
        return merge_3.merge.apply(void 0, observables)(this);
    }
    var merge_4$1 = merge$3;


    var merge_3$1 = {
    	mergeStatic: mergeStatic$1,
    	merge: merge_4$1
    };

    Observable_1.Observable.prototype.merge = merge_3$1.merge;

    /**
     * Converts a higher-order Observable into a first-order Observable which
     * concurrently delivers all values that are emitted on the inner Observables.
     *
     * <span class="informal">Flattens an Observable-of-Observables.</span>
     *
     * <img src="./img/mergeAll.png" width="100%">
     *
     * `mergeAll` subscribes to an Observable that emits Observables, also known as
     * a higher-order Observable. Each time it observes one of these emitted inner
     * Observables, it subscribes to that and delivers all the values from the
     * inner Observable on the output Observable. The output Observable only
     * completes once all inner Observables have completed. Any error delivered by
     * a inner Observable will be immediately emitted on the output Observable.
     *
     * @example <caption>Spawn a new interval Observable for each click event, and blend their outputs as one Observable</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000));
     * var firstOrder = higherOrder.mergeAll();
     * firstOrder.subscribe(x => console.log(x));
     *
     * @example <caption>Count from 0 to 9 every second for each click, but only allow 2 concurrent timers</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000).take(10));
     * var firstOrder = higherOrder.mergeAll(2);
     * firstOrder.subscribe(x => console.log(x));
     *
     * @see {@link combineAll}
     * @see {@link concatAll}
     * @see {@link exhaust}
     * @see {@link merge}
     * @see {@link mergeMap}
     * @see {@link mergeMapTo}
     * @see {@link mergeScan}
     * @see {@link switch}
     * @see {@link zipAll}
     *
     * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of inner
     * Observables being subscribed to concurrently.
     * @return {Observable} An Observable that emits values coming from all the
     * inner Observables emitted by the source Observable.
     * @method mergeAll
     * @owner Observable
     */
    function mergeAll$1(concurrent) {
        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
        return mergeAll_1.mergeAll(concurrent)(this);
    }
    var mergeAll_3 = mergeAll$1;


    var mergeAll_2$1 = {
    	mergeAll: mergeAll_3
    };

    Observable_1.Observable.prototype.mergeAll = mergeAll_2$1.mergeAll;

    /* tslint:enable:max-line-length */
    /**
     * Projects each source value to an Observable which is merged in the output
     * Observable.
     *
     * <span class="informal">Maps each value to an Observable, then flattens all of
     * these inner Observables using {@link mergeAll}.</span>
     *
     * <img src="./img/mergeMap.png" width="100%">
     *
     * Returns an Observable that emits items based on applying a function that you
     * supply to each item emitted by the source Observable, where that function
     * returns an Observable, and then merging those resulting Observables and
     * emitting the results of this merger.
     *
     * @example <caption>Map and flatten each letter to an Observable ticking every 1 second</caption>
     * var letters = Rx.Observable.of('a', 'b', 'c');
     * var result = letters.mergeMap(x =>
     *   Rx.Observable.interval(1000).map(i => x+i)
     * );
     * result.subscribe(x => console.log(x));
     *
     * // Results in the following:
     * // a0
     * // b0
     * // c0
     * // a1
     * // b1
     * // c1
     * // continues to list a,b,c with respective ascending integers
     *
     * @see {@link concatMap}
     * @see {@link exhaustMap}
     * @see {@link merge}
     * @see {@link mergeAll}
     * @see {@link mergeMapTo}
     * @see {@link mergeScan}
     * @see {@link switchMap}
     *
     * @param {function(value: T, ?index: number): ObservableInput} project A function
     * that, when applied to an item emitted by the source Observable, returns an
     * Observable.
     * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
     * A function to produce the value on the output Observable based on the values
     * and the indices of the source (outer) emission and the inner Observable
     * emission. The arguments passed to this function are:
     * - `outerValue`: the value that came from the source
     * - `innerValue`: the value that came from the projected Observable
     * - `outerIndex`: the "index" of the value that came from the source
     * - `innerIndex`: the "index" of the value from the projected Observable
     * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
     * Observables being subscribed to concurrently.
     * @return {Observable} An Observable that emits the result of applying the
     * projection function (and the optional `resultSelector`) to each item emitted
     * by the source Observable and merging the results of the Observables obtained
     * from this transformation.
     * @method mergeMap
     * @owner Observable
     */
    function mergeMap$1(project, resultSelector, concurrent) {
        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
        return mergeMap_1.mergeMap(project, resultSelector, concurrent)(this);
    }
    var mergeMap_3 = mergeMap$1;


    var mergeMap_2$1 = {
    	mergeMap: mergeMap_3
    };

    Observable_1.Observable.prototype.mergeMap = mergeMap_2$1.mergeMap;
    Observable_1.Observable.prototype.flatMap = mergeMap_2$1.mergeMap;

    var __extends$1A = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };


    /* tslint:enable:max-line-length */
    /**
     * Projects each source value to the same Observable which is merged multiple
     * times in the output Observable.
     *
     * <span class="informal">It's like {@link mergeMap}, but maps each value always
     * to the same inner Observable.</span>
     *
     * <img src="./img/mergeMapTo.png" width="100%">
     *
     * Maps each source value to the given Observable `innerObservable` regardless
     * of the source value, and then merges those resulting Observables into one
     * single Observable, which is the output Observable.
     *
     * @example <caption>For each click event, start an interval Observable ticking every 1 second</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var result = clicks.mergeMapTo(Rx.Observable.interval(1000));
     * result.subscribe(x => console.log(x));
     *
     * @see {@link concatMapTo}
     * @see {@link merge}
     * @see {@link mergeAll}
     * @see {@link mergeMap}
     * @see {@link mergeScan}
     * @see {@link switchMapTo}
     *
     * @param {ObservableInput} innerObservable An Observable to replace each value from
     * the source Observable.
     * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
     * A function to produce the value on the output Observable based on the values
     * and the indices of the source (outer) emission and the inner Observable
     * emission. The arguments passed to this function are:
     * - `outerValue`: the value that came from the source
     * - `innerValue`: the value that came from the projected Observable
     * - `outerIndex`: the "index" of the value that came from the source
     * - `innerIndex`: the "index" of the value from the projected Observable
     * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
     * Observables being subscribed to concurrently.
     * @return {Observable} An Observable that emits items from the given
     * `innerObservable` (and optionally transformed through `resultSelector`) every
     * time a value is emitted on the source Observable.
     * @method mergeMapTo
     * @owner Observable
     */
    function mergeMapTo(innerObservable, resultSelector, concurrent) {
        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
        if (typeof resultSelector === 'number') {
            concurrent = resultSelector;
            resultSelector = null;
        }
        return function (source) { return source.lift(new MergeMapToOperator(innerObservable, resultSelector, concurrent)); };
    }
    var mergeMapTo_2 = mergeMapTo;
    // TODO: Figure out correct signature here: an Operator<Observable<T>, R>
    //       needs to implement call(observer: Subscriber<R>): Subscriber<Observable<T>>
    var MergeMapToOperator = (function () {
        function MergeMapToOperator(ish, resultSelector, concurrent) {
            if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
            this.ish = ish;
            this.resultSelector = resultSelector;
            this.concurrent = concurrent;
        }
        MergeMapToOperator.prototype.call = function (observer, source) {
            return source.subscribe(new MergeMapToSubscriber(observer, this.ish, this.resultSelector, this.concurrent));
        };
        return MergeMapToOperator;
    }());
    var MergeMapToOperator_1 = MergeMapToOperator;
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var MergeMapToSubscriber = (function (_super) {
        __extends$1A(MergeMapToSubscriber, _super);
        function MergeMapToSubscriber(destination, ish, resultSelector, concurrent) {
            if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
            _super.call(this, destination);
            this.ish = ish;
            this.resultSelector = resultSelector;
            this.concurrent = concurrent;
            this.hasCompleted = false;
            this.buffer = [];
            this.active = 0;
            this.index = 0;
        }
        MergeMapToSubscriber.prototype._next = function (value) {
            if (this.active < this.concurrent) {
                var resultSelector = this.resultSelector;
                var index = this.index++;
                var ish = this.ish;
                var destination = this.destination;
                this.active++;
                this._innerSub(ish, destination, resultSelector, value, index);
            }
            else {
                this.buffer.push(value);
            }
        };
        MergeMapToSubscriber.prototype._innerSub = function (ish, destination, resultSelector, value, index) {
            this.add(subscribeToResult_1.subscribeToResult(this, ish, value, index));
        };
        MergeMapToSubscriber.prototype._complete = function () {
            this.hasCompleted = true;
            if (this.active === 0 && this.buffer.length === 0) {
                this.destination.complete();
            }
        };
        MergeMapToSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
            var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;
            if (resultSelector) {
                this.trySelectResult(outerValue, innerValue, outerIndex, innerIndex);
            }
            else {
                destination.next(innerValue);
            }
        };
        MergeMapToSubscriber.prototype.trySelectResult = function (outerValue, innerValue, outerIndex, innerIndex) {
            var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;
            var result;
            try {
                result = resultSelector(outerValue, innerValue, outerIndex, innerIndex);
            }
            catch (err) {
                destination.error(err);
                return;
            }
            destination.next(result);
        };
        MergeMapToSubscriber.prototype.notifyError = function (err) {
            this.destination.error(err);
        };
        MergeMapToSubscriber.prototype.notifyComplete = function (innerSub) {
            var buffer = this.buffer;
            this.remove(innerSub);
            this.active--;
            if (buffer.length > 0) {
                this._next(buffer.shift());
            }
            else if (this.active === 0 && this.hasCompleted) {
                this.destination.complete();
            }
        };
        return MergeMapToSubscriber;
    }(OuterSubscriber_1.OuterSubscriber));
    var MergeMapToSubscriber_1 = MergeMapToSubscriber;


    var mergeMapTo_1 = {
    	mergeMapTo: mergeMapTo_2,
    	MergeMapToOperator: MergeMapToOperator_1,
    	MergeMapToSubscriber: MergeMapToSubscriber_1
    };

    /* tslint:enable:max-line-length */
    /**
     * Projects each source value to the same Observable which is merged multiple
     * times in the output Observable.
     *
     * <span class="informal">It's like {@link mergeMap}, but maps each value always
     * to the same inner Observable.</span>
     *
     * <img src="./img/mergeMapTo.png" width="100%">
     *
     * Maps each source value to the given Observable `innerObservable` regardless
     * of the source value, and then merges those resulting Observables into one
     * single Observable, which is the output Observable.
     *
     * @example <caption>For each click event, start an interval Observable ticking every 1 second</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var result = clicks.mergeMapTo(Rx.Observable.interval(1000));
     * result.subscribe(x => console.log(x));
     *
     * @see {@link concatMapTo}
     * @see {@link merge}
     * @see {@link mergeAll}
     * @see {@link mergeMap}
     * @see {@link mergeScan}
     * @see {@link switchMapTo}
     *
     * @param {ObservableInput} innerObservable An Observable to replace each value from
     * the source Observable.
     * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
     * A function to produce the value on the output Observable based on the values
     * and the indices of the source (outer) emission and the inner Observable
     * emission. The arguments passed to this function are:
     * - `outerValue`: the value that came from the source
     * - `innerValue`: the value that came from the projected Observable
     * - `outerIndex`: the "index" of the value that came from the source
     * - `innerIndex`: the "index" of the value from the projected Observable
     * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
     * Observables being subscribed to concurrently.
     * @return {Observable} An Observable that emits items from the given
     * `innerObservable` (and optionally transformed through `resultSelector`) every
     * time a value is emitted on the source Observable.
     * @method mergeMapTo
     * @owner Observable
     */
    function mergeMapTo$1(innerObservable, resultSelector, concurrent) {
        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
        return mergeMapTo_1.mergeMapTo(innerObservable, resultSelector, concurrent)(this);
    }
    var mergeMapTo_3 = mergeMapTo$1;


    var mergeMapTo_2$1 = {
    	mergeMapTo: mergeMapTo_3
    };

    Observable_1.Observable.prototype.flatMapTo = mergeMapTo_2$1.mergeMapTo;
    Observable_1.Observable.prototype.mergeMapTo = mergeMapTo_2$1.mergeMapTo;

    var __extends$1B = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };




    /**
     * Applies an accumulator function over the source Observable where the
     * accumulator function itself returns an Observable, then each intermediate
     * Observable returned is merged into the output Observable.
     *
     * <span class="informal">It's like {@link scan}, but the Observables returned
     * by the accumulator are merged into the outer Observable.</span>
     *
     * @example <caption>Count the number of click events</caption>
     * const click$ = Rx.Observable.fromEvent(document, 'click');
     * const one$ = click$.mapTo(1);
     * const seed = 0;
     * const count$ = one$.mergeScan((acc, one) => Rx.Observable.of(acc + one), seed);
     * count$.subscribe(x => console.log(x));
     *
     * // Results:
     * 1
     * 2
     * 3
     * 4
     * // ...and so on for each click
     *
     * @param {function(acc: R, value: T): Observable<R>} accumulator
     * The accumulator function called on each source value.
     * @param seed The initial accumulation value.
     * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of
     * input Observables being subscribed to concurrently.
     * @return {Observable<R>} An observable of the accumulated values.
     * @method mergeScan
     * @owner Observable
     */
    function mergeScan(accumulator, seed, concurrent) {
        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
        return function (source) { return source.lift(new MergeScanOperator(accumulator, seed, concurrent)); };
    }
    var mergeScan_2 = mergeScan;
    var MergeScanOperator = (function () {
        function MergeScanOperator(accumulator, seed, concurrent) {
            this.accumulator = accumulator;
            this.seed = seed;
            this.concurrent = concurrent;
        }
        MergeScanOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(new MergeScanSubscriber(subscriber, this.accumulator, this.seed, this.concurrent));
        };
        return MergeScanOperator;
    }());
    var MergeScanOperator_1 = MergeScanOperator;
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var MergeScanSubscriber = (function (_super) {
        __extends$1B(MergeScanSubscriber, _super);
        function MergeScanSubscriber(destination, accumulator, acc, concurrent) {
            _super.call(this, destination);
            this.accumulator = accumulator;
            this.acc = acc;
            this.concurrent = concurrent;
            this.hasValue = false;
            this.hasCompleted = false;
            this.buffer = [];
            this.active = 0;
            this.index = 0;
        }
        MergeScanSubscriber.prototype._next = function (value) {
            if (this.active < this.concurrent) {
                var index = this.index++;
                var ish = tryCatch_1.tryCatch(this.accumulator)(this.acc, value);
                var destination = this.destination;
                if (ish === errorObject.errorObject) {
                    destination.error(errorObject.errorObject.e);
                }
                else {
                    this.active++;
                    this._innerSub(ish, value, index);
                }
            }
            else {
                this.buffer.push(value);
            }
        };
        MergeScanSubscriber.prototype._innerSub = function (ish, value, index) {
            this.add(subscribeToResult_1.subscribeToResult(this, ish, value, index));
        };
        MergeScanSubscriber.prototype._complete = function () {
            this.hasCompleted = true;
            if (this.active === 0 && this.buffer.length === 0) {
                if (this.hasValue === false) {
                    this.destination.next(this.acc);
                }
                this.destination.complete();
            }
        };
        MergeScanSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
            var destination = this.destination;
            this.acc = innerValue;
            this.hasValue = true;
            destination.next(innerValue);
        };
        MergeScanSubscriber.prototype.notifyComplete = function (innerSub) {
            var buffer = this.buffer;
            this.remove(innerSub);
            this.active--;
            if (buffer.length > 0) {
                this._next(buffer.shift());
            }
            else if (this.active === 0 && this.hasCompleted) {
                if (this.hasValue === false) {
                    this.destination.next(this.acc);
                }
                this.destination.complete();
            }
        };
        return MergeScanSubscriber;
    }(OuterSubscriber_1.OuterSubscriber));
    var MergeScanSubscriber_1 = MergeScanSubscriber;


    var mergeScan_1 = {
    	mergeScan: mergeScan_2,
    	MergeScanOperator: MergeScanOperator_1,
    	MergeScanSubscriber: MergeScanSubscriber_1
    };

    /**
     * Applies an accumulator function over the source Observable where the
     * accumulator function itself returns an Observable, then each intermediate
     * Observable returned is merged into the output Observable.
     *
     * <span class="informal">It's like {@link scan}, but the Observables returned
     * by the accumulator are merged into the outer Observable.</span>
     *
     * @example <caption>Count the number of click events</caption>
     * const click$ = Rx.Observable.fromEvent(document, 'click');
     * const one$ = click$.mapTo(1);
     * const seed = 0;
     * const count$ = one$.mergeScan((acc, one) => Rx.Observable.of(acc + one), seed);
     * count$.subscribe(x => console.log(x));
     *
     * // Results:
     * 1
     * 2
     * 3
     * 4
     * // ...and so on for each click
     *
     * @param {function(acc: R, value: T): Observable<R>} accumulator
     * The accumulator function called on each source value.
     * @param seed The initial accumulation value.
     * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of
     * input Observables being subscribed to concurrently.
     * @return {Observable<R>} An observable of the accumulated values.
     * @method mergeScan
     * @owner Observable
     */
    function mergeScan$1(accumulator, seed, concurrent) {
        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
        return mergeScan_1.mergeScan(accumulator, seed, concurrent)(this);
    }
    var mergeScan_3 = mergeScan$1;


    var mergeScan_2$1 = {
    	mergeScan: mergeScan_3
    };

    Observable_1.Observable.prototype.mergeScan = mergeScan_2$1.mergeScan;

    /**
     * The Min operator operates on an Observable that emits numbers (or items that can be compared with a provided function),
     * and when source Observable completes it emits a single item: the item with the smallest value.
     *
     * <img src="./img/min.png" width="100%">
     *
     * @example <caption>Get the minimal value of a series of numbers</caption>
     * Rx.Observable.of(5, 4, 7, 2, 8)
     *   .min()
     *   .subscribe(x => console.log(x)); // -> 2
     *
     * @example <caption>Use a comparer function to get the minimal item</caption>
     * interface Person {
     *   age: number,
     *   name: string
     * }
     * Observable.of<Person>({age: 7, name: 'Foo'},
     *                       {age: 5, name: 'Bar'},
     *                       {age: 9, name: 'Beer'})
     *           .min<Person>( (a: Person, b: Person) => a.age < b.age ? -1 : 1)
     *           .subscribe((x: Person) => console.log(x.name)); // -> 'Bar'
     * }
     *
     * @see {@link max}
     *
     * @param {Function} [comparer] - Optional comparer function that it will use instead of its default to compare the
     * value of two items.
     * @return {Observable<R>} An Observable that emits item with the smallest value.
     * @method min
     * @owner Observable
     */
    function min(comparer) {
        var min = (typeof comparer === 'function')
            ? function (x, y) { return comparer(x, y) < 0 ? x : y; }
            : function (x, y) { return x < y ? x : y; };
        return reduce_1.reduce(min);
    }
    var min_2 = min;


    var min_1 = {
    	min: min_2
    };

    /**
     * The Min operator operates on an Observable that emits numbers (or items that can be compared with a provided function),
     * and when source Observable completes it emits a single item: the item with the smallest value.
     *
     * <img src="./img/min.png" width="100%">
     *
     * @example <caption>Get the minimal value of a series of numbers</caption>
     * Rx.Observable.of(5, 4, 7, 2, 8)
     *   .min()
     *   .subscribe(x => console.log(x)); // -> 2
     *
     * @example <caption>Use a comparer function to get the minimal item</caption>
     * interface Person {
     *   age: number,
     *   name: string
     * }
     * Observable.of<Person>({age: 7, name: 'Foo'},
     *                       {age: 5, name: 'Bar'},
     *                       {age: 9, name: 'Beer'})
     *           .min<Person>( (a: Person, b: Person) => a.age < b.age ? -1 : 1)
     *           .subscribe((x: Person) => console.log(x.name)); // -> 'Bar'
     * }
     *
     * @see {@link max}
     *
     * @param {Function} [comparer] - Optional comparer function that it will use instead of its default to compare the
     * value of two items.
     * @return {Observable<R>} An Observable that emits item with the smallest value.
     * @method min
     * @owner Observable
     */
    function min$1(comparer) {
        return min_1.min(comparer)(this);
    }
    var min_3 = min$1;


    var min_2$1 = {
    	min: min_3
    };

    Observable_1.Observable.prototype.min = min_2$1.min;

    var __extends$1C = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };

    function refCount() {
        return function refCountOperatorFunction(source) {
            return source.lift(new RefCountOperator(source));
        };
    }
    var refCount_2 = refCount;
    var RefCountOperator = (function () {
        function RefCountOperator(connectable) {
            this.connectable = connectable;
        }
        RefCountOperator.prototype.call = function (subscriber, source) {
            var connectable = this.connectable;
            connectable._refCount++;
            var refCounter = new RefCountSubscriber(subscriber, connectable);
            var subscription = source.subscribe(refCounter);
            if (!refCounter.closed) {
                refCounter.connection = connectable.connect();
            }
            return subscription;
        };
        return RefCountOperator;
    }());
    var RefCountSubscriber = (function (_super) {
        __extends$1C(RefCountSubscriber, _super);
        function RefCountSubscriber(destination, connectable) {
            _super.call(this, destination);
            this.connectable = connectable;
        }
        /** @deprecated internal use only */ RefCountSubscriber.prototype._unsubscribe = function () {
            var connectable = this.connectable;
            if (!connectable) {
                this.connection = null;
                return;
            }
            this.connectable = null;
            var refCount = connectable._refCount;
            if (refCount <= 0) {
                this.connection = null;
                return;
            }
            connectable._refCount = refCount - 1;
            if (refCount > 1) {
                this.connection = null;
                return;
            }
            ///
            // Compare the local RefCountSubscriber's connection Subscription to the
            // connection Subscription on the shared ConnectableObservable. In cases
            // where the ConnectableObservable source synchronously emits values, and
            // the RefCountSubscriber's downstream Observers synchronously unsubscribe,
            // execution continues to here before the RefCountOperator has a chance to
            // supply the RefCountSubscriber with the shared connection Subscription.
            // For example:
            // ```
            // Observable.range(0, 10)
            //   .publish()
            //   .refCount()
            //   .take(5)
            //   .subscribe();
            // ```
            // In order to account for this case, RefCountSubscriber should only dispose
            // the ConnectableObservable's shared connection Subscription if the
            // connection Subscription exists, *and* either:
            //   a. RefCountSubscriber doesn't have a reference to the shared connection
            //      Subscription yet, or,
            //   b. RefCountSubscriber's connection Subscription reference is identical
            //      to the shared connection Subscription
            ///
            var connection = this.connection;
            var sharedConnection = connectable._connection;
            this.connection = null;
            if (sharedConnection && (!connection || sharedConnection === connection)) {
                sharedConnection.unsubscribe();
            }
        };
        return RefCountSubscriber;
    }(Subscriber_1.Subscriber));


    var refCount_1 = {
    	refCount: refCount_2
    };

    var __extends$1D = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };





    /**
     * @class ConnectableObservable<T>
     */
    var ConnectableObservable = (function (_super) {
        __extends$1D(ConnectableObservable, _super);
        function ConnectableObservable(/** @deprecated internal use only */ source, 
            /** @deprecated internal use only */ subjectFactory) {
            _super.call(this);
            this.source = source;
            this.subjectFactory = subjectFactory;
            /** @deprecated internal use only */ this._refCount = 0;
            this._isComplete = false;
        }
        /** @deprecated internal use only */ ConnectableObservable.prototype._subscribe = function (subscriber) {
            return this.getSubject().subscribe(subscriber);
        };
        /** @deprecated internal use only */ ConnectableObservable.prototype.getSubject = function () {
            var subject = this._subject;
            if (!subject || subject.isStopped) {
                this._subject = this.subjectFactory();
            }
            return this._subject;
        };
        ConnectableObservable.prototype.connect = function () {
            var connection = this._connection;
            if (!connection) {
                this._isComplete = false;
                connection = this._connection = new Subscription_1.Subscription();
                connection.add(this.source
                    .subscribe(new ConnectableSubscriber(this.getSubject(), this)));
                if (connection.closed) {
                    this._connection = null;
                    connection = Subscription_1.Subscription.EMPTY;
                }
                else {
                    this._connection = connection;
                }
            }
            return connection;
        };
        ConnectableObservable.prototype.refCount = function () {
            return refCount_1.refCount()(this);
        };
        return ConnectableObservable;
    }(Observable_1.Observable));
    var ConnectableObservable_2 = ConnectableObservable;
    var connectableProto = ConnectableObservable.prototype;
    var connectableObservableDescriptor = {
        operator: { value: null },
        _refCount: { value: 0, writable: true },
        _subject: { value: null, writable: true },
        _connection: { value: null, writable: true },
        _subscribe: { value: connectableProto._subscribe },
        _isComplete: { value: connectableProto._isComplete, writable: true },
        getSubject: { value: connectableProto.getSubject },
        connect: { value: connectableProto.connect },
        refCount: { value: connectableProto.refCount }
    };
    var ConnectableSubscriber = (function (_super) {
        __extends$1D(ConnectableSubscriber, _super);
        function ConnectableSubscriber(destination, connectable) {
            _super.call(this, destination);
            this.connectable = connectable;
        }
        ConnectableSubscriber.prototype._error = function (err) {
            this._unsubscribe();
            _super.prototype._error.call(this, err);
        };
        ConnectableSubscriber.prototype._complete = function () {
            this.connectable._isComplete = true;
            this._unsubscribe();
            _super.prototype._complete.call(this);
        };
        /** @deprecated internal use only */ ConnectableSubscriber.prototype._unsubscribe = function () {
            var connectable = this.connectable;
            if (connectable) {
                this.connectable = null;
                var connection = connectable._connection;
                connectable._refCount = 0;
                connectable._subject = null;
                connectable._connection = null;
                if (connection) {
                    connection.unsubscribe();
                }
            }
        };
        return ConnectableSubscriber;
    }(Subject_1.SubjectSubscriber));
    var RefCountSubscriber$1 = (function (_super) {
        __extends$1D(RefCountSubscriber, _super);
        function RefCountSubscriber(destination, connectable) {
            _super.call(this, destination);
            this.connectable = connectable;
        }
        /** @deprecated internal use only */ RefCountSubscriber.prototype._unsubscribe = function () {
            var connectable = this.connectable;
            if (!connectable) {
                this.connection = null;
                return;
            }
            this.connectable = null;
            var refCount = connectable._refCount;
            if (refCount <= 0) {
                this.connection = null;
                return;
            }
            connectable._refCount = refCount - 1;
            if (refCount > 1) {
                this.connection = null;
                return;
            }
            ///
            // Compare the local RefCountSubscriber's connection Subscription to the
            // connection Subscription on the shared ConnectableObservable. In cases
            // where the ConnectableObservable source synchronously emits values, and
            // the RefCountSubscriber's downstream Observers synchronously unsubscribe,
            // execution continues to here before the RefCountOperator has a chance to
            // supply the RefCountSubscriber with the shared connection Subscription.
            // For example:
            // ```
            // Observable.range(0, 10)
            //   .publish()
            //   .refCount()
            //   .take(5)
            //   .subscribe();
            // ```
            // In order to account for this case, RefCountSubscriber should only dispose
            // the ConnectableObservable's shared connection Subscription if the
            // connection Subscription exists, *and* either:
            //   a. RefCountSubscriber doesn't have a reference to the shared connection
            //      Subscription yet, or,
            //   b. RefCountSubscriber's connection Subscription reference is identical
            //      to the shared connection Subscription
            ///
            var connection = this.connection;
            var sharedConnection = connectable._connection;
            this.connection = null;
            if (sharedConnection && (!connection || sharedConnection === connection)) {
                sharedConnection.unsubscribe();
            }
        };
        return RefCountSubscriber;
    }(Subscriber_1.Subscriber));


    var ConnectableObservable_1 = {
    	ConnectableObservable: ConnectableObservable_2,
    	connectableObservableDescriptor: connectableObservableDescriptor
    };

    /* tslint:enable:max-line-length */
    /**
     * Returns an Observable that emits the results of invoking a specified selector on items
     * emitted by a ConnectableObservable that shares a single subscription to the underlying stream.
     *
     * <img src="./img/multicast.png" width="100%">
     *
     * @param {Function|Subject} subjectOrSubjectFactory - Factory function to create an intermediate subject through
     * which the source sequence's elements will be multicast to the selector function
     * or Subject to push source elements into.
     * @param {Function} [selector] - Optional selector function that can use the multicasted source stream
     * as many times as needed, without causing multiple subscriptions to the source stream.
     * Subscribers to the given source will receive all notifications of the source from the
     * time of the subscription forward.
     * @return {Observable} An Observable that emits the results of invoking the selector
     * on the items emitted by a `ConnectableObservable` that shares a single subscription to
     * the underlying stream.
     * @method multicast
     * @owner Observable
     */
    function multicast(subjectOrSubjectFactory, selector) {
        return function multicastOperatorFunction(source) {
            var subjectFactory;
            if (typeof subjectOrSubjectFactory === 'function') {
                subjectFactory = subjectOrSubjectFactory;
            }
            else {
                subjectFactory = function subjectFactory() {
                    return subjectOrSubjectFactory;
                };
            }
            if (typeof selector === 'function') {
                return source.lift(new MulticastOperator(subjectFactory, selector));
            }
            var connectable = Object.create(source, ConnectableObservable_1.connectableObservableDescriptor);
            connectable.source = source;
            connectable.subjectFactory = subjectFactory;
            return connectable;
        };
    }
    var multicast_2 = multicast;
    var MulticastOperator = (function () {
        function MulticastOperator(subjectFactory, selector) {
            this.subjectFactory = subjectFactory;
            this.selector = selector;
        }
        MulticastOperator.prototype.call = function (subscriber, source) {
            var selector = this.selector;
            var subject = this.subjectFactory();
            var subscription = selector(subject).subscribe(subscriber);
            subscription.add(source.subscribe(subject));
            return subscription;
        };
        return MulticastOperator;
    }());
    var MulticastOperator_1 = MulticastOperator;


    var multicast_1 = {
    	multicast: multicast_2,
    	MulticastOperator: MulticastOperator_1
    };

    /* tslint:enable:max-line-length */
    /**
     * Allows source Observable to be subscribed only once with a Subject of choice,
     * while still sharing its values between multiple subscribers.
     *
     * <span class="informal">Subscribe to Observable once, but send its values to multiple subscribers.</span>
     *
     * <img src="./img/multicast.png" width="100%">
     *
     * `multicast` is an operator that works in two modes.
     *
     * In the first mode you provide a single argument to it, which can be either an initialized Subject or a Subject
     * factory. As a result you will get a special kind of an Observable - a {@link ConnectableObservable}. It can be
     * subscribed multiple times, just as regular Observable, but it won't subscribe to the source Observable at that
     * moment. It will do it only if you call its `connect` method. This means you can essentially control by hand, when
     * source Observable will be actually subscribed. What is more, ConnectableObservable will share this one subscription
     * between all of its subscribers. This means that, for example, `ajax` Observable will only send a request once,
     * even though usually it would send a request per every subscriber. Since it sends a request at the moment of
     * subscription, here request would be sent when the `connect` method of a ConnectableObservable is called.
     *
     * The most common pattern of using ConnectableObservable is calling `connect` when the first consumer subscribes,
     * keeping the subscription alive while several consumers come and go and finally unsubscribing from the source
     * Observable, when the last consumer unsubscribes. To not implement that logic over and over again,
     * ConnectableObservable has a special operator, `refCount`. When called, it returns an Observable, which will count
     * the number of consumers subscribed to it and keep ConnectableObservable connected as long as there is at least
     * one consumer. So if you don't actually need to decide yourself when to connect and disconnect a
     * ConnectableObservable, use `refCount`.
     *
     * The second mode is invoked by calling `multicast` with an additional, second argument - selector function.
     * This function accepts an Observable - which basically mirrors the source Observable - and returns Observable
     * as well, which should be the input stream modified by any operators you want. Note that in this
     * mode you cannot provide initialized Subject as a first argument - it has to be a Subject factory. If
     * you provide selector function, `multicast` returns just a regular Observable, instead of ConnectableObservable.
     * Thus, as usual, each subscription to this stream triggers subscription to the source Observable. However,
     * if inside the selector function you subscribe to the input Observable multiple times, actual source stream
     * will be subscribed only once. So if you have a chain of operators that use some Observable many times,
     * but you want to subscribe to that Observable only once, this is the mode you would use.
     *
     * Subject provided as a first parameter of `multicast` is used as a proxy for the single subscription to the
     * source Observable. It means that all values from the source stream go through that Subject. Thus, if a Subject
     * has some special properties, Observable returned by `multicast` will have them as well. If you want to use
     * `multicast` with a Subject that is one of the ones included in RxJS by default - {@link Subject},
     * {@link AsyncSubject}, {@link BehaviorSubject}, or {@link ReplaySubject} - simply use {@link publish},
     * {@link publishLast}, {@link publishBehavior} or {@link publishReplay} respectively. These are actually
     * just wrappers around `multicast`, with a specific Subject hardcoded inside.
     *
     * Also, if you use {@link publish} or {@link publishReplay} with a ConnectableObservables `refCount` operator,
     * you can simply use {@link share} and {@link shareReplay} respectively, which chain these two.
     *
     * @example <caption>Use ConnectableObservable</caption>
     * const seconds = Rx.Observable.interval(1000);
     * const connectableSeconds = seconds.multicast(new Subject());
     *
     * connectableSeconds.subscribe(value => console.log('first: ' + value));
     * connectableSeconds.subscribe(value => console.log('second: ' + value));
     *
     * // At this point still nothing happens, even though we subscribed twice.
     *
     * connectableSeconds.connect();
     *
     * // From now on `seconds` are being logged to the console,
     * // twice per every second. `seconds` Observable was however only subscribed once,
     * // so under the hood Observable.interval had only one clock started.
     *
     * @example <caption>Use selector</caption>
     * const seconds = Rx.Observable.interval(1000);
     *
     * seconds
     *     .multicast(
     *         () => new Subject(),
     *         seconds => seconds.zip(seconds) // Usually zip would subscribe to `seconds` twice.
     *                                         // Because we are inside selector, `seconds` is subscribed once,
     *     )                                   // thus starting only one clock used internally by Observable.interval.
     *     .subscribe();
     *
     * @see {@link publish}
     * @see {@link publishLast}
     * @see {@link publishBehavior}
     * @see {@link publishReplay}
     * @see {@link share}
     * @see {@link shareReplay}
     *
     * @param {Function|Subject} subjectOrSubjectFactory - Factory function to create an intermediate Subject through
     * which the source sequence's elements will be multicast to the selector function input Observable or
     * ConnectableObservable returned by the operator.
     * @param {Function} [selector] - Optional selector function that can use the input stream
     * as many times as needed, without causing multiple subscriptions to the source stream.
     * Subscribers to the input source will receive all notifications of the source from the
     * time of the subscription forward.
     * @return {Observable<T>|ConnectableObservable<T>} An Observable that emits the results of invoking the selector
     * on the source stream or a special {@link ConnectableObservable}, if selector was not provided.
     *
     * @method multicast
     * @owner Observable
     */
    function multicast$1(subjectOrSubjectFactory, selector) {
        return multicast_1.multicast(subjectOrSubjectFactory, selector)(this);
    }
    var multicast_3 = multicast$1;


    var multicast_2$1 = {
    	multicast: multicast_3
    };

    Observable_1.Observable.prototype.multicast = multicast_2$1.multicast;

    /**
     *
     * Re-emits all notifications from source Observable with specified scheduler.
     *
     * <span class="informal">Ensure a specific scheduler is used, from outside of an Observable.</span>
     *
     * `observeOn` is an operator that accepts a scheduler as a first parameter, which will be used to reschedule
     * notifications emitted by the source Observable. It might be useful, if you do not have control over
     * internal scheduler of a given Observable, but want to control when its values are emitted nevertheless.
     *
     * Returned Observable emits the same notifications (nexted values, complete and error events) as the source Observable,
     * but rescheduled with provided scheduler. Note that this doesn't mean that source Observables internal
     * scheduler will be replaced in any way. Original scheduler still will be used, but when the source Observable emits
     * notification, it will be immediately scheduled again - this time with scheduler passed to `observeOn`.
     * An anti-pattern would be calling `observeOn` on Observable that emits lots of values synchronously, to split
     * that emissions into asynchronous chunks. For this to happen, scheduler would have to be passed into the source
     * Observable directly (usually into the operator that creates it). `observeOn` simply delays notifications a
     * little bit more, to ensure that they are emitted at expected moments.
     *
     * As a matter of fact, `observeOn` accepts second parameter, which specifies in milliseconds with what delay notifications
     * will be emitted. The main difference between {@link delay} operator and `observeOn` is that `observeOn`
     * will delay all notifications - including error notifications - while `delay` will pass through error
     * from source Observable immediately when it is emitted. In general it is highly recommended to use `delay` operator
     * for any kind of delaying of values in the stream, while using `observeOn` to specify which scheduler should be used
     * for notification emissions in general.
     *
     * @example <caption>Ensure values in subscribe are called just before browser repaint.</caption>
     * const intervals = Rx.Observable.interval(10); // Intervals are scheduled
     *                                               // with async scheduler by default...
     *
     * intervals
     * .observeOn(Rx.Scheduler.animationFrame)       // ...but we will observe on animationFrame
     * .subscribe(val => {                           // scheduler to ensure smooth animation.
     *   someDiv.style.height = val + 'px';
     * });
     *
     * @see {@link delay}
     *
     * @param {IScheduler} scheduler Scheduler that will be used to reschedule notifications from source Observable.
     * @param {number} [delay] Number of milliseconds that states with what delay every notification should be rescheduled.
     * @return {Observable<T>} Observable that emits the same notifications as the source Observable,
     * but with provided scheduler.
     *
     * @method observeOn
     * @owner Observable
     */
    function observeOn$1(scheduler, delay) {
        if (delay === void 0) { delay = 0; }
        return observeOn_1.observeOn(scheduler, delay)(this);
    }
    var observeOn_3 = observeOn$1;


    var observeOn_2$1 = {
    	observeOn: observeOn_3
    };

    Observable_1.Observable.prototype.observeOn = observeOn_2$1.observeOn;

    /* tslint:enable:max-line-length */
    /**
     * When any of the provided Observable emits an complete or error notification, it immediately subscribes to the next one
     * that was passed.
     *
     * <span class="informal">Execute series of Observables no matter what, even if it means swallowing errors.</span>
     *
     * <img src="./img/onErrorResumeNext.png" width="100%">
     *
     * `onErrorResumeNext` is an operator that accepts a series of Observables, provided either directly as
     * arguments or as an array. If no single Observable is provided, returned Observable will simply behave the same
     * as the source.
     *
     * `onErrorResumeNext` returns an Observable that starts by subscribing and re-emitting values from the source Observable.
     * When its stream of values ends - no matter if Observable completed or emitted an error - `onErrorResumeNext`
     * will subscribe to the first Observable that was passed as an argument to the method. It will start re-emitting
     * its values as well and - again - when that stream ends, `onErrorResumeNext` will proceed to subscribing yet another
     * Observable in provided series, no matter if previous Observable completed or ended with an error. This will
     * be happening until there is no more Observables left in the series, at which point returned Observable will
     * complete - even if the last subscribed stream ended with an error.
     *
     * `onErrorResumeNext` can be therefore thought of as version of {@link concat} operator, which is more permissive
     * when it comes to the errors emitted by its input Observables. While `concat` subscribes to the next Observable
     * in series only if previous one successfully completed, `onErrorResumeNext` subscribes even if it ended with
     * an error.
     *
     * Note that you do not get any access to errors emitted by the Observables. In particular do not
     * expect these errors to appear in error callback passed to {@link subscribe}. If you want to take
     * specific actions based on what error was emitted by an Observable, you should try out {@link catch} instead.
     *
     *
     * @example <caption>Subscribe to the next Observable after map fails</caption>
     * Rx.Observable.of(1, 2, 3, 0)
     *   .map(x => {
     *       if (x === 0) { throw Error(); }
             return 10 / x;
     *   })
     *   .onErrorResumeNext(Rx.Observable.of(1, 2, 3))
     *   .subscribe(
     *     val => console.log(val),
     *     err => console.log(err),          // Will never be called.
     *     () => console.log('that\'s it!')
     *   );
     *
     * // Logs:
     * // 10
     * // 5
     * // 3.3333333333333335
     * // 1
     * // 2
     * // 3
     * // "that's it!"
     *
     * @see {@link concat}
     * @see {@link catch}
     *
     * @param {...ObservableInput} observables Observables passed either directly or as an array.
     * @return {Observable} An Observable that emits values from source Observable, but - if it errors - subscribes
     * to the next passed Observable and so on, until it completes or runs out of Observables.
     * @method onErrorResumeNext
     * @owner Observable
     */
    function onErrorResumeNext$3() {
        var nextSources = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            nextSources[_i - 0] = arguments[_i];
        }
        return onErrorResumeNext_1.onErrorResumeNext.apply(void 0, nextSources)(this);
    }
    var onErrorResumeNext_3 = onErrorResumeNext$3;


    var onErrorResumeNext_2$2 = {
    	onErrorResumeNext: onErrorResumeNext_3
    };

    Observable_1.Observable.prototype.onErrorResumeNext = onErrorResumeNext_2$2.onErrorResumeNext;

    var __extends$1E = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };

    /**
     * Groups pairs of consecutive emissions together and emits them as an array of
     * two values.
     *
     * <span class="informal">Puts the current value and previous value together as
     * an array, and emits that.</span>
     *
     * <img src="./img/pairwise.png" width="100%">
     *
     * The Nth emission from the source Observable will cause the output Observable
     * to emit an array [(N-1)th, Nth] of the previous and the current value, as a
     * pair. For this reason, `pairwise` emits on the second and subsequent
     * emissions from the source Observable, but not on the first emission, because
     * there is no previous value in that case.
     *
     * @example <caption>On every click (starting from the second), emit the relative distance to the previous click</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var pairs = clicks.pairwise();
     * var distance = pairs.map(pair => {
     *   var x0 = pair[0].clientX;
     *   var y0 = pair[0].clientY;
     *   var x1 = pair[1].clientX;
     *   var y1 = pair[1].clientY;
     *   return Math.sqrt(Math.pow(x0 - x1, 2) + Math.pow(y0 - y1, 2));
     * });
     * distance.subscribe(x => console.log(x));
     *
     * @see {@link buffer}
     * @see {@link bufferCount}
     *
     * @return {Observable<Array<T>>} An Observable of pairs (as arrays) of
     * consecutive values from the source Observable.
     * @method pairwise
     * @owner Observable
     */
    function pairwise() {
        return function (source) { return source.lift(new PairwiseOperator()); };
    }
    var pairwise_2 = pairwise;
    var PairwiseOperator = (function () {
        function PairwiseOperator() {
        }
        PairwiseOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(new PairwiseSubscriber(subscriber));
        };
        return PairwiseOperator;
    }());
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var PairwiseSubscriber = (function (_super) {
        __extends$1E(PairwiseSubscriber, _super);
        function PairwiseSubscriber(destination) {
            _super.call(this, destination);
            this.hasPrev = false;
        }
        PairwiseSubscriber.prototype._next = function (value) {
            if (this.hasPrev) {
                this.destination.next([this.prev, value]);
            }
            else {
                this.hasPrev = true;
            }
            this.prev = value;
        };
        return PairwiseSubscriber;
    }(Subscriber_1.Subscriber));


    var pairwise_1 = {
    	pairwise: pairwise_2
    };

    /**
     * Groups pairs of consecutive emissions together and emits them as an array of
     * two values.
     *
     * <span class="informal">Puts the current value and previous value together as
     * an array, and emits that.</span>
     *
     * <img src="./img/pairwise.png" width="100%">
     *
     * The Nth emission from the source Observable will cause the output Observable
     * to emit an array [(N-1)th, Nth] of the previous and the current value, as a
     * pair. For this reason, `pairwise` emits on the second and subsequent
     * emissions from the source Observable, but not on the first emission, because
     * there is no previous value in that case.
     *
     * @example <caption>On every click (starting from the second), emit the relative distance to the previous click</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var pairs = clicks.pairwise();
     * var distance = pairs.map(pair => {
     *   var x0 = pair[0].clientX;
     *   var y0 = pair[0].clientY;
     *   var x1 = pair[1].clientX;
     *   var y1 = pair[1].clientY;
     *   return Math.sqrt(Math.pow(x0 - x1, 2) + Math.pow(y0 - y1, 2));
     * });
     * distance.subscribe(x => console.log(x));
     *
     * @see {@link buffer}
     * @see {@link bufferCount}
     *
     * @return {Observable<Array<T>>} An Observable of pairs (as arrays) of
     * consecutive values from the source Observable.
     * @method pairwise
     * @owner Observable
     */
    function pairwise$1() {
        return pairwise_1.pairwise()(this);
    }
    var pairwise_3 = pairwise$1;


    var pairwise_2$1 = {
    	pairwise: pairwise_3
    };

    Observable_1.Observable.prototype.pairwise = pairwise_2$1.pairwise;

    function not(pred, thisArg) {
        function notPred() {
            return !(notPred.pred.apply(notPred.thisArg, arguments));
        }
        notPred.pred = pred;
        notPred.thisArg = thisArg;
        return notPred;
    }
    var not_2 = not;


    var not_1 = {
    	not: not_2
    };

    /**
     * Splits the source Observable into two, one with values that satisfy a
     * predicate, and another with values that don't satisfy the predicate.
     *
     * <span class="informal">It's like {@link filter}, but returns two Observables:
     * one like the output of {@link filter}, and the other with values that did not
     * pass the condition.</span>
     *
     * <img src="./img/partition.png" width="100%">
     *
     * `partition` outputs an array with two Observables that partition the values
     * from the source Observable through the given `predicate` function. The first
     * Observable in that array emits source values for which the predicate argument
     * returns true. The second Observable emits source values for which the
     * predicate returns false. The first behaves like {@link filter} and the second
     * behaves like {@link filter} with the predicate negated.
     *
     * @example <caption>Partition click events into those on DIV elements and those elsewhere</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var parts = clicks.partition(ev => ev.target.tagName === 'DIV');
     * var clicksOnDivs = parts[0];
     * var clicksElsewhere = parts[1];
     * clicksOnDivs.subscribe(x => console.log('DIV clicked: ', x));
     * clicksElsewhere.subscribe(x => console.log('Other clicked: ', x));
     *
     * @see {@link filter}
     *
     * @param {function(value: T, index: number): boolean} predicate A function that
     * evaluates each value emitted by the source Observable. If it returns `true`,
     * the value is emitted on the first Observable in the returned array, if
     * `false` the value is emitted on the second Observable in the array. The
     * `index` parameter is the number `i` for the i-th source emission that has
     * happened since the subscription, starting from the number `0`.
     * @param {any} [thisArg] An optional argument to determine the value of `this`
     * in the `predicate` function.
     * @return {[Observable<T>, Observable<T>]} An array with two Observables: one
     * with values that passed the predicate, and another with values that did not
     * pass the predicate.
     * @method partition
     * @owner Observable
     */
    function partition(predicate, thisArg) {
        return function (source) { return [
            filter_1.filter(predicate, thisArg)(source),
            filter_1.filter(not_1.not(predicate, thisArg))(source)
        ]; };
    }
    var partition_2 = partition;


    var partition_1 = {
    	partition: partition_2
    };

    /**
     * Splits the source Observable into two, one with values that satisfy a
     * predicate, and another with values that don't satisfy the predicate.
     *
     * <span class="informal">It's like {@link filter}, but returns two Observables:
     * one like the output of {@link filter}, and the other with values that did not
     * pass the condition.</span>
     *
     * <img src="./img/partition.png" width="100%">
     *
     * `partition` outputs an array with two Observables that partition the values
     * from the source Observable through the given `predicate` function. The first
     * Observable in that array emits source values for which the predicate argument
     * returns true. The second Observable emits source values for which the
     * predicate returns false. The first behaves like {@link filter} and the second
     * behaves like {@link filter} with the predicate negated.
     *
     * @example <caption>Partition click events into those on DIV elements and those elsewhere</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var parts = clicks.partition(ev => ev.target.tagName === 'DIV');
     * var clicksOnDivs = parts[0];
     * var clicksElsewhere = parts[1];
     * clicksOnDivs.subscribe(x => console.log('DIV clicked: ', x));
     * clicksElsewhere.subscribe(x => console.log('Other clicked: ', x));
     *
     * @see {@link filter}
     *
     * @param {function(value: T, index: number): boolean} predicate A function that
     * evaluates each value emitted by the source Observable. If it returns `true`,
     * the value is emitted on the first Observable in the returned array, if
     * `false` the value is emitted on the second Observable in the array. The
     * `index` parameter is the number `i` for the i-th source emission that has
     * happened since the subscription, starting from the number `0`.
     * @param {any} [thisArg] An optional argument to determine the value of `this`
     * in the `predicate` function.
     * @return {[Observable<T>, Observable<T>]} An array with two Observables: one
     * with values that passed the predicate, and another with values that did not
     * pass the predicate.
     * @method partition
     * @owner Observable
     */
    function partition$1(predicate, thisArg) {
        return partition_1.partition(predicate, thisArg)(this);
    }
    var partition_3 = partition$1;


    var partition_2$1 = {
    	partition: partition_3
    };

    Observable_1.Observable.prototype.partition = partition_2$1.partition;

    /**
     * Maps each source value (an object) to its specified nested property.
     *
     * <span class="informal">Like {@link map}, but meant only for picking one of
     * the nested properties of every emitted object.</span>
     *
     * <img src="./img/pluck.png" width="100%">
     *
     * Given a list of strings describing a path to an object property, retrieves
     * the value of a specified nested property from all values in the source
     * Observable. If a property can't be resolved, it will return `undefined` for
     * that value.
     *
     * @example <caption>Map every click to the tagName of the clicked target element</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var tagNames = clicks.pluck('target', 'tagName');
     * tagNames.subscribe(x => console.log(x));
     *
     * @see {@link map}
     *
     * @param {...string} properties The nested properties to pluck from each source
     * value (an object).
     * @return {Observable} A new Observable of property values from the source values.
     * @method pluck
     * @owner Observable
     */
    function pluck() {
        var properties = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            properties[_i - 0] = arguments[_i];
        }
        var length = properties.length;
        if (length === 0) {
            throw new Error('list of properties cannot be empty.');
        }
        return function (source) { return map_1.map(plucker(properties, length))(source); };
    }
    var pluck_2 = pluck;
    function plucker(props, length) {
        var mapper = function (x) {
            var currentProp = x;
            for (var i = 0; i < length; i++) {
                var p = currentProp[props[i]];
                if (typeof p !== 'undefined') {
                    currentProp = p;
                }
                else {
                    return undefined;
                }
            }
            return currentProp;
        };
        return mapper;
    }


    var pluck_1 = {
    	pluck: pluck_2
    };

    /**
     * Maps each source value (an object) to its specified nested property.
     *
     * <span class="informal">Like {@link map}, but meant only for picking one of
     * the nested properties of every emitted object.</span>
     *
     * <img src="./img/pluck.png" width="100%">
     *
     * Given a list of strings describing a path to an object property, retrieves
     * the value of a specified nested property from all values in the source
     * Observable. If a property can't be resolved, it will return `undefined` for
     * that value.
     *
     * @example <caption>Map every click to the tagName of the clicked target element</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var tagNames = clicks.pluck('target', 'tagName');
     * tagNames.subscribe(x => console.log(x));
     *
     * @see {@link map}
     *
     * @param {...string} properties The nested properties to pluck from each source
     * value (an object).
     * @return {Observable} A new Observable of property values from the source values.
     * @method pluck
     * @owner Observable
     */
    function pluck$1() {
        var properties = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            properties[_i - 0] = arguments[_i];
        }
        return pluck_1.pluck.apply(void 0, properties)(this);
    }
    var pluck_3 = pluck$1;


    var pluck_2$1 = {
    	pluck: pluck_3
    };

    Observable_1.Observable.prototype.pluck = pluck_2$1.pluck;

    /* tslint:enable:max-line-length */
    /**
     * Returns a ConnectableObservable, which is a variety of Observable that waits until its connect method is called
     * before it begins emitting items to those Observers that have subscribed to it.
     *
     * <img src="./img/publish.png" width="100%">
     *
     * @param {Function} [selector] - Optional selector function which can use the multicasted source sequence as many times
     * as needed, without causing multiple subscriptions to the source sequence.
     * Subscribers to the given source will receive all notifications of the source from the time of the subscription on.
     * @return A ConnectableObservable that upon connection causes the source Observable to emit items to its Observers.
     * @method publish
     * @owner Observable
     */
    function publish(selector) {
        return selector ?
            multicast_1.multicast(function () { return new Subject_1.Subject(); }, selector) :
            multicast_1.multicast(new Subject_1.Subject());
    }
    var publish_2 = publish;


    var publish_1 = {
    	publish: publish_2
    };

    /* tslint:enable:max-line-length */
    /**
     * Returns a ConnectableObservable, which is a variety of Observable that waits until its connect method is called
     * before it begins emitting items to those Observers that have subscribed to it.
     *
     * <img src="./img/publish.png" width="100%">
     *
     * @param {Function} [selector] - Optional selector function which can use the multicasted source sequence as many times
     * as needed, without causing multiple subscriptions to the source sequence.
     * Subscribers to the given source will receive all notifications of the source from the time of the subscription on.
     * @return A ConnectableObservable that upon connection causes the source Observable to emit items to its Observers.
     * @method publish
     * @owner Observable
     */
    function publish$1(selector) {
        return publish_1.publish(selector)(this);
    }
    var publish_3 = publish$1;


    var publish_2$1 = {
    	publish: publish_3
    };

    Observable_1.Observable.prototype.publish = publish_2$1.publish;

    var __extends$1F = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };


    /**
     * @class BehaviorSubject<T>
     */
    var BehaviorSubject = (function (_super) {
        __extends$1F(BehaviorSubject, _super);
        function BehaviorSubject(_value) {
            _super.call(this);
            this._value = _value;
        }
        Object.defineProperty(BehaviorSubject.prototype, "value", {
            get: function () {
                return this.getValue();
            },
            enumerable: true,
            configurable: true
        });
        /** @deprecated internal use only */ BehaviorSubject.prototype._subscribe = function (subscriber) {
            var subscription = _super.prototype._subscribe.call(this, subscriber);
            if (subscription && !subscription.closed) {
                subscriber.next(this._value);
            }
            return subscription;
        };
        BehaviorSubject.prototype.getValue = function () {
            if (this.hasError) {
                throw this.thrownError;
            }
            else if (this.closed) {
                throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
            }
            else {
                return this._value;
            }
        };
        BehaviorSubject.prototype.next = function (value) {
            _super.prototype.next.call(this, this._value = value);
        };
        return BehaviorSubject;
    }(Subject_1.Subject));
    var BehaviorSubject_2 = BehaviorSubject;


    var BehaviorSubject_1 = {
    	BehaviorSubject: BehaviorSubject_2
    };

    /**
     * @param value
     * @return {ConnectableObservable<T>}
     * @method publishBehavior
     * @owner Observable
     */
    function publishBehavior(value) {
        return function (source) { return multicast_1.multicast(new BehaviorSubject_1.BehaviorSubject(value))(source); };
    }
    var publishBehavior_2 = publishBehavior;


    var publishBehavior_1 = {
    	publishBehavior: publishBehavior_2
    };

    /**
     * @param value
     * @return {ConnectableObservable<T>}
     * @method publishBehavior
     * @owner Observable
     */
    function publishBehavior$1(value) {
        return publishBehavior_1.publishBehavior(value)(this);
    }
    var publishBehavior_3 = publishBehavior$1;


    var publishBehavior_2$1 = {
    	publishBehavior: publishBehavior_3
    };

    Observable_1.Observable.prototype.publishBehavior = publishBehavior_2$1.publishBehavior;

    /* tslint:enable:max-line-length */
    function publishReplay(bufferSize, windowTime, selectorOrScheduler, scheduler) {
        if (selectorOrScheduler && typeof selectorOrScheduler !== 'function') {
            scheduler = selectorOrScheduler;
        }
        var selector = typeof selectorOrScheduler === 'function' ? selectorOrScheduler : undefined;
        var subject = new ReplaySubject_1.ReplaySubject(bufferSize, windowTime, scheduler);
        return function (source) { return multicast_1.multicast(function () { return subject; }, selector)(source); };
    }
    var publishReplay_2 = publishReplay;


    var publishReplay_1 = {
    	publishReplay: publishReplay_2
    };

    /* tslint:enable:max-line-length */
    /**
     * @param bufferSize
     * @param windowTime
     * @param selectorOrScheduler
     * @param scheduler
     * @return {Observable<T> | ConnectableObservable<T>}
     * @method publishReplay
     * @owner Observable
     */
    function publishReplay$1(bufferSize, windowTime, selectorOrScheduler, scheduler) {
        return publishReplay_1.publishReplay(bufferSize, windowTime, selectorOrScheduler, scheduler)(this);
    }
    var publishReplay_3 = publishReplay$1;


    var publishReplay_2$1 = {
    	publishReplay: publishReplay_3
    };

    Observable_1.Observable.prototype.publishReplay = publishReplay_2$1.publishReplay;

    function publishLast() {
        return function (source) { return multicast_1.multicast(new AsyncSubject_1.AsyncSubject())(source); };
    }
    var publishLast_2 = publishLast;


    var publishLast_1 = {
    	publishLast: publishLast_2
    };

    /**
     * @return {ConnectableObservable<T>}
     * @method publishLast
     * @owner Observable
     */
    function publishLast$1() {
        //TODO(benlesh): correct type-flow through here.
        return publishLast_1.publishLast()(this);
    }
    var publishLast_3 = publishLast$1;


    var publishLast_2$1 = {
    	publishLast: publishLast_3
    };

    Observable_1.Observable.prototype.publishLast = publishLast_2$1.publishLast;

    /* tslint:enable:max-line-length */
    /**
     * Returns an Observable that mirrors the first source Observable to emit an item
     * from the combination of this Observable and supplied Observables.
     * @param {...Observables} ...observables Sources used to race for which Observable emits first.
     * @return {Observable} An Observable that mirrors the output of the first Observable to emit an item.
     * @method race
     * @owner Observable
     */
    function race$2() {
        var observables = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            observables[_i - 0] = arguments[_i];
        }
        return function raceOperatorFunction(source) {
            // if the only argument is an array, it was most likely called with
            // `pair([obs1, obs2, ...])`
            if (observables.length === 1 && isArray.isArray(observables[0])) {
                observables = observables[0];
            }
            return source.lift.call(race_1.race.apply(void 0, [source].concat(observables)));
        };
    }
    var race_3 = race$2;


    var race_2$1 = {
    	race: race_3
    };

    // NOTE: to support backwards compatability with 5.4.* and lower

    var raceStatic = race_1.race;
    /* tslint:enable:max-line-length */
    /**
     * Returns an Observable that mirrors the first source Observable to emit an item
     * from the combination of this Observable and supplied Observables.
     * @param {...Observables} ...observables Sources used to race for which Observable emits first.
     * @return {Observable} An Observable that mirrors the output of the first Observable to emit an item.
     * @method race
     * @owner Observable
     */
    function race$3() {
        var observables = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            observables[_i - 0] = arguments[_i];
        }
        return race_2$1.race.apply(void 0, observables)(this);
    }
    var race_4 = race$3;


    var race_3$1 = {
    	raceStatic: raceStatic,
    	race: race_4
    };

    Observable_1.Observable.prototype.race = race_3$1.race;

    /* tslint:enable:max-line-length */
    /**
     * Applies an accumulator function over the source Observable, and returns the
     * accumulated result when the source completes, given an optional seed value.
     *
     * <span class="informal">Combines together all values emitted on the source,
     * using an accumulator function that knows how to join a new source value into
     * the accumulation from the past.</span>
     *
     * <img src="./img/reduce.png" width="100%">
     *
     * Like
     * [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce),
     * `reduce` applies an `accumulator` function against an accumulation and each
     * value of the source Observable (from the past) to reduce it to a single
     * value, emitted on the output Observable. Note that `reduce` will only emit
     * one value, only when the source Observable completes. It is equivalent to
     * applying operator {@link scan} followed by operator {@link last}.
     *
     * Returns an Observable that applies a specified `accumulator` function to each
     * item emitted by the source Observable. If a `seed` value is specified, then
     * that value will be used as the initial value for the accumulator. If no seed
     * value is specified, the first item of the source is used as the seed.
     *
     * @example <caption>Count the number of click events that happened in 5 seconds</caption>
     * var clicksInFiveSeconds = Rx.Observable.fromEvent(document, 'click')
     *   .takeUntil(Rx.Observable.interval(5000));
     * var ones = clicksInFiveSeconds.mapTo(1);
     * var seed = 0;
     * var count = ones.reduce((acc, one) => acc + one, seed);
     * count.subscribe(x => console.log(x));
     *
     * @see {@link count}
     * @see {@link expand}
     * @see {@link mergeScan}
     * @see {@link scan}
     *
     * @param {function(acc: R, value: T, index: number): R} accumulator The accumulator function
     * called on each source value.
     * @param {R} [seed] The initial accumulation value.
     * @return {Observable<R>} An Observable that emits a single value that is the
     * result of accumulating the values emitted by the source Observable.
     * @method reduce
     * @owner Observable
     */
    function reduce$1(accumulator, seed) {
        // providing a seed of `undefined` *should* be valid and trigger
        // hasSeed! so don't use `seed !== undefined` checks!
        // For this reason, we have to check it here at the original call site
        // otherwise inside Operator/Subscriber we won't know if `undefined`
        // means they didn't provide anything or if they literally provided `undefined`
        if (arguments.length >= 2) {
            return reduce_1.reduce(accumulator, seed)(this);
        }
        return reduce_1.reduce(accumulator)(this);
    }
    var reduce_3 = reduce$1;


    var reduce_2$1 = {
    	reduce: reduce_3
    };

    Observable_1.Observable.prototype.reduce = reduce_2$1.reduce;

    var __extends$1G = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };


    /**
     * Returns an Observable that repeats the stream of items emitted by the source Observable at most count times.
     *
     * <img src="./img/repeat.png" width="100%">
     *
     * @param {number} [count] The number of times the source Observable items are repeated, a count of 0 will yield
     * an empty Observable.
     * @return {Observable} An Observable that repeats the stream of items emitted by the source Observable at most
     * count times.
     * @method repeat
     * @owner Observable
     */
    function repeat(count) {
        if (count === void 0) { count = -1; }
        return function (source) {
            if (count === 0) {
                return new EmptyObservable_1.EmptyObservable();
            }
            else if (count < 0) {
                return source.lift(new RepeatOperator(-1, source));
            }
            else {
                return source.lift(new RepeatOperator(count - 1, source));
            }
        };
    }
    var repeat_2 = repeat;
    var RepeatOperator = (function () {
        function RepeatOperator(count, source) {
            this.count = count;
            this.source = source;
        }
        RepeatOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(new RepeatSubscriber(subscriber, this.count, this.source));
        };
        return RepeatOperator;
    }());
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var RepeatSubscriber = (function (_super) {
        __extends$1G(RepeatSubscriber, _super);
        function RepeatSubscriber(destination, count, source) {
            _super.call(this, destination);
            this.count = count;
            this.source = source;
        }
        RepeatSubscriber.prototype.complete = function () {
            if (!this.isStopped) {
                var _a = this, source = _a.source, count = _a.count;
                if (count === 0) {
                    return _super.prototype.complete.call(this);
                }
                else if (count > -1) {
                    this.count = count - 1;
                }
                source.subscribe(this._unsubscribeAndRecycle());
            }
        };
        return RepeatSubscriber;
    }(Subscriber_1.Subscriber));


    var repeat_1 = {
    	repeat: repeat_2
    };

    /**
     * Returns an Observable that repeats the stream of items emitted by the source Observable at most count times.
     *
     * <img src="./img/repeat.png" width="100%">
     *
     * @param {number} [count] The number of times the source Observable items are repeated, a count of 0 will yield
     * an empty Observable.
     * @return {Observable} An Observable that repeats the stream of items emitted by the source Observable at most
     * count times.
     * @method repeat
     * @owner Observable
     */
    function repeat$1(count) {
        if (count === void 0) { count = -1; }
        return repeat_1.repeat(count)(this);
    }
    var repeat_3 = repeat$1;


    var repeat_2$1 = {
    	repeat: repeat_3
    };

    Observable_1.Observable.prototype.repeat = repeat_2$1.repeat;

    var __extends$1H = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };





    /**
     * Returns an Observable that mirrors the source Observable with the exception of a `complete`. If the source
     * Observable calls `complete`, this method will emit to the Observable returned from `notifier`. If that Observable
     * calls `complete` or `error`, then this method will call `complete` or `error` on the child subscription. Otherwise
     * this method will resubscribe to the source Observable.
     *
     * <img src="./img/repeatWhen.png" width="100%">
     *
     * @param {function(notifications: Observable): Observable} notifier - Receives an Observable of notifications with
     * which a user can `complete` or `error`, aborting the repetition.
     * @return {Observable} The source Observable modified with repeat logic.
     * @method repeatWhen
     * @owner Observable
     */
    function repeatWhen(notifier) {
        return function (source) { return source.lift(new RepeatWhenOperator(notifier)); };
    }
    var repeatWhen_2 = repeatWhen;
    var RepeatWhenOperator = (function () {
        function RepeatWhenOperator(notifier) {
            this.notifier = notifier;
        }
        RepeatWhenOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(new RepeatWhenSubscriber(subscriber, this.notifier, source));
        };
        return RepeatWhenOperator;
    }());
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var RepeatWhenSubscriber = (function (_super) {
        __extends$1H(RepeatWhenSubscriber, _super);
        function RepeatWhenSubscriber(destination, notifier, source) {
            _super.call(this, destination);
            this.notifier = notifier;
            this.source = source;
            this.sourceIsBeingSubscribedTo = true;
        }
        RepeatWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
            this.sourceIsBeingSubscribedTo = true;
            this.source.subscribe(this);
        };
        RepeatWhenSubscriber.prototype.notifyComplete = function (innerSub) {
            if (this.sourceIsBeingSubscribedTo === false) {
                return _super.prototype.complete.call(this);
            }
        };
        RepeatWhenSubscriber.prototype.complete = function () {
            this.sourceIsBeingSubscribedTo = false;
            if (!this.isStopped) {
                if (!this.retries) {
                    this.subscribeToRetries();
                }
                if (!this.retriesSubscription || this.retriesSubscription.closed) {
                    return _super.prototype.complete.call(this);
                }
                this._unsubscribeAndRecycle();
                this.notifications.next();
            }
        };
        /** @deprecated internal use only */ RepeatWhenSubscriber.prototype._unsubscribe = function () {
            var _a = this, notifications = _a.notifications, retriesSubscription = _a.retriesSubscription;
            if (notifications) {
                notifications.unsubscribe();
                this.notifications = null;
            }
            if (retriesSubscription) {
                retriesSubscription.unsubscribe();
                this.retriesSubscription = null;
            }
            this.retries = null;
        };
        /** @deprecated internal use only */ RepeatWhenSubscriber.prototype._unsubscribeAndRecycle = function () {
            var _a = this, notifications = _a.notifications, retries = _a.retries, retriesSubscription = _a.retriesSubscription;
            this.notifications = null;
            this.retries = null;
            this.retriesSubscription = null;
            _super.prototype._unsubscribeAndRecycle.call(this);
            this.notifications = notifications;
            this.retries = retries;
            this.retriesSubscription = retriesSubscription;
            return this;
        };
        RepeatWhenSubscriber.prototype.subscribeToRetries = function () {
            this.notifications = new Subject_1.Subject();
            var retries = tryCatch_1.tryCatch(this.notifier)(this.notifications);
            if (retries === errorObject.errorObject) {
                return _super.prototype.complete.call(this);
            }
            this.retries = retries;
            this.retriesSubscription = subscribeToResult_1.subscribeToResult(this, retries);
        };
        return RepeatWhenSubscriber;
    }(OuterSubscriber_1.OuterSubscriber));


    var repeatWhen_1 = {
    	repeatWhen: repeatWhen_2
    };

    /**
     * Returns an Observable that mirrors the source Observable with the exception of a `complete`. If the source
     * Observable calls `complete`, this method will emit to the Observable returned from `notifier`. If that Observable
     * calls `complete` or `error`, then this method will call `complete` or `error` on the child subscription. Otherwise
     * this method will resubscribe to the source Observable.
     *
     * <img src="./img/repeatWhen.png" width="100%">
     *
     * @param {function(notifications: Observable): Observable} notifier - Receives an Observable of notifications with
     * which a user can `complete` or `error`, aborting the repetition.
     * @return {Observable} The source Observable modified with repeat logic.
     * @method repeatWhen
     * @owner Observable
     */
    function repeatWhen$1(notifier) {
        return repeatWhen_1.repeatWhen(notifier)(this);
    }
    var repeatWhen_3 = repeatWhen$1;


    var repeatWhen_2$1 = {
    	repeatWhen: repeatWhen_3
    };

    Observable_1.Observable.prototype.repeatWhen = repeatWhen_2$1.repeatWhen;

    var __extends$1I = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };

    /**
     * Returns an Observable that mirrors the source Observable with the exception of an `error`. If the source Observable
     * calls `error`, this method will resubscribe to the source Observable for a maximum of `count` resubscriptions (given
     * as a number parameter) rather than propagating the `error` call.
     *
     * <img src="./img/retry.png" width="100%">
     *
     * Any and all items emitted by the source Observable will be emitted by the resulting Observable, even those emitted
     * during failed subscriptions. For example, if an Observable fails at first but emits [1, 2] then succeeds the second
     * time and emits: [1, 2, 3, 4, 5] then the complete stream of emissions and notifications
     * would be: [1, 2, 1, 2, 3, 4, 5, `complete`].
     * @param {number} count - Number of retry attempts before failing.
     * @return {Observable} The source Observable modified with the retry logic.
     * @method retry
     * @owner Observable
     */
    function retry(count) {
        if (count === void 0) { count = -1; }
        return function (source) { return source.lift(new RetryOperator(count, source)); };
    }
    var retry_2 = retry;
    var RetryOperator = (function () {
        function RetryOperator(count, source) {
            this.count = count;
            this.source = source;
        }
        RetryOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(new RetrySubscriber(subscriber, this.count, this.source));
        };
        return RetryOperator;
    }());
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var RetrySubscriber = (function (_super) {
        __extends$1I(RetrySubscriber, _super);
        function RetrySubscriber(destination, count, source) {
            _super.call(this, destination);
            this.count = count;
            this.source = source;
        }
        RetrySubscriber.prototype.error = function (err) {
            if (!this.isStopped) {
                var _a = this, source = _a.source, count = _a.count;
                if (count === 0) {
                    return _super.prototype.error.call(this, err);
                }
                else if (count > -1) {
                    this.count = count - 1;
                }
                source.subscribe(this._unsubscribeAndRecycle());
            }
        };
        return RetrySubscriber;
    }(Subscriber_1.Subscriber));


    var retry_1 = {
    	retry: retry_2
    };

    /**
     * Returns an Observable that mirrors the source Observable with the exception of an `error`. If the source Observable
     * calls `error`, this method will resubscribe to the source Observable for a maximum of `count` resubscriptions (given
     * as a number parameter) rather than propagating the `error` call.
     *
     * <img src="./img/retry.png" width="100%">
     *
     * Any and all items emitted by the source Observable will be emitted by the resulting Observable, even those emitted
     * during failed subscriptions. For example, if an Observable fails at first but emits [1, 2] then succeeds the second
     * time and emits: [1, 2, 3, 4, 5] then the complete stream of emissions and notifications
     * would be: [1, 2, 1, 2, 3, 4, 5, `complete`].
     * @param {number} count - Number of retry attempts before failing.
     * @return {Observable} The source Observable modified with the retry logic.
     * @method retry
     * @owner Observable
     */
    function retry$1(count) {
        if (count === void 0) { count = -1; }
        return retry_1.retry(count)(this);
    }
    var retry_3 = retry$1;


    var retry_2$1 = {
    	retry: retry_3
    };

    Observable_1.Observable.prototype.retry = retry_2$1.retry;

    var __extends$1J = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };





    /**
     * Returns an Observable that mirrors the source Observable with the exception of an `error`. If the source Observable
     * calls `error`, this method will emit the Throwable that caused the error to the Observable returned from `notifier`.
     * If that Observable calls `complete` or `error` then this method will call `complete` or `error` on the child
     * subscription. Otherwise this method will resubscribe to the source Observable.
     *
     * <img src="./img/retryWhen.png" width="100%">
     *
     * @param {function(errors: Observable): Observable} notifier - Receives an Observable of notifications with which a
     * user can `complete` or `error`, aborting the retry.
     * @return {Observable} The source Observable modified with retry logic.
     * @method retryWhen
     * @owner Observable
     */
    function retryWhen(notifier) {
        return function (source) { return source.lift(new RetryWhenOperator(notifier, source)); };
    }
    var retryWhen_2 = retryWhen;
    var RetryWhenOperator = (function () {
        function RetryWhenOperator(notifier, source) {
            this.notifier = notifier;
            this.source = source;
        }
        RetryWhenOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(new RetryWhenSubscriber(subscriber, this.notifier, this.source));
        };
        return RetryWhenOperator;
    }());
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var RetryWhenSubscriber = (function (_super) {
        __extends$1J(RetryWhenSubscriber, _super);
        function RetryWhenSubscriber(destination, notifier, source) {
            _super.call(this, destination);
            this.notifier = notifier;
            this.source = source;
        }
        RetryWhenSubscriber.prototype.error = function (err) {
            if (!this.isStopped) {
                var errors = this.errors;
                var retries = this.retries;
                var retriesSubscription = this.retriesSubscription;
                if (!retries) {
                    errors = new Subject_1.Subject();
                    retries = tryCatch_1.tryCatch(this.notifier)(errors);
                    if (retries === errorObject.errorObject) {
                        return _super.prototype.error.call(this, errorObject.errorObject.e);
                    }
                    retriesSubscription = subscribeToResult_1.subscribeToResult(this, retries);
                }
                else {
                    this.errors = null;
                    this.retriesSubscription = null;
                }
                this._unsubscribeAndRecycle();
                this.errors = errors;
                this.retries = retries;
                this.retriesSubscription = retriesSubscription;
                errors.next(err);
            }
        };
        /** @deprecated internal use only */ RetryWhenSubscriber.prototype._unsubscribe = function () {
            var _a = this, errors = _a.errors, retriesSubscription = _a.retriesSubscription;
            if (errors) {
                errors.unsubscribe();
                this.errors = null;
            }
            if (retriesSubscription) {
                retriesSubscription.unsubscribe();
                this.retriesSubscription = null;
            }
            this.retries = null;
        };
        RetryWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
            var _a = this, errors = _a.errors, retries = _a.retries, retriesSubscription = _a.retriesSubscription;
            this.errors = null;
            this.retries = null;
            this.retriesSubscription = null;
            this._unsubscribeAndRecycle();
            this.errors = errors;
            this.retries = retries;
            this.retriesSubscription = retriesSubscription;
            this.source.subscribe(this);
        };
        return RetryWhenSubscriber;
    }(OuterSubscriber_1.OuterSubscriber));


    var retryWhen_1 = {
    	retryWhen: retryWhen_2
    };

    /**
     * Returns an Observable that mirrors the source Observable with the exception of an `error`. If the source Observable
     * calls `error`, this method will emit the Throwable that caused the error to the Observable returned from `notifier`.
     * If that Observable calls `complete` or `error` then this method will call `complete` or `error` on the child
     * subscription. Otherwise this method will resubscribe to the source Observable.
     *
     * <img src="./img/retryWhen.png" width="100%">
     *
     * @param {function(errors: Observable): Observable} notifier - Receives an Observable of notifications with which a
     * user can `complete` or `error`, aborting the retry.
     * @return {Observable} The source Observable modified with retry logic.
     * @method retryWhen
     * @owner Observable
     */
    function retryWhen$1(notifier) {
        return retryWhen_1.retryWhen(notifier)(this);
    }
    var retryWhen_3 = retryWhen$1;


    var retryWhen_2$1 = {
    	retryWhen: retryWhen_3
    };

    Observable_1.Observable.prototype.retryWhen = retryWhen_2$1.retryWhen;

    var __extends$1K = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };


    /**
     * Emits the most recently emitted value from the source Observable whenever
     * another Observable, the `notifier`, emits.
     *
     * <span class="informal">It's like {@link sampleTime}, but samples whenever
     * the `notifier` Observable emits something.</span>
     *
     * <img src="./img/sample.png" width="100%">
     *
     * Whenever the `notifier` Observable emits a value or completes, `sample`
     * looks at the source Observable and emits whichever value it has most recently
     * emitted since the previous sampling, unless the source has not emitted
     * anything since the previous sampling. The `notifier` is subscribed to as soon
     * as the output Observable is subscribed.
     *
     * @example <caption>On every click, sample the most recent "seconds" timer</caption>
     * var seconds = Rx.Observable.interval(1000);
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var result = seconds.sample(clicks);
     * result.subscribe(x => console.log(x));
     *
     * @see {@link audit}
     * @see {@link debounce}
     * @see {@link sampleTime}
     * @see {@link throttle}
     *
     * @param {Observable<any>} notifier The Observable to use for sampling the
     * source Observable.
     * @return {Observable<T>} An Observable that emits the results of sampling the
     * values emitted by the source Observable whenever the notifier Observable
     * emits value or completes.
     * @method sample
     * @owner Observable
     */
    function sample(notifier) {
        return function (source) { return source.lift(new SampleOperator(notifier)); };
    }
    var sample_2 = sample;
    var SampleOperator = (function () {
        function SampleOperator(notifier) {
            this.notifier = notifier;
        }
        SampleOperator.prototype.call = function (subscriber, source) {
            var sampleSubscriber = new SampleSubscriber(subscriber);
            var subscription = source.subscribe(sampleSubscriber);
            subscription.add(subscribeToResult_1.subscribeToResult(sampleSubscriber, this.notifier));
            return subscription;
        };
        return SampleOperator;
    }());
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var SampleSubscriber = (function (_super) {
        __extends$1K(SampleSubscriber, _super);
        function SampleSubscriber() {
            _super.apply(this, arguments);
            this.hasValue = false;
        }
        SampleSubscriber.prototype._next = function (value) {
            this.value = value;
            this.hasValue = true;
        };
        SampleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
            this.emitValue();
        };
        SampleSubscriber.prototype.notifyComplete = function () {
            this.emitValue();
        };
        SampleSubscriber.prototype.emitValue = function () {
            if (this.hasValue) {
                this.hasValue = false;
                this.destination.next(this.value);
            }
        };
        return SampleSubscriber;
    }(OuterSubscriber_1.OuterSubscriber));


    var sample_1 = {
    	sample: sample_2
    };

    /**
     * Emits the most recently emitted value from the source Observable whenever
     * another Observable, the `notifier`, emits.
     *
     * <span class="informal">It's like {@link sampleTime}, but samples whenever
     * the `notifier` Observable emits something.</span>
     *
     * <img src="./img/sample.png" width="100%">
     *
     * Whenever the `notifier` Observable emits a value or completes, `sample`
     * looks at the source Observable and emits whichever value it has most recently
     * emitted since the previous sampling, unless the source has not emitted
     * anything since the previous sampling. The `notifier` is subscribed to as soon
     * as the output Observable is subscribed.
     *
     * @example <caption>On every click, sample the most recent "seconds" timer</caption>
     * var seconds = Rx.Observable.interval(1000);
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var result = seconds.sample(clicks);
     * result.subscribe(x => console.log(x));
     *
     * @see {@link audit}
     * @see {@link debounce}
     * @see {@link sampleTime}
     * @see {@link throttle}
     *
     * @param {Observable<any>} notifier The Observable to use for sampling the
     * source Observable.
     * @return {Observable<T>} An Observable that emits the results of sampling the
     * values emitted by the source Observable whenever the notifier Observable
     * emits value or completes.
     * @method sample
     * @owner Observable
     */
    function sample$1(notifier) {
        return sample_1.sample(notifier)(this);
    }
    var sample_3 = sample$1;


    var sample_2$1 = {
    	sample: sample_3
    };

    Observable_1.Observable.prototype.sample = sample_2$1.sample;

    var __extends$1L = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };


    /**
     * Emits the most recently emitted value from the source Observable within
     * periodic time intervals.
     *
     * <span class="informal">Samples the source Observable at periodic time
     * intervals, emitting what it samples.</span>
     *
     * <img src="./img/sampleTime.png" width="100%">
     *
     * `sampleTime` periodically looks at the source Observable and emits whichever
     * value it has most recently emitted since the previous sampling, unless the
     * source has not emitted anything since the previous sampling. The sampling
     * happens periodically in time every `period` milliseconds (or the time unit
     * defined by the optional `scheduler` argument). The sampling starts as soon as
     * the output Observable is subscribed.
     *
     * @example <caption>Every second, emit the most recent click at most once</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var result = clicks.sampleTime(1000);
     * result.subscribe(x => console.log(x));
     *
     * @see {@link auditTime}
     * @see {@link debounceTime}
     * @see {@link delay}
     * @see {@link sample}
     * @see {@link throttleTime}
     *
     * @param {number} period The sampling period expressed in milliseconds or the
     * time unit determined internally by the optional `scheduler`.
     * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for
     * managing the timers that handle the sampling.
     * @return {Observable<T>} An Observable that emits the results of sampling the
     * values emitted by the source Observable at the specified time interval.
     * @method sampleTime
     * @owner Observable
     */
    function sampleTime(period, scheduler) {
        if (scheduler === void 0) { scheduler = async.async; }
        return function (source) { return source.lift(new SampleTimeOperator(period, scheduler)); };
    }
    var sampleTime_2 = sampleTime;
    var SampleTimeOperator = (function () {
        function SampleTimeOperator(period, scheduler) {
            this.period = period;
            this.scheduler = scheduler;
        }
        SampleTimeOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(new SampleTimeSubscriber(subscriber, this.period, this.scheduler));
        };
        return SampleTimeOperator;
    }());
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var SampleTimeSubscriber = (function (_super) {
        __extends$1L(SampleTimeSubscriber, _super);
        function SampleTimeSubscriber(destination, period, scheduler) {
            _super.call(this, destination);
            this.period = period;
            this.scheduler = scheduler;
            this.hasValue = false;
            this.add(scheduler.schedule(dispatchNotification, period, { subscriber: this, period: period }));
        }
        SampleTimeSubscriber.prototype._next = function (value) {
            this.lastValue = value;
            this.hasValue = true;
        };
        SampleTimeSubscriber.prototype.notifyNext = function () {
            if (this.hasValue) {
                this.hasValue = false;
                this.destination.next(this.lastValue);
            }
        };
        return SampleTimeSubscriber;
    }(Subscriber_1.Subscriber));
    function dispatchNotification(state) {
        var subscriber = state.subscriber, period = state.period;
        subscriber.notifyNext();
        this.schedule(state, period);
    }


    var sampleTime_1 = {
    	sampleTime: sampleTime_2
    };

    /**
     * Emits the most recently emitted value from the source Observable within
     * periodic time intervals.
     *
     * <span class="informal">Samples the source Observable at periodic time
     * intervals, emitting what it samples.</span>
     *
     * <img src="./img/sampleTime.png" width="100%">
     *
     * `sampleTime` periodically looks at the source Observable and emits whichever
     * value it has most recently emitted since the previous sampling, unless the
     * source has not emitted anything since the previous sampling. The sampling
     * happens periodically in time every `period` milliseconds (or the time unit
     * defined by the optional `scheduler` argument). The sampling starts as soon as
     * the output Observable is subscribed.
     *
     * @example <caption>Every second, emit the most recent click at most once</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var result = clicks.sampleTime(1000);
     * result.subscribe(x => console.log(x));
     *
     * @see {@link auditTime}
     * @see {@link debounceTime}
     * @see {@link delay}
     * @see {@link sample}
     * @see {@link throttleTime}
     *
     * @param {number} period The sampling period expressed in milliseconds or the
     * time unit determined internally by the optional `scheduler`.
     * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for
     * managing the timers that handle the sampling.
     * @return {Observable<T>} An Observable that emits the results of sampling the
     * values emitted by the source Observable at the specified time interval.
     * @method sampleTime
     * @owner Observable
     */
    function sampleTime$1(period, scheduler) {
        if (scheduler === void 0) { scheduler = async.async; }
        return sampleTime_1.sampleTime(period, scheduler)(this);
    }
    var sampleTime_3 = sampleTime$1;


    var sampleTime_2$1 = {
    	sampleTime: sampleTime_3
    };

    Observable_1.Observable.prototype.sampleTime = sampleTime_2$1.sampleTime;

    /* tslint:enable:max-line-length */
    /**
     * Applies an accumulator function over the source Observable, and returns each
     * intermediate result, with an optional seed value.
     *
     * <span class="informal">It's like {@link reduce}, but emits the current
     * accumulation whenever the source emits a value.</span>
     *
     * <img src="./img/scan.png" width="100%">
     *
     * Combines together all values emitted on the source, using an accumulator
     * function that knows how to join a new source value into the accumulation from
     * the past. Is similar to {@link reduce}, but emits the intermediate
     * accumulations.
     *
     * Returns an Observable that applies a specified `accumulator` function to each
     * item emitted by the source Observable. If a `seed` value is specified, then
     * that value will be used as the initial value for the accumulator. If no seed
     * value is specified, the first item of the source is used as the seed.
     *
     * @example <caption>Count the number of click events</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var ones = clicks.mapTo(1);
     * var seed = 0;
     * var count = ones.scan((acc, one) => acc + one, seed);
     * count.subscribe(x => console.log(x));
     *
     * @see {@link expand}
     * @see {@link mergeScan}
     * @see {@link reduce}
     *
     * @param {function(acc: R, value: T, index: number): R} accumulator
     * The accumulator function called on each source value.
     * @param {T|R} [seed] The initial accumulation value.
     * @return {Observable<R>} An observable of the accumulated values.
     * @method scan
     * @owner Observable
     */
    function scan$1(accumulator, seed) {
        if (arguments.length >= 2) {
            return scan_1.scan(accumulator, seed)(this);
        }
        return scan_1.scan(accumulator)(this);
    }
    var scan_3 = scan$1;


    var scan_2$1 = {
    	scan: scan_3
    };

    Observable_1.Observable.prototype.scan = scan_2$1.scan;

    var __extends$1M = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };



    /**
     * Compares all values of two observables in sequence using an optional comparor function
     * and returns an observable of a single boolean value representing whether or not the two sequences
     * are equal.
     *
     * <span class="informal">Checks to see of all values emitted by both observables are equal, in order.</span>
     *
     * <img src="./img/sequenceEqual.png" width="100%">
     *
     * `sequenceEqual` subscribes to two observables and buffers incoming values from each observable. Whenever either
     * observable emits a value, the value is buffered and the buffers are shifted and compared from the bottom
     * up; If any value pair doesn't match, the returned observable will emit `false` and complete. If one of the
     * observables completes, the operator will wait for the other observable to complete; If the other
     * observable emits before completing, the returned observable will emit `false` and complete. If one observable never
     * completes or emits after the other complets, the returned observable will never complete.
     *
     * @example <caption>figure out if the Konami code matches</caption>
     * var code = Rx.Observable.from([
     *  "ArrowUp",
     *  "ArrowUp",
     *  "ArrowDown",
     *  "ArrowDown",
     *  "ArrowLeft",
     *  "ArrowRight",
     *  "ArrowLeft",
     *  "ArrowRight",
     *  "KeyB",
     *  "KeyA",
     *  "Enter" // no start key, clearly.
     * ]);
     *
     * var keys = Rx.Observable.fromEvent(document, 'keyup')
     *  .map(e => e.code);
     * var matches = keys.bufferCount(11, 1)
     *  .mergeMap(
     *    last11 =>
     *      Rx.Observable.from(last11)
     *        .sequenceEqual(code)
     *   );
     * matches.subscribe(matched => console.log('Successful cheat at Contra? ', matched));
     *
     * @see {@link combineLatest}
     * @see {@link zip}
     * @see {@link withLatestFrom}
     *
     * @param {Observable} compareTo The observable sequence to compare the source sequence to.
     * @param {function} [comparor] An optional function to compare each value pair
     * @return {Observable} An Observable of a single boolean value representing whether or not
     * the values emitted by both observables were equal in sequence.
     * @method sequenceEqual
     * @owner Observable
     */
    function sequenceEqual(compareTo, comparor) {
        return function (source) { return source.lift(new SequenceEqualOperator(compareTo, comparor)); };
    }
    var sequenceEqual_2 = sequenceEqual;
    var SequenceEqualOperator = (function () {
        function SequenceEqualOperator(compareTo, comparor) {
            this.compareTo = compareTo;
            this.comparor = comparor;
        }
        SequenceEqualOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(new SequenceEqualSubscriber(subscriber, this.compareTo, this.comparor));
        };
        return SequenceEqualOperator;
    }());
    var SequenceEqualOperator_1 = SequenceEqualOperator;
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var SequenceEqualSubscriber = (function (_super) {
        __extends$1M(SequenceEqualSubscriber, _super);
        function SequenceEqualSubscriber(destination, compareTo, comparor) {
            _super.call(this, destination);
            this.compareTo = compareTo;
            this.comparor = comparor;
            this._a = [];
            this._b = [];
            this._oneComplete = false;
            this.add(compareTo.subscribe(new SequenceEqualCompareToSubscriber(destination, this)));
        }
        SequenceEqualSubscriber.prototype._next = function (value) {
            if (this._oneComplete && this._b.length === 0) {
                this.emit(false);
            }
            else {
                this._a.push(value);
                this.checkValues();
            }
        };
        SequenceEqualSubscriber.prototype._complete = function () {
            if (this._oneComplete) {
                this.emit(this._a.length === 0 && this._b.length === 0);
            }
            else {
                this._oneComplete = true;
            }
        };
        SequenceEqualSubscriber.prototype.checkValues = function () {
            var _c = this, _a = _c._a, _b = _c._b, comparor = _c.comparor;
            while (_a.length > 0 && _b.length > 0) {
                var a = _a.shift();
                var b = _b.shift();
                var areEqual = false;
                if (comparor) {
                    areEqual = tryCatch_1.tryCatch(comparor)(a, b);
                    if (areEqual === errorObject.errorObject) {
                        this.destination.error(errorObject.errorObject.e);
                    }
                }
                else {
                    areEqual = a === b;
                }
                if (!areEqual) {
                    this.emit(false);
                }
            }
        };
        SequenceEqualSubscriber.prototype.emit = function (value) {
            var destination = this.destination;
            destination.next(value);
            destination.complete();
        };
        SequenceEqualSubscriber.prototype.nextB = function (value) {
            if (this._oneComplete && this._a.length === 0) {
                this.emit(false);
            }
            else {
                this._b.push(value);
                this.checkValues();
            }
        };
        return SequenceEqualSubscriber;
    }(Subscriber_1.Subscriber));
    var SequenceEqualSubscriber_1 = SequenceEqualSubscriber;
    var SequenceEqualCompareToSubscriber = (function (_super) {
        __extends$1M(SequenceEqualCompareToSubscriber, _super);
        function SequenceEqualCompareToSubscriber(destination, parent) {
            _super.call(this, destination);
            this.parent = parent;
        }
        SequenceEqualCompareToSubscriber.prototype._next = function (value) {
            this.parent.nextB(value);
        };
        SequenceEqualCompareToSubscriber.prototype._error = function (err) {
            this.parent.error(err);
        };
        SequenceEqualCompareToSubscriber.prototype._complete = function () {
            this.parent._complete();
        };
        return SequenceEqualCompareToSubscriber;
    }(Subscriber_1.Subscriber));


    var sequenceEqual_1 = {
    	sequenceEqual: sequenceEqual_2,
    	SequenceEqualOperator: SequenceEqualOperator_1,
    	SequenceEqualSubscriber: SequenceEqualSubscriber_1
    };

    /**
     * Compares all values of two observables in sequence using an optional comparor function
     * and returns an observable of a single boolean value representing whether or not the two sequences
     * are equal.
     *
     * <span class="informal">Checks to see of all values emitted by both observables are equal, in order.</span>
     *
     * <img src="./img/sequenceEqual.png" width="100%">
     *
     * `sequenceEqual` subscribes to two observables and buffers incoming values from each observable. Whenever either
     * observable emits a value, the value is buffered and the buffers are shifted and compared from the bottom
     * up; If any value pair doesn't match, the returned observable will emit `false` and complete. If one of the
     * observables completes, the operator will wait for the other observable to complete; If the other
     * observable emits before completing, the returned observable will emit `false` and complete. If one observable never
     * completes or emits after the other complets, the returned observable will never complete.
     *
     * @example <caption>figure out if the Konami code matches</caption>
     * var code = Rx.Observable.from([
     *  "ArrowUp",
     *  "ArrowUp",
     *  "ArrowDown",
     *  "ArrowDown",
     *  "ArrowLeft",
     *  "ArrowRight",
     *  "ArrowLeft",
     *  "ArrowRight",
     *  "KeyB",
     *  "KeyA",
     *  "Enter" // no start key, clearly.
     * ]);
     *
     * var keys = Rx.Observable.fromEvent(document, 'keyup')
     *  .map(e => e.code);
     * var matches = keys.bufferCount(11, 1)
     *  .mergeMap(
     *    last11 =>
     *      Rx.Observable.from(last11)
     *        .sequenceEqual(code)
     *   );
     * matches.subscribe(matched => console.log('Successful cheat at Contra? ', matched));
     *
     * @see {@link combineLatest}
     * @see {@link zip}
     * @see {@link withLatestFrom}
     *
     * @param {Observable} compareTo The observable sequence to compare the source sequence to.
     * @param {function} [comparor] An optional function to compare each value pair
     * @return {Observable} An Observable of a single boolean value representing whether or not
     * the values emitted by both observables were equal in sequence.
     * @method sequenceEqual
     * @owner Observable
     */
    function sequenceEqual$1(compareTo, comparor) {
        return sequenceEqual_1.sequenceEqual(compareTo, comparor)(this);
    }
    var sequenceEqual_3 = sequenceEqual$1;


    var sequenceEqual_2$1 = {
    	sequenceEqual: sequenceEqual_3
    };

    Observable_1.Observable.prototype.sequenceEqual = sequenceEqual_2$1.sequenceEqual;

    function shareSubjectFactory() {
        return new Subject_1.Subject();
    }
    /**
     * Returns a new Observable that multicasts (shares) the original Observable. As long as there is at least one
     * Subscriber this Observable will be subscribed and emitting data. When all subscribers have unsubscribed it will
     * unsubscribe from the source Observable. Because the Observable is multicasting it makes the stream `hot`.
     * This is an alias for .multicast(() => new Subject()).refCount().
     *
     * <img src="./img/share.png" width="100%">
     *
     * @return {Observable<T>} An Observable that upon connection causes the source Observable to emit items to its Observers.
     * @method share
     * @owner Observable
     */
    function share() {
        return function (source) { return refCount_1.refCount()(multicast_1.multicast(shareSubjectFactory)(source)); };
    }
    var share_2 = share;


    var share_1 = {
    	share: share_2
    };

    /**
     * Returns a new Observable that multicasts (shares) the original Observable. As long as there is at least one
     * Subscriber this Observable will be subscribed and emitting data. When all subscribers have unsubscribed it will
     * unsubscribe from the source Observable. Because the Observable is multicasting it makes the stream `hot`.
     *
     * This behaves similarly to .publish().refCount(), with a behavior difference when the source observable emits complete.
     * .publish().refCount() will not resubscribe to the original source, however .share() will resubscribe to the original source.
     * Observable.of("test").publish().refCount() will not re-emit "test" on new subscriptions, Observable.of("test").share() will
     * re-emit "test" to new subscriptions.
     *
     * <img src="./img/share.png" width="100%">
     *
     * @return {Observable<T>} An Observable that upon connection causes the source Observable to emit items to its Observers.
     * @method share
     * @owner Observable
     */
    function share$1() {
        return share_1.share()(this);
    }
    var share_3 = share$1;


    var share_2$1 = {
    	share: share_3
    };

    Observable_1.Observable.prototype.share = share_2$1.share;

    /**
     * @method shareReplay
     * @owner Observable
     */
    function shareReplay(bufferSize, windowTime, scheduler) {
        return function (source) { return source.lift(shareReplayOperator(bufferSize, windowTime, scheduler)); };
    }
    var shareReplay_2 = shareReplay;
    function shareReplayOperator(bufferSize, windowTime, scheduler) {
        var subject;
        var refCount = 0;
        var subscription;
        var hasError = false;
        var isComplete = false;
        return function shareReplayOperation(source) {
            refCount++;
            if (!subject || hasError) {
                hasError = false;
                subject = new ReplaySubject_1.ReplaySubject(bufferSize, windowTime, scheduler);
                subscription = source.subscribe({
                    next: function (value) { subject.next(value); },
                    error: function (err) {
                        hasError = true;
                        subject.error(err);
                    },
                    complete: function () {
                        isComplete = true;
                        subject.complete();
                    },
                });
            }
            var innerSub = subject.subscribe(this);
            return function () {
                refCount--;
                innerSub.unsubscribe();
                if (subscription && refCount === 0 && isComplete) {
                    subscription.unsubscribe();
                }
            };
        };
    }


    var shareReplay_1 = {
    	shareReplay: shareReplay_2
    };

    /**
     * @method shareReplay
     * @owner Observable
     */
    function shareReplay$1(bufferSize, windowTime, scheduler) {
        return shareReplay_1.shareReplay(bufferSize, windowTime, scheduler)(this);
    }
    var shareReplay_3 = shareReplay$1;


    var shareReplay_2$1 = {
    	shareReplay: shareReplay_3
    };

    Observable_1.Observable.prototype.shareReplay = shareReplay_2$1.shareReplay;

    var __extends$1N = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };


    /**
     * Returns an Observable that emits the single item emitted by the source Observable that matches a specified
     * predicate, if that Observable emits one such item. If the source Observable emits more than one such item or no
     * such items, notify of an IllegalArgumentException or NoSuchElementException respectively.
     *
     * <img src="./img/single.png" width="100%">
     *
     * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`
     * callback if the Observable completes before any `next` notification was sent.
     * @param {Function} predicate - A predicate function to evaluate items emitted by the source Observable.
     * @return {Observable<T>} An Observable that emits the single item emitted by the source Observable that matches
     * the predicate.
     .
     * @method single
     * @owner Observable
     */
    function single(predicate) {
        return function (source) { return source.lift(new SingleOperator(predicate, source)); };
    }
    var single_2 = single;
    var SingleOperator = (function () {
        function SingleOperator(predicate, source) {
            this.predicate = predicate;
            this.source = source;
        }
        SingleOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(new SingleSubscriber(subscriber, this.predicate, this.source));
        };
        return SingleOperator;
    }());
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var SingleSubscriber = (function (_super) {
        __extends$1N(SingleSubscriber, _super);
        function SingleSubscriber(destination, predicate, source) {
            _super.call(this, destination);
            this.predicate = predicate;
            this.source = source;
            this.seenValue = false;
            this.index = 0;
        }
        SingleSubscriber.prototype.applySingleValue = function (value) {
            if (this.seenValue) {
                this.destination.error('Sequence contains more than one element');
            }
            else {
                this.seenValue = true;
                this.singleValue = value;
            }
        };
        SingleSubscriber.prototype._next = function (value) {
            var index = this.index++;
            if (this.predicate) {
                this.tryNext(value, index);
            }
            else {
                this.applySingleValue(value);
            }
        };
        SingleSubscriber.prototype.tryNext = function (value, index) {
            try {
                if (this.predicate(value, index, this.source)) {
                    this.applySingleValue(value);
                }
            }
            catch (err) {
                this.destination.error(err);
            }
        };
        SingleSubscriber.prototype._complete = function () {
            var destination = this.destination;
            if (this.index > 0) {
                destination.next(this.seenValue ? this.singleValue : undefined);
                destination.complete();
            }
            else {
                destination.error(new EmptyError_1.EmptyError);
            }
        };
        return SingleSubscriber;
    }(Subscriber_1.Subscriber));


    var single_1 = {
    	single: single_2
    };

    /**
     * Returns an Observable that emits the single item emitted by the source Observable that matches a specified
     * predicate, if that Observable emits one such item. If the source Observable emits more than one such item or no
     * such items, notify of an IllegalArgumentException or NoSuchElementException respectively.
     *
     * <img src="./img/single.png" width="100%">
     *
     * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`
     * callback if the Observable completes before any `next` notification was sent.
     * @param {Function} predicate - A predicate function to evaluate items emitted by the source Observable.
     * @return {Observable<T>} An Observable that emits the single item emitted by the source Observable that matches
     * the predicate.
     .
     * @method single
     * @owner Observable
     */
    function single$1(predicate) {
        return single_1.single(predicate)(this);
    }
    var single_3 = single$1;


    var single_2$1 = {
    	single: single_3
    };

    Observable_1.Observable.prototype.single = single_2$1.single;

    var __extends$1O = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };

    /**
     * Returns an Observable that skips the first `count` items emitted by the source Observable.
     *
     * <img src="./img/skip.png" width="100%">
     *
     * @param {Number} count - The number of times, items emitted by source Observable should be skipped.
     * @return {Observable} An Observable that skips values emitted by the source Observable.
     *
     * @method skip
     * @owner Observable
     */
    function skip(count) {
        return function (source) { return source.lift(new SkipOperator(count)); };
    }
    var skip_2 = skip;
    var SkipOperator = (function () {
        function SkipOperator(total) {
            this.total = total;
        }
        SkipOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(new SkipSubscriber(subscriber, this.total));
        };
        return SkipOperator;
    }());
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var SkipSubscriber = (function (_super) {
        __extends$1O(SkipSubscriber, _super);
        function SkipSubscriber(destination, total) {
            _super.call(this, destination);
            this.total = total;
            this.count = 0;
        }
        SkipSubscriber.prototype._next = function (x) {
            if (++this.count > this.total) {
                this.destination.next(x);
            }
        };
        return SkipSubscriber;
    }(Subscriber_1.Subscriber));


    var skip_1 = {
    	skip: skip_2
    };

    /**
     * Returns an Observable that skips the first `count` items emitted by the source Observable.
     *
     * <img src="./img/skip.png" width="100%">
     *
     * @param {Number} count - The number of times, items emitted by source Observable should be skipped.
     * @return {Observable} An Observable that skips values emitted by the source Observable.
     *
     * @method skip
     * @owner Observable
     */
    function skip$1(count) {
        return skip_1.skip(count)(this);
    }
    var skip_3 = skip$1;


    var skip_2$1 = {
    	skip: skip_3
    };

    Observable_1.Observable.prototype.skip = skip_2$1.skip;

    var __extends$1P = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };


    /**
     * Skip the last `count` values emitted by the source Observable.
     *
     * <img src="./img/skipLast.png" width="100%">
     *
     * `skipLast` returns an Observable that accumulates a queue with a length
     * enough to store the first `count` values. As more values are received,
     * values are taken from the front of the queue and produced on the result
     * sequence. This causes values to be delayed.
     *
     * @example <caption>Skip the last 2 values of an Observable with many values</caption>
     * var many = Rx.Observable.range(1, 5);
     * var skipLastTwo = many.skipLast(2);
     * skipLastTwo.subscribe(x => console.log(x));
     *
     * // Results in:
     * // 1 2 3
     *
     * @see {@link skip}
     * @see {@link skipUntil}
     * @see {@link skipWhile}
     * @see {@link take}
     *
     * @throws {ArgumentOutOfRangeError} When using `skipLast(i)`, it throws
     * ArgumentOutOrRangeError if `i < 0`.
     *
     * @param {number} count Number of elements to skip from the end of the source Observable.
     * @returns {Observable<T>} An Observable that skips the last count values
     * emitted by the source Observable.
     * @method skipLast
     * @owner Observable
     */
    function skipLast(count) {
        return function (source) { return source.lift(new SkipLastOperator(count)); };
    }
    var skipLast_2 = skipLast;
    var SkipLastOperator = (function () {
        function SkipLastOperator(_skipCount) {
            this._skipCount = _skipCount;
            if (this._skipCount < 0) {
                throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;
            }
        }
        SkipLastOperator.prototype.call = function (subscriber, source) {
            if (this._skipCount === 0) {
                // If we don't want to skip any values then just subscribe
                // to Subscriber without any further logic.
                return source.subscribe(new Subscriber_1.Subscriber(subscriber));
            }
            else {
                return source.subscribe(new SkipLastSubscriber(subscriber, this._skipCount));
            }
        };
        return SkipLastOperator;
    }());
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var SkipLastSubscriber = (function (_super) {
        __extends$1P(SkipLastSubscriber, _super);
        function SkipLastSubscriber(destination, _skipCount) {
            _super.call(this, destination);
            this._skipCount = _skipCount;
            this._count = 0;
            this._ring = new Array(_skipCount);
        }
        SkipLastSubscriber.prototype._next = function (value) {
            var skipCount = this._skipCount;
            var count = this._count++;
            if (count < skipCount) {
                this._ring[count] = value;
            }
            else {
                var currentIndex = count % skipCount;
                var ring = this._ring;
                var oldValue = ring[currentIndex];
                ring[currentIndex] = value;
                this.destination.next(oldValue);
            }
        };
        return SkipLastSubscriber;
    }(Subscriber_1.Subscriber));


    var skipLast_1 = {
    	skipLast: skipLast_2
    };

    /**
     * Skip the last `count` values emitted by the source Observable.
     *
     * <img src="./img/skipLast.png" width="100%">
     *
     * `skipLast` returns an Observable that accumulates a queue with a length
     * enough to store the first `count` values. As more values are received,
     * values are taken from the front of the queue and produced on the result
     * sequence. This causes values to be delayed.
     *
     * @example <caption>Skip the last 2 values of an Observable with many values</caption>
     * var many = Rx.Observable.range(1, 5);
     * var skipLastTwo = many.skipLast(2);
     * skipLastTwo.subscribe(x => console.log(x));
     *
     * // Results in:
     * // 1 2 3
     *
     * @see {@link skip}
     * @see {@link skipUntil}
     * @see {@link skipWhile}
     * @see {@link take}
     *
     * @throws {ArgumentOutOfRangeError} When using `skipLast(i)`, it throws
     * ArgumentOutOrRangeError if `i < 0`.
     *
     * @param {number} count Number of elements to skip from the end of the source Observable.
     * @returns {Observable<T>} An Observable that skips the last count values
     * emitted by the source Observable.
     * @method skipLast
     * @owner Observable
     */
    function skipLast$1(count) {
        return skipLast_1.skipLast(count)(this);
    }
    var skipLast_3 = skipLast$1;


    var skipLast_2$1 = {
    	skipLast: skipLast_3
    };

    Observable_1.Observable.prototype.skipLast = skipLast_2$1.skipLast;

    var __extends$1Q = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };


    /**
     * Returns an Observable that skips items emitted by the source Observable until a second Observable emits an item.
     *
     * <img src="./img/skipUntil.png" width="100%">
     *
     * @param {Observable} notifier - The second Observable that has to emit an item before the source Observable's elements begin to
     * be mirrored by the resulting Observable.
     * @return {Observable<T>} An Observable that skips items from the source Observable until the second Observable emits
     * an item, then emits the remaining items.
     * @method skipUntil
     * @owner Observable
     */
    function skipUntil(notifier) {
        return function (source) { return source.lift(new SkipUntilOperator(notifier)); };
    }
    var skipUntil_2 = skipUntil;
    var SkipUntilOperator = (function () {
        function SkipUntilOperator(notifier) {
            this.notifier = notifier;
        }
        SkipUntilOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(new SkipUntilSubscriber(subscriber, this.notifier));
        };
        return SkipUntilOperator;
    }());
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var SkipUntilSubscriber = (function (_super) {
        __extends$1Q(SkipUntilSubscriber, _super);
        function SkipUntilSubscriber(destination, notifier) {
            _super.call(this, destination);
            this.hasValue = false;
            this.isInnerStopped = false;
            this.add(subscribeToResult_1.subscribeToResult(this, notifier));
        }
        SkipUntilSubscriber.prototype._next = function (value) {
            if (this.hasValue) {
                _super.prototype._next.call(this, value);
            }
        };
        SkipUntilSubscriber.prototype._complete = function () {
            if (this.isInnerStopped) {
                _super.prototype._complete.call(this);
            }
            else {
                this.unsubscribe();
            }
        };
        SkipUntilSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
            this.hasValue = true;
        };
        SkipUntilSubscriber.prototype.notifyComplete = function () {
            this.isInnerStopped = true;
            if (this.isStopped) {
                _super.prototype._complete.call(this);
            }
        };
        return SkipUntilSubscriber;
    }(OuterSubscriber_1.OuterSubscriber));


    var skipUntil_1 = {
    	skipUntil: skipUntil_2
    };

    /**
     * Returns an Observable that skips items emitted by the source Observable until a second Observable emits an item.
     *
     * <img src="./img/skipUntil.png" width="100%">
     *
     * @param {Observable} notifier - The second Observable that has to emit an item before the source Observable's elements begin to
     * be mirrored by the resulting Observable.
     * @return {Observable<T>} An Observable that skips items from the source Observable until the second Observable emits
     * an item, then emits the remaining items.
     * @method skipUntil
     * @owner Observable
     */
    function skipUntil$1(notifier) {
        return skipUntil_1.skipUntil(notifier)(this);
    }
    var skipUntil_3 = skipUntil$1;


    var skipUntil_2$1 = {
    	skipUntil: skipUntil_3
    };

    Observable_1.Observable.prototype.skipUntil = skipUntil_2$1.skipUntil;

    var __extends$1R = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };

    /**
     * Returns an Observable that skips all items emitted by the source Observable as long as a specified condition holds
     * true, but emits all further source items as soon as the condition becomes false.
     *
     * <img src="./img/skipWhile.png" width="100%">
     *
     * @param {Function} predicate - A function to test each item emitted from the source Observable.
     * @return {Observable<T>} An Observable that begins emitting items emitted by the source Observable when the
     * specified predicate becomes false.
     * @method skipWhile
     * @owner Observable
     */
    function skipWhile(predicate) {
        return function (source) { return source.lift(new SkipWhileOperator(predicate)); };
    }
    var skipWhile_2 = skipWhile;
    var SkipWhileOperator = (function () {
        function SkipWhileOperator(predicate) {
            this.predicate = predicate;
        }
        SkipWhileOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(new SkipWhileSubscriber(subscriber, this.predicate));
        };
        return SkipWhileOperator;
    }());
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var SkipWhileSubscriber = (function (_super) {
        __extends$1R(SkipWhileSubscriber, _super);
        function SkipWhileSubscriber(destination, predicate) {
            _super.call(this, destination);
            this.predicate = predicate;
            this.skipping = true;
            this.index = 0;
        }
        SkipWhileSubscriber.prototype._next = function (value) {
            var destination = this.destination;
            if (this.skipping) {
                this.tryCallPredicate(value);
            }
            if (!this.skipping) {
                destination.next(value);
            }
        };
        SkipWhileSubscriber.prototype.tryCallPredicate = function (value) {
            try {
                var result = this.predicate(value, this.index++);
                this.skipping = Boolean(result);
            }
            catch (err) {
                this.destination.error(err);
            }
        };
        return SkipWhileSubscriber;
    }(Subscriber_1.Subscriber));


    var skipWhile_1 = {
    	skipWhile: skipWhile_2
    };

    /**
     * Returns an Observable that skips all items emitted by the source Observable as long as a specified condition holds
     * true, but emits all further source items as soon as the condition becomes false.
     *
     * <img src="./img/skipWhile.png" width="100%">
     *
     * @param {Function} predicate - A function to test each item emitted from the source Observable.
     * @return {Observable<T>} An Observable that begins emitting items emitted by the source Observable when the
     * specified predicate becomes false.
     * @method skipWhile
     * @owner Observable
     */
    function skipWhile$1(predicate) {
        return skipWhile_1.skipWhile(predicate)(this);
    }
    var skipWhile_3 = skipWhile$1;


    var skipWhile_2$1 = {
    	skipWhile: skipWhile_3
    };

    Observable_1.Observable.prototype.skipWhile = skipWhile_2$1.skipWhile;

    /* tslint:enable:max-line-length */
    /**
     * Returns an Observable that emits the items you specify as arguments before it begins to emit
     * items emitted by the source Observable.
     *
     * <img src="./img/startWith.png" width="100%">
     *
     * @param {...T} values - Items you want the modified Observable to emit first.
     * @param {Scheduler} [scheduler] - A {@link IScheduler} to use for scheduling
     * the emissions of the `next` notifications.
     * @return {Observable} An Observable that emits the items in the specified Iterable and then emits the items
     * emitted by the source Observable.
     * @method startWith
     * @owner Observable
     */
    function startWith() {
        var array = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            array[_i - 0] = arguments[_i];
        }
        return function (source) {
            var scheduler = array[array.length - 1];
            if (isScheduler_1.isScheduler(scheduler)) {
                array.pop();
            }
            else {
                scheduler = null;
            }
            var len = array.length;
            if (len === 1) {
                return concat_1.concat(new ScalarObservable_1.ScalarObservable(array[0], scheduler), source);
            }
            else if (len > 1) {
                return concat_1.concat(new ArrayObservable_1.ArrayObservable(array, scheduler), source);
            }
            else {
                return concat_1.concat(new EmptyObservable_1.EmptyObservable(scheduler), source);
            }
        };
    }
    var startWith_2 = startWith;


    var startWith_1 = {
    	startWith: startWith_2
    };

    /* tslint:enable:max-line-length */
    /**
     * Returns an Observable that emits the items you specify as arguments before it begins to emit
     * items emitted by the source Observable.
     *
     * <img src="./img/startWith.png" width="100%">
     *
     * @param {...T} values - Items you want the modified Observable to emit first.
     * @param {Scheduler} [scheduler] - A {@link IScheduler} to use for scheduling
     * the emissions of the `next` notifications.
     * @return {Observable} An Observable that emits the items in the specified Iterable and then emits the items
     * emitted by the source Observable.
     * @method startWith
     * @owner Observable
     */
    function startWith$1() {
        var array = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            array[_i - 0] = arguments[_i];
        }
        return startWith_1.startWith.apply(void 0, array)(this);
    }
    var startWith_3 = startWith$1;


    var startWith_2$1 = {
    	startWith: startWith_3
    };

    Observable_1.Observable.prototype.startWith = startWith_2$1.startWith;

    var ImmediateDefinition = (function () {
        function ImmediateDefinition(root$$1) {
            this.root = root$$1;
            if (root$$1.setImmediate && typeof root$$1.setImmediate === 'function') {
                this.setImmediate = root$$1.setImmediate.bind(root$$1);
                this.clearImmediate = root$$1.clearImmediate.bind(root$$1);
            }
            else {
                this.nextHandle = 1;
                this.tasksByHandle = {};
                this.currentlyRunningATask = false;
                // Don't get fooled by e.g. browserify environments.
                if (this.canUseProcessNextTick()) {
                    // For Node.js before 0.9
                    this.setImmediate = this.createProcessNextTickSetImmediate();
                }
                else if (this.canUsePostMessage()) {
                    // For non-IE10 modern browsers
                    this.setImmediate = this.createPostMessageSetImmediate();
                }
                else if (this.canUseMessageChannel()) {
                    // For web workers, where supported
                    this.setImmediate = this.createMessageChannelSetImmediate();
                }
                else if (this.canUseReadyStateChange()) {
                    // For IE 6–8
                    this.setImmediate = this.createReadyStateChangeSetImmediate();
                }
                else {
                    // For older browsers
                    this.setImmediate = this.createSetTimeoutSetImmediate();
                }
                var ci = function clearImmediate(handle) {
                    delete clearImmediate.instance.tasksByHandle[handle];
                };
                ci.instance = this;
                this.clearImmediate = ci;
            }
        }
        ImmediateDefinition.prototype.identify = function (o) {
            return this.root.Object.prototype.toString.call(o);
        };
        ImmediateDefinition.prototype.canUseProcessNextTick = function () {
            return this.identify(this.root.process) === '[object process]';
        };
        ImmediateDefinition.prototype.canUseMessageChannel = function () {
            return Boolean(this.root.MessageChannel);
        };
        ImmediateDefinition.prototype.canUseReadyStateChange = function () {
            var document = this.root.document;
            return Boolean(document && 'onreadystatechange' in document.createElement('script'));
        };
        ImmediateDefinition.prototype.canUsePostMessage = function () {
            var root$$1 = this.root;
            // The test against `importScripts` prevents this implementation from being installed inside a web worker,
            // where `root.postMessage` means something completely different and can't be used for this purpose.
            if (root$$1.postMessage && !root$$1.importScripts) {
                var postMessageIsAsynchronous_1 = true;
                var oldOnMessage = root$$1.onmessage;
                root$$1.onmessage = function () {
                    postMessageIsAsynchronous_1 = false;
                };
                root$$1.postMessage('', '*');
                root$$1.onmessage = oldOnMessage;
                return postMessageIsAsynchronous_1;
            }
            return false;
        };
        // This function accepts the same arguments as setImmediate, but
        // returns a function that requires no arguments.
        ImmediateDefinition.prototype.partiallyApplied = function (handler) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            var fn = function result() {
                var _a = result, handler = _a.handler, args = _a.args;
                if (typeof handler === 'function') {
                    handler.apply(undefined, args);
                }
                else {
                    (new Function('' + handler))();
                }
            };
            fn.handler = handler;
            fn.args = args;
            return fn;
        };
        ImmediateDefinition.prototype.addFromSetImmediateArguments = function (args) {
            this.tasksByHandle[this.nextHandle] = this.partiallyApplied.apply(undefined, args);
            return this.nextHandle++;
        };
        ImmediateDefinition.prototype.createProcessNextTickSetImmediate = function () {
            var fn = function setImmediate() {
                var instance = setImmediate.instance;
                var handle = instance.addFromSetImmediateArguments(arguments);
                instance.root.process.nextTick(instance.partiallyApplied(instance.runIfPresent, handle));
                return handle;
            };
            fn.instance = this;
            return fn;
        };
        ImmediateDefinition.prototype.createPostMessageSetImmediate = function () {
            // Installs an event handler on `global` for the `message` event: see
            // * https://developer.mozilla.org/en/DOM/window.postMessage
            // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages
            var root$$1 = this.root;
            var messagePrefix = 'setImmediate$' + root$$1.Math.random() + '$';
            var onGlobalMessage = function globalMessageHandler(event) {
                var instance = globalMessageHandler.instance;
                if (event.source === root$$1 &&
                    typeof event.data === 'string' &&
                    event.data.indexOf(messagePrefix) === 0) {
                    instance.runIfPresent(+event.data.slice(messagePrefix.length));
                }
            };
            onGlobalMessage.instance = this;
            root$$1.addEventListener('message', onGlobalMessage, false);
            var fn = function setImmediate() {
                var _a = setImmediate, messagePrefix = _a.messagePrefix, instance = _a.instance;
                var handle = instance.addFromSetImmediateArguments(arguments);
                instance.root.postMessage(messagePrefix + handle, '*');
                return handle;
            };
            fn.instance = this;
            fn.messagePrefix = messagePrefix;
            return fn;
        };
        ImmediateDefinition.prototype.runIfPresent = function (handle) {
            // From the spec: 'Wait until any invocations of this algorithm started before this one have completed.'
            // So if we're currently running a task, we'll need to delay this invocation.
            if (this.currentlyRunningATask) {
                // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
                // 'too much recursion' error.
                this.root.setTimeout(this.partiallyApplied(this.runIfPresent, handle), 0);
            }
            else {
                var task = this.tasksByHandle[handle];
                if (task) {
                    this.currentlyRunningATask = true;
                    try {
                        task();
                    }
                    finally {
                        this.clearImmediate(handle);
                        this.currentlyRunningATask = false;
                    }
                }
            }
        };
        ImmediateDefinition.prototype.createMessageChannelSetImmediate = function () {
            var _this = this;
            var channel = new this.root.MessageChannel();
            channel.port1.onmessage = function (event) {
                var handle = event.data;
                _this.runIfPresent(handle);
            };
            var fn = function setImmediate() {
                var _a = setImmediate, channel = _a.channel, instance = _a.instance;
                var handle = instance.addFromSetImmediateArguments(arguments);
                channel.port2.postMessage(handle);
                return handle;
            };
            fn.channel = channel;
            fn.instance = this;
            return fn;
        };
        ImmediateDefinition.prototype.createReadyStateChangeSetImmediate = function () {
            var fn = function setImmediate() {
                var instance = setImmediate.instance;
                var root$$1 = instance.root;
                var doc = root$$1.document;
                var html = doc.documentElement;
                var handle = instance.addFromSetImmediateArguments(arguments);
                // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
                // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
                var script = doc.createElement('script');
                script.onreadystatechange = function () {
                    instance.runIfPresent(handle);
                    script.onreadystatechange = null;
                    html.removeChild(script);
                    script = null;
                };
                html.appendChild(script);
                return handle;
            };
            fn.instance = this;
            return fn;
        };
        ImmediateDefinition.prototype.createSetTimeoutSetImmediate = function () {
            var fn = function setImmediate() {
                var instance = setImmediate.instance;
                var handle = instance.addFromSetImmediateArguments(arguments);
                instance.root.setTimeout(instance.partiallyApplied(instance.runIfPresent, handle), 0);
                return handle;
            };
            fn.instance = this;
            return fn;
        };
        return ImmediateDefinition;
    }());
    var ImmediateDefinition_1 = ImmediateDefinition;
    var Immediate_1 = new ImmediateDefinition(root.root);


    var Immediate = {
    	ImmediateDefinition: ImmediateDefinition_1,
    	Immediate: Immediate_1
    };

    var __extends$1S = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };


    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var AsapAction = (function (_super) {
        __extends$1S(AsapAction, _super);
        function AsapAction(scheduler, work) {
            _super.call(this, scheduler, work);
            this.scheduler = scheduler;
            this.work = work;
        }
        AsapAction.prototype.requestAsyncId = function (scheduler, id, delay) {
            if (delay === void 0) { delay = 0; }
            // If delay is greater than 0, request as an async action.
            if (delay !== null && delay > 0) {
                return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
            }
            // Push the action to the end of the scheduler queue.
            scheduler.actions.push(this);
            // If a microtask has already been scheduled, don't schedule another
            // one. If a microtask hasn't been scheduled yet, schedule one now. Return
            // the current scheduled microtask id.
            return scheduler.scheduled || (scheduler.scheduled = Immediate.Immediate.setImmediate(scheduler.flush.bind(scheduler, null)));
        };
        AsapAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
            if (delay === void 0) { delay = 0; }
            // If delay exists and is greater than 0, or if the delay is null (the
            // action wasn't rescheduled) but was originally scheduled as an async
            // action, then recycle as an async action.
            if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
                return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
            }
            // If the scheduler queue is empty, cancel the requested microtask and
            // set the scheduled flag to undefined so the next AsapAction will schedule
            // its own.
            if (scheduler.actions.length === 0) {
                Immediate.Immediate.clearImmediate(id);
                scheduler.scheduled = undefined;
            }
            // Return undefined so the action knows to request a new async id if it's rescheduled.
            return undefined;
        };
        return AsapAction;
    }(AsyncAction_1.AsyncAction));
    var AsapAction_2 = AsapAction;


    var AsapAction_1 = {
    	AsapAction: AsapAction_2
    };

    var __extends$1T = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };

    var AsapScheduler = (function (_super) {
        __extends$1T(AsapScheduler, _super);
        function AsapScheduler() {
            _super.apply(this, arguments);
        }
        AsapScheduler.prototype.flush = function (action) {
            this.active = true;
            this.scheduled = undefined;
            var actions = this.actions;
            var error;
            var index = -1;
            var count = actions.length;
            action = action || actions.shift();
            do {
                if (error = action.execute(action.state, action.delay)) {
                    break;
                }
            } while (++index < count && (action = actions.shift()));
            this.active = false;
            if (error) {
                while (++index < count && (action = actions.shift())) {
                    action.unsubscribe();
                }
                throw error;
            }
        };
        return AsapScheduler;
    }(AsyncScheduler_1.AsyncScheduler));
    var AsapScheduler_2 = AsapScheduler;


    var AsapScheduler_1 = {
    	AsapScheduler: AsapScheduler_2
    };

    /**
     *
     * Asap Scheduler
     *
     * <span class="informal">Perform task as fast as it can be performed asynchronously</span>
     *
     * `asap` scheduler behaves the same as {@link async} scheduler when you use it to delay task
     * in time. If however you set delay to `0`, `asap` will wait for current synchronously executing
     * code to end and then it will try to execute given task as fast as possible.
     *
     * `asap` scheduler will do its best to minimize time between end of currently executing code
     * and start of scheduled task. This makes it best candidate for performing so called "deferring".
     * Traditionally this was achieved by calling `setTimeout(deferredTask, 0)`, but that technique involves
     * some (although minimal) unwanted delay.
     *
     * Note that using `asap` scheduler does not necessarily mean that your task will be first to process
     * after currently executing code. In particular, if some task was also scheduled with `asap` before,
     * that task will execute first. That being said, if you need to schedule task asynchronously, but
     * as soon as possible, `asap` scheduler is your best bet.
     *
     * @example <caption>Compare async and asap scheduler</caption>
     *
     * Rx.Scheduler.async.schedule(() => console.log('async')); // scheduling 'async' first...
     * Rx.Scheduler.asap.schedule(() => console.log('asap'));
     *
     * // Logs:
     * // "asap"
     * // "async"
     * // ... but 'asap' goes first!
     *
     * @static true
     * @name asap
     * @owner Scheduler
     */
    var asap_1 = new AsapScheduler_1.AsapScheduler(AsapAction_1.AsapAction);


    var asap = {
    	asap: asap_1
    };

    var __extends$1U = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };



    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @extends {Ignored}
     * @hide true
     */
    var SubscribeOnObservable = (function (_super) {
        __extends$1U(SubscribeOnObservable, _super);
        function SubscribeOnObservable(source, delayTime, scheduler) {
            if (delayTime === void 0) { delayTime = 0; }
            if (scheduler === void 0) { scheduler = asap.asap; }
            _super.call(this);
            this.source = source;
            this.delayTime = delayTime;
            this.scheduler = scheduler;
            if (!isNumeric_1.isNumeric(delayTime) || delayTime < 0) {
                this.delayTime = 0;
            }
            if (!scheduler || typeof scheduler.schedule !== 'function') {
                this.scheduler = asap.asap;
            }
        }
        SubscribeOnObservable.create = function (source, delay, scheduler) {
            if (delay === void 0) { delay = 0; }
            if (scheduler === void 0) { scheduler = asap.asap; }
            return new SubscribeOnObservable(source, delay, scheduler);
        };
        SubscribeOnObservable.dispatch = function (arg) {
            var source = arg.source, subscriber = arg.subscriber;
            return this.add(source.subscribe(subscriber));
        };
        /** @deprecated internal use only */ SubscribeOnObservable.prototype._subscribe = function (subscriber) {
            var delay = this.delayTime;
            var source = this.source;
            var scheduler = this.scheduler;
            return scheduler.schedule(SubscribeOnObservable.dispatch, delay, {
                source: source, subscriber: subscriber
            });
        };
        return SubscribeOnObservable;
    }(Observable_1.Observable));
    var SubscribeOnObservable_2 = SubscribeOnObservable;


    var SubscribeOnObservable_1 = {
    	SubscribeOnObservable: SubscribeOnObservable_2
    };

    /**
     * Asynchronously subscribes Observers to this Observable on the specified IScheduler.
     *
     * <img src="./img/subscribeOn.png" width="100%">
     *
     * @param {Scheduler} scheduler - The IScheduler to perform subscription actions on.
     * @return {Observable<T>} The source Observable modified so that its subscriptions happen on the specified IScheduler.
     .
     * @method subscribeOn
     * @owner Observable
     */
    function subscribeOn(scheduler, delay) {
        if (delay === void 0) { delay = 0; }
        return function subscribeOnOperatorFunction(source) {
            return source.lift(new SubscribeOnOperator(scheduler, delay));
        };
    }
    var subscribeOn_2 = subscribeOn;
    var SubscribeOnOperator = (function () {
        function SubscribeOnOperator(scheduler, delay) {
            this.scheduler = scheduler;
            this.delay = delay;
        }
        SubscribeOnOperator.prototype.call = function (subscriber, source) {
            return new SubscribeOnObservable_1.SubscribeOnObservable(source, this.delay, this.scheduler).subscribe(subscriber);
        };
        return SubscribeOnOperator;
    }());


    var subscribeOn_1 = {
    	subscribeOn: subscribeOn_2
    };

    /**
     * Asynchronously subscribes Observers to this Observable on the specified IScheduler.
     *
     * <img src="./img/subscribeOn.png" width="100%">
     *
     * @param {Scheduler} scheduler - The IScheduler to perform subscription actions on.
     * @return {Observable<T>} The source Observable modified so that its subscriptions happen on the specified IScheduler.
     .
     * @method subscribeOn
     * @owner Observable
     */
    function subscribeOn$1(scheduler, delay) {
        if (delay === void 0) { delay = 0; }
        return subscribeOn_1.subscribeOn(scheduler, delay)(this);
    }
    var subscribeOn_3 = subscribeOn$1;


    var subscribeOn_2$1 = {
    	subscribeOn: subscribeOn_3
    };

    Observable_1.Observable.prototype.subscribeOn = subscribeOn_2$1.subscribeOn;

    var __extends$1V = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };


    /* tslint:enable:max-line-length */
    /**
     * Projects each source value to an Observable which is merged in the output
     * Observable, emitting values only from the most recently projected Observable.
     *
     * <span class="informal">Maps each value to an Observable, then flattens all of
     * these inner Observables using {@link switch}.</span>
     *
     * <img src="./img/switchMap.png" width="100%">
     *
     * Returns an Observable that emits items based on applying a function that you
     * supply to each item emitted by the source Observable, where that function
     * returns an (so-called "inner") Observable. Each time it observes one of these
     * inner Observables, the output Observable begins emitting the items emitted by
     * that inner Observable. When a new inner Observable is emitted, `switchMap`
     * stops emitting items from the earlier-emitted inner Observable and begins
     * emitting items from the new one. It continues to behave like this for
     * subsequent inner Observables.
     *
     * @example <caption>Rerun an interval Observable on every click event</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var result = clicks.switchMap((ev) => Rx.Observable.interval(1000));
     * result.subscribe(x => console.log(x));
     *
     * @see {@link concatMap}
     * @see {@link exhaustMap}
     * @see {@link mergeMap}
     * @see {@link switch}
     * @see {@link switchMapTo}
     *
     * @param {function(value: T, ?index: number): ObservableInput} project A function
     * that, when applied to an item emitted by the source Observable, returns an
     * Observable.
     * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
     * A function to produce the value on the output Observable based on the values
     * and the indices of the source (outer) emission and the inner Observable
     * emission. The arguments passed to this function are:
     * - `outerValue`: the value that came from the source
     * - `innerValue`: the value that came from the projected Observable
     * - `outerIndex`: the "index" of the value that came from the source
     * - `innerIndex`: the "index" of the value from the projected Observable
     * @return {Observable} An Observable that emits the result of applying the
     * projection function (and the optional `resultSelector`) to each item emitted
     * by the source Observable and taking only the values from the most recently
     * projected inner Observable.
     * @method switchMap
     * @owner Observable
     */
    function switchMap(project, resultSelector) {
        return function switchMapOperatorFunction(source) {
            return source.lift(new SwitchMapOperator(project, resultSelector));
        };
    }
    var switchMap_2 = switchMap;
    var SwitchMapOperator = (function () {
        function SwitchMapOperator(project, resultSelector) {
            this.project = project;
            this.resultSelector = resultSelector;
        }
        SwitchMapOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(new SwitchMapSubscriber(subscriber, this.project, this.resultSelector));
        };
        return SwitchMapOperator;
    }());
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var SwitchMapSubscriber = (function (_super) {
        __extends$1V(SwitchMapSubscriber, _super);
        function SwitchMapSubscriber(destination, project, resultSelector) {
            _super.call(this, destination);
            this.project = project;
            this.resultSelector = resultSelector;
            this.index = 0;
        }
        SwitchMapSubscriber.prototype._next = function (value) {
            var result;
            var index = this.index++;
            try {
                result = this.project(value, index);
            }
            catch (error) {
                this.destination.error(error);
                return;
            }
            this._innerSub(result, value, index);
        };
        SwitchMapSubscriber.prototype._innerSub = function (result, value, index) {
            var innerSubscription = this.innerSubscription;
            if (innerSubscription) {
                innerSubscription.unsubscribe();
            }
            this.add(this.innerSubscription = subscribeToResult_1.subscribeToResult(this, result, value, index));
        };
        SwitchMapSubscriber.prototype._complete = function () {
            var innerSubscription = this.innerSubscription;
            if (!innerSubscription || innerSubscription.closed) {
                _super.prototype._complete.call(this);
            }
        };
        /** @deprecated internal use only */ SwitchMapSubscriber.prototype._unsubscribe = function () {
            this.innerSubscription = null;
        };
        SwitchMapSubscriber.prototype.notifyComplete = function (innerSub) {
            this.remove(innerSub);
            this.innerSubscription = null;
            if (this.isStopped) {
                _super.prototype._complete.call(this);
            }
        };
        SwitchMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
            if (this.resultSelector) {
                this._tryNotifyNext(outerValue, innerValue, outerIndex, innerIndex);
            }
            else {
                this.destination.next(innerValue);
            }
        };
        SwitchMapSubscriber.prototype._tryNotifyNext = function (outerValue, innerValue, outerIndex, innerIndex) {
            var result;
            try {
                result = this.resultSelector(outerValue, innerValue, outerIndex, innerIndex);
            }
            catch (err) {
                this.destination.error(err);
                return;
            }
            this.destination.next(result);
        };
        return SwitchMapSubscriber;
    }(OuterSubscriber_1.OuterSubscriber));


    var switchMap_1 = {
    	switchMap: switchMap_2
    };

    function switchAll() {
        return switchMap_1.switchMap(identity_1.identity);
    }
    var switchAll_2 = switchAll;


    var switchAll_1 = {
    	switchAll: switchAll_2
    };

    /**
     * Converts a higher-order Observable into a first-order Observable by
     * subscribing to only the most recently emitted of those inner Observables.
     *
     * <span class="informal">Flattens an Observable-of-Observables by dropping the
     * previous inner Observable once a new one appears.</span>
     *
     * <img src="./img/switch.png" width="100%">
     *
     * `switch` subscribes to an Observable that emits Observables, also known as a
     * higher-order Observable. Each time it observes one of these emitted inner
     * Observables, the output Observable subscribes to the inner Observable and
     * begins emitting the items emitted by that. So far, it behaves
     * like {@link mergeAll}. However, when a new inner Observable is emitted,
     * `switch` unsubscribes from the earlier-emitted inner Observable and
     * subscribes to the new inner Observable and begins emitting items from it. It
     * continues to behave like this for subsequent inner Observables.
     *
     * @example <caption>Rerun an interval Observable on every click event</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * // Each click event is mapped to an Observable that ticks every second
     * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000));
     * var switched = higherOrder.switch();
     * // The outcome is that `switched` is essentially a timer that restarts
     * // on every click. The interval Observables from older clicks do not merge
     * // with the current interval Observable.
     * switched.subscribe(x => console.log(x));
     *
     * @see {@link combineAll}
     * @see {@link concatAll}
     * @see {@link exhaust}
     * @see {@link mergeAll}
     * @see {@link switchMap}
     * @see {@link switchMapTo}
     * @see {@link zipAll}
     *
     * @return {Observable<T>} An Observable that emits the items emitted by the
     * Observable most recently emitted by the source Observable.
     * @method switch
     * @name switch
     * @owner Observable
     */
    function _switch() {
        return switchAll_1.switchAll()(this);
    }
    var _switch_2 = _switch;


    var _switch_1 = {
    	_switch: _switch_2
    };

    Observable_1.Observable.prototype.switch = _switch_1._switch;
    Observable_1.Observable.prototype._switch = _switch_1._switch;

    /* tslint:enable:max-line-length */
    /**
     * Projects each source value to an Observable which is merged in the output
     * Observable, emitting values only from the most recently projected Observable.
     *
     * <span class="informal">Maps each value to an Observable, then flattens all of
     * these inner Observables using {@link switch}.</span>
     *
     * <img src="./img/switchMap.png" width="100%">
     *
     * Returns an Observable that emits items based on applying a function that you
     * supply to each item emitted by the source Observable, where that function
     * returns an (so-called "inner") Observable. Each time it observes one of these
     * inner Observables, the output Observable begins emitting the items emitted by
     * that inner Observable. When a new inner Observable is emitted, `switchMap`
     * stops emitting items from the earlier-emitted inner Observable and begins
     * emitting items from the new one. It continues to behave like this for
     * subsequent inner Observables.
     *
     * @example <caption>Rerun an interval Observable on every click event</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var result = clicks.switchMap((ev) => Rx.Observable.interval(1000));
     * result.subscribe(x => console.log(x));
     *
     * @see {@link concatMap}
     * @see {@link exhaustMap}
     * @see {@link mergeMap}
     * @see {@link switch}
     * @see {@link switchMapTo}
     *
     * @param {function(value: T, ?index: number): ObservableInput} project A function
     * that, when applied to an item emitted by the source Observable, returns an
     * Observable.
     * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
     * A function to produce the value on the output Observable based on the values
     * and the indices of the source (outer) emission and the inner Observable
     * emission. The arguments passed to this function are:
     * - `outerValue`: the value that came from the source
     * - `innerValue`: the value that came from the projected Observable
     * - `outerIndex`: the "index" of the value that came from the source
     * - `innerIndex`: the "index" of the value from the projected Observable
     * @return {Observable} An Observable that emits the result of applying the
     * projection function (and the optional `resultSelector`) to each item emitted
     * by the source Observable and taking only the values from the most recently
     * projected inner Observable.
     * @method switchMap
     * @owner Observable
     */
    function switchMap$1(project, resultSelector) {
        return switchMap_1.switchMap(project, resultSelector)(this);
    }
    var switchMap_3 = switchMap$1;


    var switchMap_2$1 = {
    	switchMap: switchMap_3
    };

    Observable_1.Observable.prototype.switchMap = switchMap_2$1.switchMap;

    var __extends$1W = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };


    /* tslint:enable:max-line-length */
    /**
     * Projects each source value to the same Observable which is flattened multiple
     * times with {@link switch} in the output Observable.
     *
     * <span class="informal">It's like {@link switchMap}, but maps each value
     * always to the same inner Observable.</span>
     *
     * <img src="./img/switchMapTo.png" width="100%">
     *
     * Maps each source value to the given Observable `innerObservable` regardless
     * of the source value, and then flattens those resulting Observables into one
     * single Observable, which is the output Observable. The output Observables
     * emits values only from the most recently emitted instance of
     * `innerObservable`.
     *
     * @example <caption>Rerun an interval Observable on every click event</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var result = clicks.switchMapTo(Rx.Observable.interval(1000));
     * result.subscribe(x => console.log(x));
     *
     * @see {@link concatMapTo}
     * @see {@link switch}
     * @see {@link switchMap}
     * @see {@link mergeMapTo}
     *
     * @param {ObservableInput} innerObservable An Observable to replace each value from
     * the source Observable.
     * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
     * A function to produce the value on the output Observable based on the values
     * and the indices of the source (outer) emission and the inner Observable
     * emission. The arguments passed to this function are:
     * - `outerValue`: the value that came from the source
     * - `innerValue`: the value that came from the projected Observable
     * - `outerIndex`: the "index" of the value that came from the source
     * - `innerIndex`: the "index" of the value from the projected Observable
     * @return {Observable} An Observable that emits items from the given
     * `innerObservable` (and optionally transformed through `resultSelector`) every
     * time a value is emitted on the source Observable, and taking only the values
     * from the most recently projected inner Observable.
     * @method switchMapTo
     * @owner Observable
     */
    function switchMapTo(innerObservable, resultSelector) {
        return function (source) { return source.lift(new SwitchMapToOperator(innerObservable, resultSelector)); };
    }
    var switchMapTo_2 = switchMapTo;
    var SwitchMapToOperator = (function () {
        function SwitchMapToOperator(observable, resultSelector) {
            this.observable = observable;
            this.resultSelector = resultSelector;
        }
        SwitchMapToOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(new SwitchMapToSubscriber(subscriber, this.observable, this.resultSelector));
        };
        return SwitchMapToOperator;
    }());
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var SwitchMapToSubscriber = (function (_super) {
        __extends$1W(SwitchMapToSubscriber, _super);
        function SwitchMapToSubscriber(destination, inner, resultSelector) {
            _super.call(this, destination);
            this.inner = inner;
            this.resultSelector = resultSelector;
            this.index = 0;
        }
        SwitchMapToSubscriber.prototype._next = function (value) {
            var innerSubscription = this.innerSubscription;
            if (innerSubscription) {
                innerSubscription.unsubscribe();
            }
            this.add(this.innerSubscription = subscribeToResult_1.subscribeToResult(this, this.inner, value, this.index++));
        };
        SwitchMapToSubscriber.prototype._complete = function () {
            var innerSubscription = this.innerSubscription;
            if (!innerSubscription || innerSubscription.closed) {
                _super.prototype._complete.call(this);
            }
        };
        /** @deprecated internal use only */ SwitchMapToSubscriber.prototype._unsubscribe = function () {
            this.innerSubscription = null;
        };
        SwitchMapToSubscriber.prototype.notifyComplete = function (innerSub) {
            this.remove(innerSub);
            this.innerSubscription = null;
            if (this.isStopped) {
                _super.prototype._complete.call(this);
            }
        };
        SwitchMapToSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
            var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;
            if (resultSelector) {
                this.tryResultSelector(outerValue, innerValue, outerIndex, innerIndex);
            }
            else {
                destination.next(innerValue);
            }
        };
        SwitchMapToSubscriber.prototype.tryResultSelector = function (outerValue, innerValue, outerIndex, innerIndex) {
            var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;
            var result;
            try {
                result = resultSelector(outerValue, innerValue, outerIndex, innerIndex);
            }
            catch (err) {
                destination.error(err);
                return;
            }
            destination.next(result);
        };
        return SwitchMapToSubscriber;
    }(OuterSubscriber_1.OuterSubscriber));


    var switchMapTo_1 = {
    	switchMapTo: switchMapTo_2
    };

    /* tslint:enable:max-line-length */
    /**
     * Projects each source value to the same Observable which is flattened multiple
     * times with {@link switch} in the output Observable.
     *
     * <span class="informal">It's like {@link switchMap}, but maps each value
     * always to the same inner Observable.</span>
     *
     * <img src="./img/switchMapTo.png" width="100%">
     *
     * Maps each source value to the given Observable `innerObservable` regardless
     * of the source value, and then flattens those resulting Observables into one
     * single Observable, which is the output Observable. The output Observables
     * emits values only from the most recently emitted instance of
     * `innerObservable`.
     *
     * @example <caption>Rerun an interval Observable on every click event</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var result = clicks.switchMapTo(Rx.Observable.interval(1000));
     * result.subscribe(x => console.log(x));
     *
     * @see {@link concatMapTo}
     * @see {@link switch}
     * @see {@link switchMap}
     * @see {@link mergeMapTo}
     *
     * @param {ObservableInput} innerObservable An Observable to replace each value from
     * the source Observable.
     * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
     * A function to produce the value on the output Observable based on the values
     * and the indices of the source (outer) emission and the inner Observable
     * emission. The arguments passed to this function are:
     * - `outerValue`: the value that came from the source
     * - `innerValue`: the value that came from the projected Observable
     * - `outerIndex`: the "index" of the value that came from the source
     * - `innerIndex`: the "index" of the value from the projected Observable
     * @return {Observable} An Observable that emits items from the given
     * `innerObservable` (and optionally transformed through `resultSelector`) every
     * time a value is emitted on the source Observable, and taking only the values
     * from the most recently projected inner Observable.
     * @method switchMapTo
     * @owner Observable
     */
    function switchMapTo$1(innerObservable, resultSelector) {
        return switchMapTo_1.switchMapTo(innerObservable, resultSelector)(this);
    }
    var switchMapTo_3 = switchMapTo$1;


    var switchMapTo_2$1 = {
    	switchMapTo: switchMapTo_3
    };

    Observable_1.Observable.prototype.switchMapTo = switchMapTo_2$1.switchMapTo;

    var __extends$1X = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };



    /**
     * Emits only the first `count` values emitted by the source Observable.
     *
     * <span class="informal">Takes the first `count` values from the source, then
     * completes.</span>
     *
     * <img src="./img/take.png" width="100%">
     *
     * `take` returns an Observable that emits only the first `count` values emitted
     * by the source Observable. If the source emits fewer than `count` values then
     * all of its values are emitted. After that, it completes, regardless if the
     * source completes.
     *
     * @example <caption>Take the first 5 seconds of an infinite 1-second interval Observable</caption>
     * var interval = Rx.Observable.interval(1000);
     * var five = interval.take(5);
     * five.subscribe(x => console.log(x));
     *
     * @see {@link takeLast}
     * @see {@link takeUntil}
     * @see {@link takeWhile}
     * @see {@link skip}
     *
     * @throws {ArgumentOutOfRangeError} When using `take(i)`, it delivers an
     * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.
     *
     * @param {number} count The maximum number of `next` values to emit.
     * @return {Observable<T>} An Observable that emits only the first `count`
     * values emitted by the source Observable, or all of the values from the source
     * if the source emits fewer than `count` values.
     * @method take
     * @owner Observable
     */
    function take(count) {
        return function (source) {
            if (count === 0) {
                return new EmptyObservable_1.EmptyObservable();
            }
            else {
                return source.lift(new TakeOperator(count));
            }
        };
    }
    var take_2 = take;
    var TakeOperator = (function () {
        function TakeOperator(total) {
            this.total = total;
            if (this.total < 0) {
                throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;
            }
        }
        TakeOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(new TakeSubscriber(subscriber, this.total));
        };
        return TakeOperator;
    }());
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var TakeSubscriber = (function (_super) {
        __extends$1X(TakeSubscriber, _super);
        function TakeSubscriber(destination, total) {
            _super.call(this, destination);
            this.total = total;
            this.count = 0;
        }
        TakeSubscriber.prototype._next = function (value) {
            var total = this.total;
            var count = ++this.count;
            if (count <= total) {
                this.destination.next(value);
                if (count === total) {
                    this.destination.complete();
                    this.unsubscribe();
                }
            }
        };
        return TakeSubscriber;
    }(Subscriber_1.Subscriber));


    var take_1 = {
    	take: take_2
    };

    /**
     * Emits only the first `count` values emitted by the source Observable.
     *
     * <span class="informal">Takes the first `count` values from the source, then
     * completes.</span>
     *
     * <img src="./img/take.png" width="100%">
     *
     * `take` returns an Observable that emits only the first `count` values emitted
     * by the source Observable. If the source emits fewer than `count` values then
     * all of its values are emitted. After that, it completes, regardless if the
     * source completes.
     *
     * @example <caption>Take the first 5 seconds of an infinite 1-second interval Observable</caption>
     * var interval = Rx.Observable.interval(1000);
     * var five = interval.take(5);
     * five.subscribe(x => console.log(x));
     *
     * @see {@link takeLast}
     * @see {@link takeUntil}
     * @see {@link takeWhile}
     * @see {@link skip}
     *
     * @throws {ArgumentOutOfRangeError} When using `take(i)`, it delivers an
     * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.
     *
     * @param {number} count The maximum number of `next` values to emit.
     * @return {Observable<T>} An Observable that emits only the first `count`
     * values emitted by the source Observable, or all of the values from the source
     * if the source emits fewer than `count` values.
     * @method take
     * @owner Observable
     */
    function take$1(count) {
        return take_1.take(count)(this);
    }
    var take_3 = take$1;


    var take_2$1 = {
    	take: take_3
    };

    Observable_1.Observable.prototype.take = take_2$1.take;

    /**
     * Emits only the last `count` values emitted by the source Observable.
     *
     * <span class="informal">Remembers the latest `count` values, then emits those
     * only when the source completes.</span>
     *
     * <img src="./img/takeLast.png" width="100%">
     *
     * `takeLast` returns an Observable that emits at most the last `count` values
     * emitted by the source Observable. If the source emits fewer than `count`
     * values then all of its values are emitted. This operator must wait until the
     * `complete` notification emission from the source in order to emit the `next`
     * values on the output Observable, because otherwise it is impossible to know
     * whether or not more values will be emitted on the source. For this reason,
     * all values are emitted synchronously, followed by the complete notification.
     *
     * @example <caption>Take the last 3 values of an Observable with many values</caption>
     * var many = Rx.Observable.range(1, 100);
     * var lastThree = many.takeLast(3);
     * lastThree.subscribe(x => console.log(x));
     *
     * @see {@link take}
     * @see {@link takeUntil}
     * @see {@link takeWhile}
     * @see {@link skip}
     *
     * @throws {ArgumentOutOfRangeError} When using `takeLast(i)`, it delivers an
     * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.
     *
     * @param {number} count The maximum number of values to emit from the end of
     * the sequence of values emitted by the source Observable.
     * @return {Observable<T>} An Observable that emits at most the last count
     * values emitted by the source Observable.
     * @method takeLast
     * @owner Observable
     */
    function takeLast$1(count) {
        return takeLast_1.takeLast(count)(this);
    }
    var takeLast_3 = takeLast$1;


    var takeLast_2$1 = {
    	takeLast: takeLast_3
    };

    Observable_1.Observable.prototype.takeLast = takeLast_2$1.takeLast;

    var __extends$1Y = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };


    /**
     * Emits the values emitted by the source Observable until a `notifier`
     * Observable emits a value.
     *
     * <span class="informal">Lets values pass until a second Observable,
     * `notifier`, emits something. Then, it completes.</span>
     *
     * <img src="./img/takeUntil.png" width="100%">
     *
     * `takeUntil` subscribes and begins mirroring the source Observable. It also
     * monitors a second Observable, `notifier` that you provide. If the `notifier`
     * emits a value or a complete notification, the output Observable stops
     * mirroring the source Observable and completes.
     *
     * @example <caption>Tick every second until the first click happens</caption>
     * var interval = Rx.Observable.interval(1000);
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var result = interval.takeUntil(clicks);
     * result.subscribe(x => console.log(x));
     *
     * @see {@link take}
     * @see {@link takeLast}
     * @see {@link takeWhile}
     * @see {@link skip}
     *
     * @param {Observable} notifier The Observable whose first emitted value will
     * cause the output Observable of `takeUntil` to stop emitting values from the
     * source Observable.
     * @return {Observable<T>} An Observable that emits the values from the source
     * Observable until such time as `notifier` emits its first value.
     * @method takeUntil
     * @owner Observable
     */
    function takeUntil(notifier) {
        return function (source) { return source.lift(new TakeUntilOperator(notifier)); };
    }
    var takeUntil_2 = takeUntil;
    var TakeUntilOperator = (function () {
        function TakeUntilOperator(notifier) {
            this.notifier = notifier;
        }
        TakeUntilOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(new TakeUntilSubscriber(subscriber, this.notifier));
        };
        return TakeUntilOperator;
    }());
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var TakeUntilSubscriber = (function (_super) {
        __extends$1Y(TakeUntilSubscriber, _super);
        function TakeUntilSubscriber(destination, notifier) {
            _super.call(this, destination);
            this.notifier = notifier;
            this.add(subscribeToResult_1.subscribeToResult(this, notifier));
        }
        TakeUntilSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
            this.complete();
        };
        TakeUntilSubscriber.prototype.notifyComplete = function () {
            // noop
        };
        return TakeUntilSubscriber;
    }(OuterSubscriber_1.OuterSubscriber));


    var takeUntil_1 = {
    	takeUntil: takeUntil_2
    };

    /**
     * Emits the values emitted by the source Observable until a `notifier`
     * Observable emits a value.
     *
     * <span class="informal">Lets values pass until a second Observable,
     * `notifier`, emits something. Then, it completes.</span>
     *
     * <img src="./img/takeUntil.png" width="100%">
     *
     * `takeUntil` subscribes and begins mirroring the source Observable. It also
     * monitors a second Observable, `notifier` that you provide. If the `notifier`
     * emits a value, the output Observable stops mirroring the source Observable
     * and completes.
     *
     * @example <caption>Tick every second until the first click happens</caption>
     * var interval = Rx.Observable.interval(1000);
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var result = interval.takeUntil(clicks);
     * result.subscribe(x => console.log(x));
     *
     * @see {@link take}
     * @see {@link takeLast}
     * @see {@link takeWhile}
     * @see {@link skip}
     *
     * @param {Observable} notifier The Observable whose first emitted value will
     * cause the output Observable of `takeUntil` to stop emitting values from the
     * source Observable.
     * @return {Observable<T>} An Observable that emits the values from the source
     * Observable until such time as `notifier` emits its first value.
     * @method takeUntil
     * @owner Observable
     */
    function takeUntil$1(notifier) {
        return takeUntil_1.takeUntil(notifier)(this);
    }
    var takeUntil_3 = takeUntil$1;


    var takeUntil_2$1 = {
    	takeUntil: takeUntil_3
    };

    Observable_1.Observable.prototype.takeUntil = takeUntil_2$1.takeUntil;

    var __extends$1Z = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };

    /**
     * Emits values emitted by the source Observable so long as each value satisfies
     * the given `predicate`, and then completes as soon as this `predicate` is not
     * satisfied.
     *
     * <span class="informal">Takes values from the source only while they pass the
     * condition given. When the first value does not satisfy, it completes.</span>
     *
     * <img src="./img/takeWhile.png" width="100%">
     *
     * `takeWhile` subscribes and begins mirroring the source Observable. Each value
     * emitted on the source is given to the `predicate` function which returns a
     * boolean, representing a condition to be satisfied by the source values. The
     * output Observable emits the source values until such time as the `predicate`
     * returns false, at which point `takeWhile` stops mirroring the source
     * Observable and completes the output Observable.
     *
     * @example <caption>Emit click events only while the clientX property is greater than 200</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var result = clicks.takeWhile(ev => ev.clientX > 200);
     * result.subscribe(x => console.log(x));
     *
     * @see {@link take}
     * @see {@link takeLast}
     * @see {@link takeUntil}
     * @see {@link skip}
     *
     * @param {function(value: T, index: number): boolean} predicate A function that
     * evaluates a value emitted by the source Observable and returns a boolean.
     * Also takes the (zero-based) index as the second argument.
     * @return {Observable<T>} An Observable that emits the values from the source
     * Observable so long as each value satisfies the condition defined by the
     * `predicate`, then completes.
     * @method takeWhile
     * @owner Observable
     */
    function takeWhile(predicate) {
        return function (source) { return source.lift(new TakeWhileOperator(predicate)); };
    }
    var takeWhile_2 = takeWhile;
    var TakeWhileOperator = (function () {
        function TakeWhileOperator(predicate) {
            this.predicate = predicate;
        }
        TakeWhileOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(new TakeWhileSubscriber(subscriber, this.predicate));
        };
        return TakeWhileOperator;
    }());
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var TakeWhileSubscriber = (function (_super) {
        __extends$1Z(TakeWhileSubscriber, _super);
        function TakeWhileSubscriber(destination, predicate) {
            _super.call(this, destination);
            this.predicate = predicate;
            this.index = 0;
        }
        TakeWhileSubscriber.prototype._next = function (value) {
            var destination = this.destination;
            var result;
            try {
                result = this.predicate(value, this.index++);
            }
            catch (err) {
                destination.error(err);
                return;
            }
            this.nextOrComplete(value, result);
        };
        TakeWhileSubscriber.prototype.nextOrComplete = function (value, predicateResult) {
            var destination = this.destination;
            if (Boolean(predicateResult)) {
                destination.next(value);
            }
            else {
                destination.complete();
            }
        };
        return TakeWhileSubscriber;
    }(Subscriber_1.Subscriber));


    var takeWhile_1 = {
    	takeWhile: takeWhile_2
    };

    /**
     * Emits values emitted by the source Observable so long as each value satisfies
     * the given `predicate`, and then completes as soon as this `predicate` is not
     * satisfied.
     *
     * <span class="informal">Takes values from the source only while they pass the
     * condition given. When the first value does not satisfy, it completes.</span>
     *
     * <img src="./img/takeWhile.png" width="100%">
     *
     * `takeWhile` subscribes and begins mirroring the source Observable. Each value
     * emitted on the source is given to the `predicate` function which returns a
     * boolean, representing a condition to be satisfied by the source values. The
     * output Observable emits the source values until such time as the `predicate`
     * returns false, at which point `takeWhile` stops mirroring the source
     * Observable and completes the output Observable.
     *
     * @example <caption>Emit click events only while the clientX property is greater than 200</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var result = clicks.takeWhile(ev => ev.clientX > 200);
     * result.subscribe(x => console.log(x));
     *
     * @see {@link take}
     * @see {@link takeLast}
     * @see {@link takeUntil}
     * @see {@link skip}
     *
     * @param {function(value: T, index: number): boolean} predicate A function that
     * evaluates a value emitted by the source Observable and returns a boolean.
     * Also takes the (zero-based) index as the second argument.
     * @return {Observable<T>} An Observable that emits the values from the source
     * Observable so long as each value satisfies the condition defined by the
     * `predicate`, then completes.
     * @method takeWhile
     * @owner Observable
     */
    function takeWhile$1(predicate) {
        return takeWhile_1.takeWhile(predicate)(this);
    }
    var takeWhile_3 = takeWhile$1;


    var takeWhile_2$1 = {
    	takeWhile: takeWhile_3
    };

    Observable_1.Observable.prototype.takeWhile = takeWhile_2$1.takeWhile;

    var throttle_1 = createCommonjsModule(function (module, exports) {
    var __extends = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };


    exports.defaultThrottleConfig = {
        leading: true,
        trailing: false
    };
    /**
     * Emits a value from the source Observable, then ignores subsequent source
     * values for a duration determined by another Observable, then repeats this
     * process.
     *
     * <span class="informal">It's like {@link throttleTime}, but the silencing
     * duration is determined by a second Observable.</span>
     *
     * <img src="./img/throttle.png" width="100%">
     *
     * `throttle` emits the source Observable values on the output Observable
     * when its internal timer is disabled, and ignores source values when the timer
     * is enabled. Initially, the timer is disabled. As soon as the first source
     * value arrives, it is forwarded to the output Observable, and then the timer
     * is enabled by calling the `durationSelector` function with the source value,
     * which returns the "duration" Observable. When the duration Observable emits a
     * value or completes, the timer is disabled, and this process repeats for the
     * next source value.
     *
     * @example <caption>Emit clicks at a rate of at most one click per second</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var result = clicks.throttle(ev => Rx.Observable.interval(1000));
     * result.subscribe(x => console.log(x));
     *
     * @see {@link audit}
     * @see {@link debounce}
     * @see {@link delayWhen}
     * @see {@link sample}
     * @see {@link throttleTime}
     *
     * @param {function(value: T): SubscribableOrPromise} durationSelector A function
     * that receives a value from the source Observable, for computing the silencing
     * duration for each source value, returned as an Observable or a Promise.
     * @param {Object} config a configuration object to define `leading` and `trailing` behavior. Defaults
     * to `{ leading: true, trailing: false }`.
     * @return {Observable<T>} An Observable that performs the throttle operation to
     * limit the rate of emissions from the source.
     * @method throttle
     * @owner Observable
     */
    function throttle(durationSelector, config) {
        if (config === void 0) { config = exports.defaultThrottleConfig; }
        return function (source) { return source.lift(new ThrottleOperator(durationSelector, config.leading, config.trailing)); };
    }
    exports.throttle = throttle;
    var ThrottleOperator = (function () {
        function ThrottleOperator(durationSelector, leading, trailing) {
            this.durationSelector = durationSelector;
            this.leading = leading;
            this.trailing = trailing;
        }
        ThrottleOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(new ThrottleSubscriber(subscriber, this.durationSelector, this.leading, this.trailing));
        };
        return ThrottleOperator;
    }());
    /**
     * We need this JSDoc comment for affecting ESDoc
     * @ignore
     * @extends {Ignored}
     */
    var ThrottleSubscriber = (function (_super) {
        __extends(ThrottleSubscriber, _super);
        function ThrottleSubscriber(destination, durationSelector, _leading, _trailing) {
            _super.call(this, destination);
            this.destination = destination;
            this.durationSelector = durationSelector;
            this._leading = _leading;
            this._trailing = _trailing;
            this._hasTrailingValue = false;
        }
        ThrottleSubscriber.prototype._next = function (value) {
            if (this.throttled) {
                if (this._trailing) {
                    this._hasTrailingValue = true;
                    this._trailingValue = value;
                }
            }
            else {
                var duration = this.tryDurationSelector(value);
                if (duration) {
                    this.add(this.throttled = subscribeToResult_1.subscribeToResult(this, duration));
                }
                if (this._leading) {
                    this.destination.next(value);
                    if (this._trailing) {
                        this._hasTrailingValue = true;
                        this._trailingValue = value;
                    }
                }
            }
        };
        ThrottleSubscriber.prototype.tryDurationSelector = function (value) {
            try {
                return this.durationSelector(value);
            }
            catch (err) {
                this.destination.error(err);
                return null;
            }
        };
        /** @deprecated internal use only */ ThrottleSubscriber.prototype._unsubscribe = function () {
            var _a = this, throttled = _a.throttled, _trailingValue = _a._trailingValue, _hasTrailingValue = _a._hasTrailingValue, _trailing = _a._trailing;
            this._trailingValue = null;
            this._hasTrailingValue = false;
            if (throttled) {
                this.remove(throttled);
                this.throttled = null;
                throttled.unsubscribe();
            }
        };
        ThrottleSubscriber.prototype._sendTrailing = function () {
            var _a = this, destination = _a.destination, throttled = _a.throttled, _trailing = _a._trailing, _trailingValue = _a._trailingValue, _hasTrailingValue = _a._hasTrailingValue;
            if (throttled && _trailing && _hasTrailingValue) {
                destination.next(_trailingValue);
                this._trailingValue = null;
                this._hasTrailingValue = false;
            }
        };
        ThrottleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
            this._sendTrailing();
            this._unsubscribe();
        };
        ThrottleSubscriber.prototype.notifyComplete = function () {
            this._sendTrailing();
            this._unsubscribe();
        };
        return ThrottleSubscriber;
    }(OuterSubscriber_1.OuterSubscriber));

    });
    var throttle_2 = throttle_1.defaultThrottleConfig;
    var throttle_3 = throttle_1.throttle;

    /**
     * Emits a value from the source Observable, then ignores subsequent source
     * values for a duration determined by another Observable, then repeats this
     * process.
     *
     * <span class="informal">It's like {@link throttleTime}, but the silencing
     * duration is determined by a second Observable.</span>
     *
     * <img src="./img/throttle.png" width="100%">
     *
     * `throttle` emits the source Observable values on the output Observable
     * when its internal timer is disabled, and ignores source values when the timer
     * is enabled. Initially, the timer is disabled. As soon as the first source
     * value arrives, it is forwarded to the output Observable, and then the timer
     * is enabled by calling the `durationSelector` function with the source value,
     * which returns the "duration" Observable. When the duration Observable emits a
     * value or completes, the timer is disabled, and this process repeats for the
     * next source value.
     *
     * @example <caption>Emit clicks at a rate of at most one click per second</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var result = clicks.throttle(ev => Rx.Observable.interval(1000));
     * result.subscribe(x => console.log(x));
     *
     * @see {@link audit}
     * @see {@link debounce}
     * @see {@link delayWhen}
     * @see {@link sample}
     * @see {@link throttleTime}
     *
     * @param {function(value: T): SubscribableOrPromise} durationSelector A function
     * that receives a value from the source Observable, for computing the silencing
     * duration for each source value, returned as an Observable or a Promise.
     * @param {Object} config a configuration object to define `leading` and `trailing` behavior. Defaults
     * to `{ leading: true, trailing: false }`.
     * @return {Observable<T>} An Observable that performs the throttle operation to
     * limit the rate of emissions from the source.
     * @method throttle
     * @owner Observable
     */
    function throttle(durationSelector, config) {
        if (config === void 0) { config = throttle_1.defaultThrottleConfig; }
        return throttle_1.throttle(durationSelector, config)(this);
    }
    var throttle_3$1 = throttle;


    var throttle_2$1 = {
    	throttle: throttle_3$1
    };

    Observable_1.Observable.prototype.throttle = throttle_2$1.throttle;

    var __extends$1$ = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };



    /**
     * Emits a value from the source Observable, then ignores subsequent source
     * values for `duration` milliseconds, then repeats this process.
     *
     * <span class="informal">Lets a value pass, then ignores source values for the
     * next `duration` milliseconds.</span>
     *
     * <img src="./img/throttleTime.png" width="100%">
     *
     * `throttleTime` emits the source Observable values on the output Observable
     * when its internal timer is disabled, and ignores source values when the timer
     * is enabled. Initially, the timer is disabled. As soon as the first source
     * value arrives, it is forwarded to the output Observable, and then the timer
     * is enabled. After `duration` milliseconds (or the time unit determined
     * internally by the optional `scheduler`) has passed, the timer is disabled,
     * and this process repeats for the next source value. Optionally takes a
     * {@link IScheduler} for managing timers.
     *
     * @example <caption>Emit clicks at a rate of at most one click per second</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var result = clicks.throttleTime(1000);
     * result.subscribe(x => console.log(x));
     *
     * @see {@link auditTime}
     * @see {@link debounceTime}
     * @see {@link delay}
     * @see {@link sampleTime}
     * @see {@link throttle}
     *
     * @param {number} duration Time to wait before emitting another value after
     * emitting the last value, measured in milliseconds or the time unit determined
     * internally by the optional `scheduler`.
     * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for
     * managing the timers that handle the throttling.
     * @return {Observable<T>} An Observable that performs the throttle operation to
     * limit the rate of emissions from the source.
     * @method throttleTime
     * @owner Observable
     */
    function throttleTime(duration, scheduler, config) {
        if (scheduler === void 0) { scheduler = async.async; }
        if (config === void 0) { config = throttle_1.defaultThrottleConfig; }
        return function (source) { return source.lift(new ThrottleTimeOperator(duration, scheduler, config.leading, config.trailing)); };
    }
    var throttleTime_2 = throttleTime;
    var ThrottleTimeOperator = (function () {
        function ThrottleTimeOperator(duration, scheduler, leading, trailing) {
            this.duration = duration;
            this.scheduler = scheduler;
            this.leading = leading;
            this.trailing = trailing;
        }
        ThrottleTimeOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(new ThrottleTimeSubscriber(subscriber, this.duration, this.scheduler, this.leading, this.trailing));
        };
        return ThrottleTimeOperator;
    }());
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var ThrottleTimeSubscriber = (function (_super) {
        __extends$1$(ThrottleTimeSubscriber, _super);
        function ThrottleTimeSubscriber(destination, duration, scheduler, leading, trailing) {
            _super.call(this, destination);
            this.duration = duration;
            this.scheduler = scheduler;
            this.leading = leading;
            this.trailing = trailing;
            this._hasTrailingValue = false;
            this._trailingValue = null;
        }
        ThrottleTimeSubscriber.prototype._next = function (value) {
            if (this.throttled) {
                if (this.trailing) {
                    this._trailingValue = value;
                    this._hasTrailingValue = true;
                }
            }
            else {
                this.add(this.throttled = this.scheduler.schedule(dispatchNext$4, this.duration, { subscriber: this }));
                if (this.leading) {
                    this.destination.next(value);
                }
            }
        };
        ThrottleTimeSubscriber.prototype.clearThrottle = function () {
            var throttled = this.throttled;
            if (throttled) {
                if (this.trailing && this._hasTrailingValue) {
                    this.destination.next(this._trailingValue);
                    this._trailingValue = null;
                    this._hasTrailingValue = false;
                }
                throttled.unsubscribe();
                this.remove(throttled);
                this.throttled = null;
            }
        };
        return ThrottleTimeSubscriber;
    }(Subscriber_1.Subscriber));
    function dispatchNext$4(arg) {
        var subscriber = arg.subscriber;
        subscriber.clearThrottle();
    }


    var throttleTime_1 = {
    	throttleTime: throttleTime_2
    };

    /**
     * Emits a value from the source Observable, then ignores subsequent source
     * values for `duration` milliseconds, then repeats this process.
     *
     * <span class="informal">Lets a value pass, then ignores source values for the
     * next `duration` milliseconds.</span>
     *
     * <img src="./img/throttleTime.png" width="100%">
     *
     * `throttleTime` emits the source Observable values on the output Observable
     * when its internal timer is disabled, and ignores source values when the timer
     * is enabled. Initially, the timer is disabled. As soon as the first source
     * value arrives, it is forwarded to the output Observable, and then the timer
     * is enabled. After `duration` milliseconds (or the time unit determined
     * internally by the optional `scheduler`) has passed, the timer is disabled,
     * and this process repeats for the next source value. Optionally takes a
     * {@link IScheduler} for managing timers.
     *
     * @example <caption>Emit clicks at a rate of at most one click per second</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var result = clicks.throttleTime(1000);
     * result.subscribe(x => console.log(x));
     *
     * @see {@link auditTime}
     * @see {@link debounceTime}
     * @see {@link delay}
     * @see {@link sampleTime}
     * @see {@link throttle}
     *
     * @param {number} duration Time to wait before emitting another value after
     * emitting the last value, measured in milliseconds or the time unit determined
     * internally by the optional `scheduler`.
     * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for
     * managing the timers that handle the throttling.
     * @return {Observable<T>} An Observable that performs the throttle operation to
     * limit the rate of emissions from the source.
     * @method throttleTime
     * @owner Observable
     */
    function throttleTime$1(duration, scheduler, config) {
        if (scheduler === void 0) { scheduler = async.async; }
        if (config === void 0) { config = throttle_1.defaultThrottleConfig; }
        return throttleTime_1.throttleTime(duration, scheduler, config)(this);
    }
    var throttleTime_3 = throttleTime$1;


    var throttleTime_2$1 = {
    	throttleTime: throttleTime_3
    };

    Observable_1.Observable.prototype.throttleTime = throttleTime_2$1.throttleTime;

    var __extends$1_ = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };


    function timeInterval(scheduler) {
        if (scheduler === void 0) { scheduler = async.async; }
        return function (source) { return source.lift(new TimeIntervalOperator(scheduler)); };
    }
    var timeInterval_2 = timeInterval;
    var TimeInterval = (function () {
        function TimeInterval(value, interval) {
            this.value = value;
            this.interval = interval;
        }
        return TimeInterval;
    }());
    var TimeInterval_1 = TimeInterval;
    var TimeIntervalOperator = (function () {
        function TimeIntervalOperator(scheduler) {
            this.scheduler = scheduler;
        }
        TimeIntervalOperator.prototype.call = function (observer, source) {
            return source.subscribe(new TimeIntervalSubscriber(observer, this.scheduler));
        };
        return TimeIntervalOperator;
    }());
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var TimeIntervalSubscriber = (function (_super) {
        __extends$1_(TimeIntervalSubscriber, _super);
        function TimeIntervalSubscriber(destination, scheduler) {
            _super.call(this, destination);
            this.scheduler = scheduler;
            this.lastTime = 0;
            this.lastTime = scheduler.now();
        }
        TimeIntervalSubscriber.prototype._next = function (value) {
            var now = this.scheduler.now();
            var span = now - this.lastTime;
            this.lastTime = now;
            this.destination.next(new TimeInterval(value, span));
        };
        return TimeIntervalSubscriber;
    }(Subscriber_1.Subscriber));


    var timeInterval_1 = {
    	timeInterval: timeInterval_2,
    	TimeInterval: TimeInterval_1
    };

    var TimeInterval$1 = timeInterval_1.TimeInterval;
    /**
     * @param scheduler
     * @return {Observable<TimeInterval<any>>|WebSocketSubject<T>|Observable<T>}
     * @method timeInterval
     * @owner Observable
     */
    function timeInterval$1(scheduler) {
        if (scheduler === void 0) { scheduler = async.async; }
        return timeInterval_1.timeInterval(scheduler)(this);
    }
    var timeInterval_3 = timeInterval$1;


    var timeInterval_2$1 = {
    	TimeInterval: TimeInterval$1,
    	timeInterval: timeInterval_3
    };

    Observable_1.Observable.prototype.timeInterval = timeInterval_2$1.timeInterval;

    var __extends$20 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    /**
     * An error thrown when duetime elapses.
     *
     * @see {@link timeout}
     *
     * @class TimeoutError
     */
    var TimeoutError = (function (_super) {
        __extends$20(TimeoutError, _super);
        function TimeoutError() {
            var err = _super.call(this, 'Timeout has occurred');
            this.name = err.name = 'TimeoutError';
            this.stack = err.stack;
            this.message = err.message;
        }
        return TimeoutError;
    }(Error));
    var TimeoutError_2 = TimeoutError;


    var TimeoutError_1 = {
    	TimeoutError: TimeoutError_2
    };

    var __extends$21 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };




    /**
     *
     * Errors if Observable does not emit a value in given time span.
     *
     * <span class="informal">Timeouts on Observable that doesn't emit values fast enough.</span>
     *
     * <img src="./img/timeout.png" width="100%">
     *
     * `timeout` operator accepts as an argument either a number or a Date.
     *
     * If number was provided, it returns an Observable that behaves like a source
     * Observable, unless there is a period of time where there is no value emitted.
     * So if you provide `100` as argument and first value comes after 50ms from
     * the moment of subscription, this value will be simply re-emitted by the resulting
     * Observable. If however after that 100ms passes without a second value being emitted,
     * stream will end with an error and source Observable will be unsubscribed.
     * These checks are performed throughout whole lifecycle of Observable - from the moment
     * it was subscribed to, until it completes or errors itself. Thus every value must be
     * emitted within specified period since previous value.
     *
     * If provided argument was Date, returned Observable behaves differently. It throws
     * if Observable did not complete before provided Date. This means that periods between
     * emission of particular values do not matter in this case. If Observable did not complete
     * before provided Date, source Observable will be unsubscribed. Other than that, resulting
     * stream behaves just as source Observable.
     *
     * `timeout` accepts also a Scheduler as a second parameter. It is used to schedule moment (or moments)
     * when returned Observable will check if source stream emitted value or completed.
     *
     * @example <caption>Check if ticks are emitted within certain timespan</caption>
     * const seconds = Rx.Observable.interval(1000);
     *
     * seconds.timeout(1100) // Let's use bigger timespan to be safe,
     *                       // since `interval` might fire a bit later then scheduled.
     * .subscribe(
     *     value => console.log(value), // Will emit numbers just as regular `interval` would.
     *     err => console.log(err) // Will never be called.
     * );
     *
     * seconds.timeout(900).subscribe(
     *     value => console.log(value), // Will never be called.
     *     err => console.log(err) // Will emit error before even first value is emitted,
     *                             // since it did not arrive within 900ms period.
     * );
     *
     * @example <caption>Use Date to check if Observable completed</caption>
     * const seconds = Rx.Observable.interval(1000);
     *
     * seconds.timeout(new Date("December 17, 2020 03:24:00"))
     * .subscribe(
     *     value => console.log(value), // Will emit values as regular `interval` would
     *                                  // until December 17, 2020 at 03:24:00.
     *     err => console.log(err) // On December 17, 2020 at 03:24:00 it will emit an error,
     *                             // since Observable did not complete by then.
     * );
     *
     * @see {@link timeoutWith}
     *
     * @param {number|Date} due Number specifying period within which Observable must emit values
     *                          or Date specifying before when Observable should complete
     * @param {Scheduler} [scheduler] Scheduler controlling when timeout checks occur.
     * @return {Observable<T>} Observable that mirrors behaviour of source, unless timeout checks fail.
     * @method timeout
     * @owner Observable
     */
    function timeout(due, scheduler) {
        if (scheduler === void 0) { scheduler = async.async; }
        var absoluteTimeout = isDate_1.isDate(due);
        var waitFor = absoluteTimeout ? (+due - scheduler.now()) : Math.abs(due);
        return function (source) { return source.lift(new TimeoutOperator(waitFor, absoluteTimeout, scheduler, new TimeoutError_1.TimeoutError())); };
    }
    var timeout_2 = timeout;
    var TimeoutOperator = (function () {
        function TimeoutOperator(waitFor, absoluteTimeout, scheduler, errorInstance) {
            this.waitFor = waitFor;
            this.absoluteTimeout = absoluteTimeout;
            this.scheduler = scheduler;
            this.errorInstance = errorInstance;
        }
        TimeoutOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(new TimeoutSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.scheduler, this.errorInstance));
        };
        return TimeoutOperator;
    }());
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var TimeoutSubscriber = (function (_super) {
        __extends$21(TimeoutSubscriber, _super);
        function TimeoutSubscriber(destination, absoluteTimeout, waitFor, scheduler, errorInstance) {
            _super.call(this, destination);
            this.absoluteTimeout = absoluteTimeout;
            this.waitFor = waitFor;
            this.scheduler = scheduler;
            this.errorInstance = errorInstance;
            this.action = null;
            this.scheduleTimeout();
        }
        TimeoutSubscriber.dispatchTimeout = function (subscriber) {
            subscriber.error(subscriber.errorInstance);
        };
        TimeoutSubscriber.prototype.scheduleTimeout = function () {
            var action = this.action;
            if (action) {
                // Recycle the action if we've already scheduled one. All the production
                // Scheduler Actions mutate their state/delay time and return themeselves.
                // VirtualActions are immutable, so they create and return a clone. In this
                // case, we need to set the action reference to the most recent VirtualAction,
                // to ensure that's the one we clone from next time.
                this.action = action.schedule(this, this.waitFor);
            }
            else {
                this.add(this.action = this.scheduler.schedule(TimeoutSubscriber.dispatchTimeout, this.waitFor, this));
            }
        };
        TimeoutSubscriber.prototype._next = function (value) {
            if (!this.absoluteTimeout) {
                this.scheduleTimeout();
            }
            _super.prototype._next.call(this, value);
        };
        /** @deprecated internal use only */ TimeoutSubscriber.prototype._unsubscribe = function () {
            this.action = null;
            this.scheduler = null;
            this.errorInstance = null;
        };
        return TimeoutSubscriber;
    }(Subscriber_1.Subscriber));


    var timeout_1 = {
    	timeout: timeout_2
    };

    /**
     *
     * Errors if Observable does not emit a value in given time span.
     *
     * <span class="informal">Timeouts on Observable that doesn't emit values fast enough.</span>
     *
     * <img src="./img/timeout.png" width="100%">
     *
     * `timeout` operator accepts as an argument either a number or a Date.
     *
     * If number was provided, it returns an Observable that behaves like a source
     * Observable, unless there is a period of time where there is no value emitted.
     * So if you provide `100` as argument and first value comes after 50ms from
     * the moment of subscription, this value will be simply re-emitted by the resulting
     * Observable. If however after that 100ms passes without a second value being emitted,
     * stream will end with an error and source Observable will be unsubscribed.
     * These checks are performed throughout whole lifecycle of Observable - from the moment
     * it was subscribed to, until it completes or errors itself. Thus every value must be
     * emitted within specified period since previous value.
     *
     * If provided argument was Date, returned Observable behaves differently. It throws
     * if Observable did not complete before provided Date. This means that periods between
     * emission of particular values do not matter in this case. If Observable did not complete
     * before provided Date, source Observable will be unsubscribed. Other than that, resulting
     * stream behaves just as source Observable.
     *
     * `timeout` accepts also a Scheduler as a second parameter. It is used to schedule moment (or moments)
     * when returned Observable will check if source stream emitted value or completed.
     *
     * @example <caption>Check if ticks are emitted within certain timespan</caption>
     * const seconds = Rx.Observable.interval(1000);
     *
     * seconds.timeout(1100) // Let's use bigger timespan to be safe,
     *                       // since `interval` might fire a bit later then scheduled.
     * .subscribe(
     *     value => console.log(value), // Will emit numbers just as regular `interval` would.
     *     err => console.log(err) // Will never be called.
     * );
     *
     * seconds.timeout(900).subscribe(
     *     value => console.log(value), // Will never be called.
     *     err => console.log(err) // Will emit error before even first value is emitted,
     *                             // since it did not arrive within 900ms period.
     * );
     *
     * @example <caption>Use Date to check if Observable completed</caption>
     * const seconds = Rx.Observable.interval(1000);
     *
     * seconds.timeout(new Date("December 17, 2020 03:24:00"))
     * .subscribe(
     *     value => console.log(value), // Will emit values as regular `interval` would
     *                                  // until December 17, 2020 at 03:24:00.
     *     err => console.log(err) // On December 17, 2020 at 03:24:00 it will emit an error,
     *                             // since Observable did not complete by then.
     * );
     *
     * @see {@link timeoutWith}
     *
     * @param {number|Date} due Number specifying period within which Observable must emit values
     *                          or Date specifying before when Observable should complete
     * @param {Scheduler} [scheduler] Scheduler controlling when timeout checks occur.
     * @return {Observable<T>} Observable that mirrors behaviour of source, unless timeout checks fail.
     * @method timeout
     * @owner Observable
     */
    function timeout$1(due, scheduler) {
        if (scheduler === void 0) { scheduler = async.async; }
        return timeout_1.timeout(due, scheduler)(this);
    }
    var timeout_3 = timeout$1;


    var timeout_2$1 = {
    	timeout: timeout_3
    };

    Observable_1.Observable.prototype.timeout = timeout_2$1.timeout;

    var __extends$22 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };




    /* tslint:enable:max-line-length */
    /**
     *
     * Errors if Observable does not emit a value in given time span, in case of which
     * subscribes to the second Observable.
     *
     * <span class="informal">It's a version of `timeout` operator that let's you specify fallback Observable.</span>
     *
     * <img src="./img/timeoutWith.png" width="100%">
     *
     * `timeoutWith` is a variation of `timeout` operator. It behaves exactly the same,
     * still accepting as a first argument either a number or a Date, which control - respectively -
     * when values of source Observable should be emitted or when it should complete.
     *
     * The only difference is that it accepts a second, required parameter. This parameter
     * should be an Observable which will be subscribed when source Observable fails any timeout check.
     * So whenever regular `timeout` would emit an error, `timeoutWith` will instead start re-emitting
     * values from second Observable. Note that this fallback Observable is not checked for timeouts
     * itself, so it can emit values and complete at arbitrary points in time. From the moment of a second
     * subscription, Observable returned from `timeoutWith` simply mirrors fallback stream. When that
     * stream completes, it completes as well.
     *
     * Scheduler, which in case of `timeout` is provided as as second argument, can be still provided
     * here - as a third, optional parameter. It still is used to schedule timeout checks and -
     * as a consequence - when second Observable will be subscribed, since subscription happens
     * immediately after failing check.
     *
     * @example <caption>Add fallback observable</caption>
     * const seconds = Rx.Observable.interval(1000);
     * const minutes = Rx.Observable.interval(60 * 1000);
     *
     * seconds.timeoutWith(900, minutes)
     *     .subscribe(
     *         value => console.log(value), // After 900ms, will start emitting `minutes`,
     *                                      // since first value of `seconds` will not arrive fast enough.
     *         err => console.log(err) // Would be called after 900ms in case of `timeout`,
     *                                 // but here will never be called.
     *     );
     *
     * @param {number|Date} due Number specifying period within which Observable must emit values
     *                          or Date specifying before when Observable should complete
     * @param {Observable<T>} withObservable Observable which will be subscribed if source fails timeout check.
     * @param {Scheduler} [scheduler] Scheduler controlling when timeout checks occur.
     * @return {Observable<T>} Observable that mirrors behaviour of source or, when timeout check fails, of an Observable
     *                          passed as a second parameter.
     * @method timeoutWith
     * @owner Observable
     */
    function timeoutWith(due, withObservable, scheduler) {
        if (scheduler === void 0) { scheduler = async.async; }
        return function (source) {
            var absoluteTimeout = isDate_1.isDate(due);
            var waitFor = absoluteTimeout ? (+due - scheduler.now()) : Math.abs(due);
            return source.lift(new TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler));
        };
    }
    var timeoutWith_2 = timeoutWith;
    var TimeoutWithOperator = (function () {
        function TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler) {
            this.waitFor = waitFor;
            this.absoluteTimeout = absoluteTimeout;
            this.withObservable = withObservable;
            this.scheduler = scheduler;
        }
        TimeoutWithOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(new TimeoutWithSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.withObservable, this.scheduler));
        };
        return TimeoutWithOperator;
    }());
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var TimeoutWithSubscriber = (function (_super) {
        __extends$22(TimeoutWithSubscriber, _super);
        function TimeoutWithSubscriber(destination, absoluteTimeout, waitFor, withObservable, scheduler) {
            _super.call(this, destination);
            this.absoluteTimeout = absoluteTimeout;
            this.waitFor = waitFor;
            this.withObservable = withObservable;
            this.scheduler = scheduler;
            this.action = null;
            this.scheduleTimeout();
        }
        TimeoutWithSubscriber.dispatchTimeout = function (subscriber) {
            var withObservable = subscriber.withObservable;
            subscriber._unsubscribeAndRecycle();
            subscriber.add(subscribeToResult_1.subscribeToResult(subscriber, withObservable));
        };
        TimeoutWithSubscriber.prototype.scheduleTimeout = function () {
            var action = this.action;
            if (action) {
                // Recycle the action if we've already scheduled one. All the production
                // Scheduler Actions mutate their state/delay time and return themeselves.
                // VirtualActions are immutable, so they create and return a clone. In this
                // case, we need to set the action reference to the most recent VirtualAction,
                // to ensure that's the one we clone from next time.
                this.action = action.schedule(this, this.waitFor);
            }
            else {
                this.add(this.action = this.scheduler.schedule(TimeoutWithSubscriber.dispatchTimeout, this.waitFor, this));
            }
        };
        TimeoutWithSubscriber.prototype._next = function (value) {
            if (!this.absoluteTimeout) {
                this.scheduleTimeout();
            }
            _super.prototype._next.call(this, value);
        };
        /** @deprecated internal use only */ TimeoutWithSubscriber.prototype._unsubscribe = function () {
            this.action = null;
            this.scheduler = null;
            this.withObservable = null;
        };
        return TimeoutWithSubscriber;
    }(OuterSubscriber_1.OuterSubscriber));


    var timeoutWith_1 = {
    	timeoutWith: timeoutWith_2
    };

    /* tslint:enable:max-line-length */
    /**
     *
     * Errors if Observable does not emit a value in given time span, in case of which
     * subscribes to the second Observable.
     *
     * <span class="informal">It's a version of `timeout` operator that let's you specify fallback Observable.</span>
     *
     * <img src="./img/timeoutWith.png" width="100%">
     *
     * `timeoutWith` is a variation of `timeout` operator. It behaves exactly the same,
     * still accepting as a first argument either a number or a Date, which control - respectively -
     * when values of source Observable should be emitted or when it should complete.
     *
     * The only difference is that it accepts a second, required parameter. This parameter
     * should be an Observable which will be subscribed when source Observable fails any timeout check.
     * So whenever regular `timeout` would emit an error, `timeoutWith` will instead start re-emitting
     * values from second Observable. Note that this fallback Observable is not checked for timeouts
     * itself, so it can emit values and complete at arbitrary points in time. From the moment of a second
     * subscription, Observable returned from `timeoutWith` simply mirrors fallback stream. When that
     * stream completes, it completes as well.
     *
     * Scheduler, which in case of `timeout` is provided as as second argument, can be still provided
     * here - as a third, optional parameter. It still is used to schedule timeout checks and -
     * as a consequence - when second Observable will be subscribed, since subscription happens
     * immediately after failing check.
     *
     * @example <caption>Add fallback observable</caption>
     * const seconds = Rx.Observable.interval(1000);
     * const minutes = Rx.Observable.interval(60 * 1000);
     *
     * seconds.timeoutWith(900, minutes)
     *     .subscribe(
     *         value => console.log(value), // After 900ms, will start emitting `minutes`,
     *                                      // since first value of `seconds` will not arrive fast enough.
     *         err => console.log(err) // Would be called after 900ms in case of `timeout`,
     *                                 // but here will never be called.
     *     );
     *
     * @param {number|Date} due Number specifying period within which Observable must emit values
     *                          or Date specifying before when Observable should complete
     * @param {Observable<T>} withObservable Observable which will be subscribed if source fails timeout check.
     * @param {Scheduler} [scheduler] Scheduler controlling when timeout checks occur.
     * @return {Observable<T>} Observable that mirrors behaviour of source or, when timeout check fails, of an Observable
     *                          passed as a second parameter.
     * @method timeoutWith
     * @owner Observable
     */
    function timeoutWith$1(due, withObservable, scheduler) {
        if (scheduler === void 0) { scheduler = async.async; }
        return timeoutWith_1.timeoutWith(due, withObservable, scheduler)(this);
    }
    var timeoutWith_3 = timeoutWith$1;


    var timeoutWith_2$1 = {
    	timeoutWith: timeoutWith_3
    };

    Observable_1.Observable.prototype.timeoutWith = timeoutWith_2$1.timeoutWith;

    /**
     * @param scheduler
     * @return {Observable<Timestamp<any>>|WebSocketSubject<T>|Observable<T>}
     * @method timestamp
     * @owner Observable
     */
    function timestamp(scheduler) {
        if (scheduler === void 0) { scheduler = async.async; }
        return map_1.map(function (value) { return new Timestamp(value, scheduler.now()); });
        // return (source: Observable<T>) => source.lift(new TimestampOperator(scheduler));
    }
    var timestamp_2 = timestamp;
    var Timestamp = (function () {
        function Timestamp(value, timestamp) {
            this.value = value;
            this.timestamp = timestamp;
        }
        return Timestamp;
    }());
    var Timestamp_1 = Timestamp;


    var timestamp_1 = {
    	timestamp: timestamp_2,
    	Timestamp: Timestamp_1
    };

    /**
     * @param scheduler
     * @return {Observable<Timestamp<any>>|WebSocketSubject<T>|Observable<T>}
     * @method timestamp
     * @owner Observable
     */
    function timestamp$1(scheduler) {
        if (scheduler === void 0) { scheduler = async.async; }
        return timestamp_1.timestamp(scheduler)(this);
    }
    var timestamp_3 = timestamp$1;


    var timestamp_2$1 = {
    	timestamp: timestamp_3
    };

    Observable_1.Observable.prototype.timestamp = timestamp_2$1.timestamp;

    function toArrayReducer(arr, item, index) {
        if (index === 0) {
            return [item];
        }
        arr.push(item);
        return arr;
    }
    function toArray() {
        return reduce_1.reduce(toArrayReducer, []);
    }
    var toArray_2 = toArray;


    var toArray_1 = {
    	toArray: toArray_2
    };

    /**
     * Collects all source emissions and emits them as an array when the source completes.
     *
     * <span class="informal">Get all values inside an array when the source completes</span>
     *
     * <img src="./img/toArray.png" width="100%">
     *
     * `toArray` will wait until the source Observable completes
     * before emitting the array containing all emissions.
     * When the source Observable errors no array will be emitted.
     *
     * @example <caption>Create array from input</caption>
     * const input = Rx.Observable.interval(100).take(4);
     *
     * input.toArray()
     *   .subscribe(arr => console.log(arr)); // [0,1,2,3]
     *
     * @see {@link buffer}
     *
     * @return {Observable<any[]>|WebSocketSubject<T>|Observable<T>}
     * @method toArray
     * @owner Observable
     */
    function toArray$1() {
        return toArray_1.toArray()(this);
    }
    var toArray_3 = toArray$1;


    var toArray_2$1 = {
    	toArray: toArray_3
    };

    Observable_1.Observable.prototype.toArray = toArray_2$1.toArray;

    // HACK: does nothing, because `toPromise` now lives on the `Observable` itself.
    // leaving this module here to prevent breakage.

    var __extends$23 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };



    /**
     * Branch out the source Observable values as a nested Observable whenever
     * `windowBoundaries` emits.
     *
     * <span class="informal">It's like {@link buffer}, but emits a nested Observable
     * instead of an array.</span>
     *
     * <img src="./img/window.png" width="100%">
     *
     * Returns an Observable that emits windows of items it collects from the source
     * Observable. The output Observable emits connected, non-overlapping
     * windows. It emits the current window and opens a new one whenever the
     * Observable `windowBoundaries` emits an item. Because each window is an
     * Observable, the output is a higher-order Observable.
     *
     * @example <caption>In every window of 1 second each, emit at most 2 click events</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var interval = Rx.Observable.interval(1000);
     * var result = clicks.window(interval)
     *   .map(win => win.take(2)) // each window has at most 2 emissions
     *   .mergeAll(); // flatten the Observable-of-Observables
     * result.subscribe(x => console.log(x));
     *
     * @see {@link windowCount}
     * @see {@link windowTime}
     * @see {@link windowToggle}
     * @see {@link windowWhen}
     * @see {@link buffer}
     *
     * @param {Observable<any>} windowBoundaries An Observable that completes the
     * previous window and starts a new window.
     * @return {Observable<Observable<T>>} An Observable of windows, which are
     * Observables emitting values of the source Observable.
     * @method window
     * @owner Observable
     */
    function window$1(windowBoundaries) {
        return function windowOperatorFunction(source) {
            return source.lift(new WindowOperator(windowBoundaries));
        };
    }
    var window_2 = window$1;
    var WindowOperator = (function () {
        function WindowOperator(windowBoundaries) {
            this.windowBoundaries = windowBoundaries;
        }
        WindowOperator.prototype.call = function (subscriber, source) {
            var windowSubscriber = new WindowSubscriber(subscriber);
            var sourceSubscription = source.subscribe(windowSubscriber);
            if (!sourceSubscription.closed) {
                windowSubscriber.add(subscribeToResult_1.subscribeToResult(windowSubscriber, this.windowBoundaries));
            }
            return sourceSubscription;
        };
        return WindowOperator;
    }());
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var WindowSubscriber = (function (_super) {
        __extends$23(WindowSubscriber, _super);
        function WindowSubscriber(destination) {
            _super.call(this, destination);
            this.window = new Subject_1.Subject();
            destination.next(this.window);
        }
        WindowSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
            this.openWindow();
        };
        WindowSubscriber.prototype.notifyError = function (error, innerSub) {
            this._error(error);
        };
        WindowSubscriber.prototype.notifyComplete = function (innerSub) {
            this._complete();
        };
        WindowSubscriber.prototype._next = function (value) {
            this.window.next(value);
        };
        WindowSubscriber.prototype._error = function (err) {
            this.window.error(err);
            this.destination.error(err);
        };
        WindowSubscriber.prototype._complete = function () {
            this.window.complete();
            this.destination.complete();
        };
        /** @deprecated internal use only */ WindowSubscriber.prototype._unsubscribe = function () {
            this.window = null;
        };
        WindowSubscriber.prototype.openWindow = function () {
            var prevWindow = this.window;
            if (prevWindow) {
                prevWindow.complete();
            }
            var destination = this.destination;
            var newWindow = this.window = new Subject_1.Subject();
            destination.next(newWindow);
        };
        return WindowSubscriber;
    }(OuterSubscriber_1.OuterSubscriber));


    var window_1 = {
    	window: window_2
    };

    /**
     * Branch out the source Observable values as a nested Observable whenever
     * `windowBoundaries` emits.
     *
     * <span class="informal">It's like {@link buffer}, but emits a nested Observable
     * instead of an array.</span>
     *
     * <img src="./img/window.png" width="100%">
     *
     * Returns an Observable that emits windows of items it collects from the source
     * Observable. The output Observable emits connected, non-overlapping
     * windows. It emits the current window and opens a new one whenever the
     * Observable `windowBoundaries` emits an item. Because each window is an
     * Observable, the output is a higher-order Observable.
     *
     * @example <caption>In every window of 1 second each, emit at most 2 click events</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var interval = Rx.Observable.interval(1000);
     * var result = clicks.window(interval)
     *   .map(win => win.take(2)) // each window has at most 2 emissions
     *   .mergeAll(); // flatten the Observable-of-Observables
     * result.subscribe(x => console.log(x));
     *
     * @see {@link windowCount}
     * @see {@link windowTime}
     * @see {@link windowToggle}
     * @see {@link windowWhen}
     * @see {@link buffer}
     *
     * @param {Observable<any>} windowBoundaries An Observable that completes the
     * previous window and starts a new window.
     * @return {Observable<Observable<T>>} An Observable of windows, which are
     * Observables emitting values of the source Observable.
     * @method window
     * @owner Observable
     */
    function window$2(windowBoundaries) {
        return window_1.window(windowBoundaries)(this);
    }
    var window_3 = window$2;


    var window_2$1 = {
    	window: window_3
    };

    Observable_1.Observable.prototype.window = window_2$1.window;

    var __extends$24 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };


    /**
     * Branch out the source Observable values as a nested Observable with each
     * nested Observable emitting at most `windowSize` values.
     *
     * <span class="informal">It's like {@link bufferCount}, but emits a nested
     * Observable instead of an array.</span>
     *
     * <img src="./img/windowCount.png" width="100%">
     *
     * Returns an Observable that emits windows of items it collects from the source
     * Observable. The output Observable emits windows every `startWindowEvery`
     * items, each containing no more than `windowSize` items. When the source
     * Observable completes or encounters an error, the output Observable emits
     * the current window and propagates the notification from the source
     * Observable. If `startWindowEvery` is not provided, then new windows are
     * started immediately at the start of the source and when each window completes
     * with size `windowSize`.
     *
     * @example <caption>Ignore every 3rd click event, starting from the first one</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var result = clicks.windowCount(3)
     *   .map(win => win.skip(1)) // skip first of every 3 clicks
     *   .mergeAll(); // flatten the Observable-of-Observables
     * result.subscribe(x => console.log(x));
     *
     * @example <caption>Ignore every 3rd click event, starting from the third one</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var result = clicks.windowCount(2, 3)
     *   .mergeAll(); // flatten the Observable-of-Observables
     * result.subscribe(x => console.log(x));
     *
     * @see {@link window}
     * @see {@link windowTime}
     * @see {@link windowToggle}
     * @see {@link windowWhen}
     * @see {@link bufferCount}
     *
     * @param {number} windowSize The maximum number of values emitted by each
     * window.
     * @param {number} [startWindowEvery] Interval at which to start a new window.
     * For example if `startWindowEvery` is `2`, then a new window will be started
     * on every other value from the source. A new window is started at the
     * beginning of the source by default.
     * @return {Observable<Observable<T>>} An Observable of windows, which in turn
     * are Observable of values.
     * @method windowCount
     * @owner Observable
     */
    function windowCount(windowSize, startWindowEvery) {
        if (startWindowEvery === void 0) { startWindowEvery = 0; }
        return function windowCountOperatorFunction(source) {
            return source.lift(new WindowCountOperator(windowSize, startWindowEvery));
        };
    }
    var windowCount_2 = windowCount;
    var WindowCountOperator = (function () {
        function WindowCountOperator(windowSize, startWindowEvery) {
            this.windowSize = windowSize;
            this.startWindowEvery = startWindowEvery;
        }
        WindowCountOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(new WindowCountSubscriber(subscriber, this.windowSize, this.startWindowEvery));
        };
        return WindowCountOperator;
    }());
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var WindowCountSubscriber = (function (_super) {
        __extends$24(WindowCountSubscriber, _super);
        function WindowCountSubscriber(destination, windowSize, startWindowEvery) {
            _super.call(this, destination);
            this.destination = destination;
            this.windowSize = windowSize;
            this.startWindowEvery = startWindowEvery;
            this.windows = [new Subject_1.Subject()];
            this.count = 0;
            destination.next(this.windows[0]);
        }
        WindowCountSubscriber.prototype._next = function (value) {
            var startWindowEvery = (this.startWindowEvery > 0) ? this.startWindowEvery : this.windowSize;
            var destination = this.destination;
            var windowSize = this.windowSize;
            var windows = this.windows;
            var len = windows.length;
            for (var i = 0; i < len && !this.closed; i++) {
                windows[i].next(value);
            }
            var c = this.count - windowSize + 1;
            if (c >= 0 && c % startWindowEvery === 0 && !this.closed) {
                windows.shift().complete();
            }
            if (++this.count % startWindowEvery === 0 && !this.closed) {
                var window_1 = new Subject_1.Subject();
                windows.push(window_1);
                destination.next(window_1);
            }
        };
        WindowCountSubscriber.prototype._error = function (err) {
            var windows = this.windows;
            if (windows) {
                while (windows.length > 0 && !this.closed) {
                    windows.shift().error(err);
                }
            }
            this.destination.error(err);
        };
        WindowCountSubscriber.prototype._complete = function () {
            var windows = this.windows;
            if (windows) {
                while (windows.length > 0 && !this.closed) {
                    windows.shift().complete();
                }
            }
            this.destination.complete();
        };
        /** @deprecated internal use only */ WindowCountSubscriber.prototype._unsubscribe = function () {
            this.count = 0;
            this.windows = null;
        };
        return WindowCountSubscriber;
    }(Subscriber_1.Subscriber));


    var windowCount_1 = {
    	windowCount: windowCount_2
    };

    /**
     * Branch out the source Observable values as a nested Observable with each
     * nested Observable emitting at most `windowSize` values.
     *
     * <span class="informal">It's like {@link bufferCount}, but emits a nested
     * Observable instead of an array.</span>
     *
     * <img src="./img/windowCount.png" width="100%">
     *
     * Returns an Observable that emits windows of items it collects from the source
     * Observable. The output Observable emits windows every `startWindowEvery`
     * items, each containing no more than `windowSize` items. When the source
     * Observable completes or encounters an error, the output Observable emits
     * the current window and propagates the notification from the source
     * Observable. If `startWindowEvery` is not provided, then new windows are
     * started immediately at the start of the source and when each window completes
     * with size `windowSize`.
     *
     * @example <caption>Ignore every 3rd click event, starting from the first one</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var result = clicks.windowCount(3)
     *   .map(win => win.skip(1)) // skip first of every 3 clicks
     *   .mergeAll(); // flatten the Observable-of-Observables
     * result.subscribe(x => console.log(x));
     *
     * @example <caption>Ignore every 3rd click event, starting from the third one</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var result = clicks.windowCount(2, 3)
     *   .mergeAll(); // flatten the Observable-of-Observables
     * result.subscribe(x => console.log(x));
     *
     * @see {@link window}
     * @see {@link windowTime}
     * @see {@link windowToggle}
     * @see {@link windowWhen}
     * @see {@link bufferCount}
     *
     * @param {number} windowSize The maximum number of values emitted by each
     * window.
     * @param {number} [startWindowEvery] Interval at which to start a new window.
     * For example if `startWindowEvery` is `2`, then a new window will be started
     * on every other value from the source. A new window is started at the
     * beginning of the source by default.
     * @return {Observable<Observable<T>>} An Observable of windows, which in turn
     * are Observable of values.
     * @method windowCount
     * @owner Observable
     */
    function windowCount$1(windowSize, startWindowEvery) {
        if (startWindowEvery === void 0) { startWindowEvery = 0; }
        return windowCount_1.windowCount(windowSize, startWindowEvery)(this);
    }
    var windowCount_3 = windowCount$1;


    var windowCount_2$1 = {
    	windowCount: windowCount_3
    };

    Observable_1.Observable.prototype.windowCount = windowCount_2$1.windowCount;

    var __extends$25 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };





    function windowTime(windowTimeSpan) {
        var scheduler = async.async;
        var windowCreationInterval = null;
        var maxWindowSize = Number.POSITIVE_INFINITY;
        if (isScheduler_1.isScheduler(arguments[3])) {
            scheduler = arguments[3];
        }
        if (isScheduler_1.isScheduler(arguments[2])) {
            scheduler = arguments[2];
        }
        else if (isNumeric_1.isNumeric(arguments[2])) {
            maxWindowSize = arguments[2];
        }
        if (isScheduler_1.isScheduler(arguments[1])) {
            scheduler = arguments[1];
        }
        else if (isNumeric_1.isNumeric(arguments[1])) {
            windowCreationInterval = arguments[1];
        }
        return function windowTimeOperatorFunction(source) {
            return source.lift(new WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler));
        };
    }
    var windowTime_2 = windowTime;
    var WindowTimeOperator = (function () {
        function WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {
            this.windowTimeSpan = windowTimeSpan;
            this.windowCreationInterval = windowCreationInterval;
            this.maxWindowSize = maxWindowSize;
            this.scheduler = scheduler;
        }
        WindowTimeOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(new WindowTimeSubscriber(subscriber, this.windowTimeSpan, this.windowCreationInterval, this.maxWindowSize, this.scheduler));
        };
        return WindowTimeOperator;
    }());
    var CountedSubject = (function (_super) {
        __extends$25(CountedSubject, _super);
        function CountedSubject() {
            _super.apply(this, arguments);
            this._numberOfNextedValues = 0;
        }
        CountedSubject.prototype.next = function (value) {
            this._numberOfNextedValues++;
            _super.prototype.next.call(this, value);
        };
        Object.defineProperty(CountedSubject.prototype, "numberOfNextedValues", {
            get: function () {
                return this._numberOfNextedValues;
            },
            enumerable: true,
            configurable: true
        });
        return CountedSubject;
    }(Subject_1.Subject));
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var WindowTimeSubscriber = (function (_super) {
        __extends$25(WindowTimeSubscriber, _super);
        function WindowTimeSubscriber(destination, windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {
            _super.call(this, destination);
            this.destination = destination;
            this.windowTimeSpan = windowTimeSpan;
            this.windowCreationInterval = windowCreationInterval;
            this.maxWindowSize = maxWindowSize;
            this.scheduler = scheduler;
            this.windows = [];
            var window = this.openWindow();
            if (windowCreationInterval !== null && windowCreationInterval >= 0) {
                var closeState = { subscriber: this, window: window, context: null };
                var creationState = { windowTimeSpan: windowTimeSpan, windowCreationInterval: windowCreationInterval, subscriber: this, scheduler: scheduler };
                this.add(scheduler.schedule(dispatchWindowClose, windowTimeSpan, closeState));
                this.add(scheduler.schedule(dispatchWindowCreation, windowCreationInterval, creationState));
            }
            else {
                var timeSpanOnlyState = { subscriber: this, window: window, windowTimeSpan: windowTimeSpan };
                this.add(scheduler.schedule(dispatchWindowTimeSpanOnly, windowTimeSpan, timeSpanOnlyState));
            }
        }
        WindowTimeSubscriber.prototype._next = function (value) {
            var windows = this.windows;
            var len = windows.length;
            for (var i = 0; i < len; i++) {
                var window_1 = windows[i];
                if (!window_1.closed) {
                    window_1.next(value);
                    if (window_1.numberOfNextedValues >= this.maxWindowSize) {
                        this.closeWindow(window_1);
                    }
                }
            }
        };
        WindowTimeSubscriber.prototype._error = function (err) {
            var windows = this.windows;
            while (windows.length > 0) {
                windows.shift().error(err);
            }
            this.destination.error(err);
        };
        WindowTimeSubscriber.prototype._complete = function () {
            var windows = this.windows;
            while (windows.length > 0) {
                var window_2 = windows.shift();
                if (!window_2.closed) {
                    window_2.complete();
                }
            }
            this.destination.complete();
        };
        WindowTimeSubscriber.prototype.openWindow = function () {
            var window = new CountedSubject();
            this.windows.push(window);
            var destination = this.destination;
            destination.next(window);
            return window;
        };
        WindowTimeSubscriber.prototype.closeWindow = function (window) {
            window.complete();
            var windows = this.windows;
            windows.splice(windows.indexOf(window), 1);
        };
        return WindowTimeSubscriber;
    }(Subscriber_1.Subscriber));
    function dispatchWindowTimeSpanOnly(state) {
        var subscriber = state.subscriber, windowTimeSpan = state.windowTimeSpan, window = state.window;
        if (window) {
            subscriber.closeWindow(window);
        }
        state.window = subscriber.openWindow();
        this.schedule(state, windowTimeSpan);
    }
    function dispatchWindowCreation(state) {
        var windowTimeSpan = state.windowTimeSpan, subscriber = state.subscriber, scheduler = state.scheduler, windowCreationInterval = state.windowCreationInterval;
        var window = subscriber.openWindow();
        var action = this;
        var context = { action: action, subscription: null };
        var timeSpanState = { subscriber: subscriber, window: window, context: context };
        context.subscription = scheduler.schedule(dispatchWindowClose, windowTimeSpan, timeSpanState);
        action.add(context.subscription);
        action.schedule(state, windowCreationInterval);
    }
    function dispatchWindowClose(state) {
        var subscriber = state.subscriber, window = state.window, context = state.context;
        if (context && context.action && context.subscription) {
            context.action.remove(context.subscription);
        }
        subscriber.closeWindow(window);
    }


    var windowTime_1 = {
    	windowTime: windowTime_2
    };

    function windowTime$1(windowTimeSpan) {
        var scheduler = async.async;
        var windowCreationInterval = null;
        var maxWindowSize = Number.POSITIVE_INFINITY;
        if (isScheduler_1.isScheduler(arguments[3])) {
            scheduler = arguments[3];
        }
        if (isScheduler_1.isScheduler(arguments[2])) {
            scheduler = arguments[2];
        }
        else if (isNumeric_1.isNumeric(arguments[2])) {
            maxWindowSize = arguments[2];
        }
        if (isScheduler_1.isScheduler(arguments[1])) {
            scheduler = arguments[1];
        }
        else if (isNumeric_1.isNumeric(arguments[1])) {
            windowCreationInterval = arguments[1];
        }
        return windowTime_1.windowTime(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler)(this);
    }
    var windowTime_3 = windowTime$1;


    var windowTime_2$1 = {
    	windowTime: windowTime_3
    };

    Observable_1.Observable.prototype.windowTime = windowTime_2$1.windowTime;

    var __extends$26 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };






    /**
     * Branch out the source Observable values as a nested Observable starting from
     * an emission from `openings` and ending when the output of `closingSelector`
     * emits.
     *
     * <span class="informal">It's like {@link bufferToggle}, but emits a nested
     * Observable instead of an array.</span>
     *
     * <img src="./img/windowToggle.png" width="100%">
     *
     * Returns an Observable that emits windows of items it collects from the source
     * Observable. The output Observable emits windows that contain those items
     * emitted by the source Observable between the time when the `openings`
     * Observable emits an item and when the Observable returned by
     * `closingSelector` emits an item.
     *
     * @example <caption>Every other second, emit the click events from the next 500ms</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var openings = Rx.Observable.interval(1000);
     * var result = clicks.windowToggle(openings, i =>
     *   i % 2 ? Rx.Observable.interval(500) : Rx.Observable.empty()
     * ).mergeAll();
     * result.subscribe(x => console.log(x));
     *
     * @see {@link window}
     * @see {@link windowCount}
     * @see {@link windowTime}
     * @see {@link windowWhen}
     * @see {@link bufferToggle}
     *
     * @param {Observable<O>} openings An observable of notifications to start new
     * windows.
     * @param {function(value: O): Observable} closingSelector A function that takes
     * the value emitted by the `openings` observable and returns an Observable,
     * which, when it emits (either `next` or `complete`), signals that the
     * associated window should complete.
     * @return {Observable<Observable<T>>} An observable of windows, which in turn
     * are Observables.
     * @method windowToggle
     * @owner Observable
     */
    function windowToggle(openings, closingSelector) {
        return function (source) { return source.lift(new WindowToggleOperator(openings, closingSelector)); };
    }
    var windowToggle_2 = windowToggle;
    var WindowToggleOperator = (function () {
        function WindowToggleOperator(openings, closingSelector) {
            this.openings = openings;
            this.closingSelector = closingSelector;
        }
        WindowToggleOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(new WindowToggleSubscriber(subscriber, this.openings, this.closingSelector));
        };
        return WindowToggleOperator;
    }());
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var WindowToggleSubscriber = (function (_super) {
        __extends$26(WindowToggleSubscriber, _super);
        function WindowToggleSubscriber(destination, openings, closingSelector) {
            _super.call(this, destination);
            this.openings = openings;
            this.closingSelector = closingSelector;
            this.contexts = [];
            this.add(this.openSubscription = subscribeToResult_1.subscribeToResult(this, openings, openings));
        }
        WindowToggleSubscriber.prototype._next = function (value) {
            var contexts = this.contexts;
            if (contexts) {
                var len = contexts.length;
                for (var i = 0; i < len; i++) {
                    contexts[i].window.next(value);
                }
            }
        };
        WindowToggleSubscriber.prototype._error = function (err) {
            var contexts = this.contexts;
            this.contexts = null;
            if (contexts) {
                var len = contexts.length;
                var index = -1;
                while (++index < len) {
                    var context = contexts[index];
                    context.window.error(err);
                    context.subscription.unsubscribe();
                }
            }
            _super.prototype._error.call(this, err);
        };
        WindowToggleSubscriber.prototype._complete = function () {
            var contexts = this.contexts;
            this.contexts = null;
            if (contexts) {
                var len = contexts.length;
                var index = -1;
                while (++index < len) {
                    var context = contexts[index];
                    context.window.complete();
                    context.subscription.unsubscribe();
                }
            }
            _super.prototype._complete.call(this);
        };
        /** @deprecated internal use only */ WindowToggleSubscriber.prototype._unsubscribe = function () {
            var contexts = this.contexts;
            this.contexts = null;
            if (contexts) {
                var len = contexts.length;
                var index = -1;
                while (++index < len) {
                    var context = contexts[index];
                    context.window.unsubscribe();
                    context.subscription.unsubscribe();
                }
            }
        };
        WindowToggleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
            if (outerValue === this.openings) {
                var closingSelector = this.closingSelector;
                var closingNotifier = tryCatch_1.tryCatch(closingSelector)(innerValue);
                if (closingNotifier === errorObject.errorObject) {
                    return this.error(errorObject.errorObject.e);
                }
                else {
                    var window_1 = new Subject_1.Subject();
                    var subscription = new Subscription_1.Subscription();
                    var context = { window: window_1, subscription: subscription };
                    this.contexts.push(context);
                    var innerSubscription = subscribeToResult_1.subscribeToResult(this, closingNotifier, context);
                    if (innerSubscription.closed) {
                        this.closeWindow(this.contexts.length - 1);
                    }
                    else {
                        innerSubscription.context = context;
                        subscription.add(innerSubscription);
                    }
                    this.destination.next(window_1);
                }
            }
            else {
                this.closeWindow(this.contexts.indexOf(outerValue));
            }
        };
        WindowToggleSubscriber.prototype.notifyError = function (err) {
            this.error(err);
        };
        WindowToggleSubscriber.prototype.notifyComplete = function (inner) {
            if (inner !== this.openSubscription) {
                this.closeWindow(this.contexts.indexOf(inner.context));
            }
        };
        WindowToggleSubscriber.prototype.closeWindow = function (index) {
            if (index === -1) {
                return;
            }
            var contexts = this.contexts;
            var context = contexts[index];
            var window = context.window, subscription = context.subscription;
            contexts.splice(index, 1);
            window.complete();
            subscription.unsubscribe();
        };
        return WindowToggleSubscriber;
    }(OuterSubscriber_1.OuterSubscriber));


    var windowToggle_1 = {
    	windowToggle: windowToggle_2
    };

    /**
     * Branch out the source Observable values as a nested Observable starting from
     * an emission from `openings` and ending when the output of `closingSelector`
     * emits.
     *
     * <span class="informal">It's like {@link bufferToggle}, but emits a nested
     * Observable instead of an array.</span>
     *
     * <img src="./img/windowToggle.png" width="100%">
     *
     * Returns an Observable that emits windows of items it collects from the source
     * Observable. The output Observable emits windows that contain those items
     * emitted by the source Observable between the time when the `openings`
     * Observable emits an item and when the Observable returned by
     * `closingSelector` emits an item.
     *
     * @example <caption>Every other second, emit the click events from the next 500ms</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var openings = Rx.Observable.interval(1000);
     * var result = clicks.windowToggle(openings, i =>
     *   i % 2 ? Rx.Observable.interval(500) : Rx.Observable.empty()
     * ).mergeAll();
     * result.subscribe(x => console.log(x));
     *
     * @see {@link window}
     * @see {@link windowCount}
     * @see {@link windowTime}
     * @see {@link windowWhen}
     * @see {@link bufferToggle}
     *
     * @param {Observable<O>} openings An observable of notifications to start new
     * windows.
     * @param {function(value: O): Observable} closingSelector A function that takes
     * the value emitted by the `openings` observable and returns an Observable,
     * which, when it emits (either `next` or `complete`), signals that the
     * associated window should complete.
     * @return {Observable<Observable<T>>} An observable of windows, which in turn
     * are Observables.
     * @method windowToggle
     * @owner Observable
     */
    function windowToggle$1(openings, closingSelector) {
        return windowToggle_1.windowToggle(openings, closingSelector)(this);
    }
    var windowToggle_3 = windowToggle$1;


    var windowToggle_2$1 = {
    	windowToggle: windowToggle_3
    };

    Observable_1.Observable.prototype.windowToggle = windowToggle_2$1.windowToggle;

    var __extends$27 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };





    /**
     * Branch out the source Observable values as a nested Observable using a
     * factory function of closing Observables to determine when to start a new
     * window.
     *
     * <span class="informal">It's like {@link bufferWhen}, but emits a nested
     * Observable instead of an array.</span>
     *
     * <img src="./img/windowWhen.png" width="100%">
     *
     * Returns an Observable that emits windows of items it collects from the source
     * Observable. The output Observable emits connected, non-overlapping windows.
     * It emits the current window and opens a new one whenever the Observable
     * produced by the specified `closingSelector` function emits an item. The first
     * window is opened immediately when subscribing to the output Observable.
     *
     * @example <caption>Emit only the first two clicks events in every window of [1-5] random seconds</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var result = clicks
     *   .windowWhen(() => Rx.Observable.interval(1000 + Math.random() * 4000))
     *   .map(win => win.take(2)) // each window has at most 2 emissions
     *   .mergeAll(); // flatten the Observable-of-Observables
     * result.subscribe(x => console.log(x));
     *
     * @see {@link window}
     * @see {@link windowCount}
     * @see {@link windowTime}
     * @see {@link windowToggle}
     * @see {@link bufferWhen}
     *
     * @param {function(): Observable} closingSelector A function that takes no
     * arguments and returns an Observable that signals (on either `next` or
     * `complete`) when to close the previous window and start a new one.
     * @return {Observable<Observable<T>>} An observable of windows, which in turn
     * are Observables.
     * @method windowWhen
     * @owner Observable
     */
    function windowWhen(closingSelector) {
        return function windowWhenOperatorFunction(source) {
            return source.lift(new WindowOperator$1(closingSelector));
        };
    }
    var windowWhen_2 = windowWhen;
    var WindowOperator$1 = (function () {
        function WindowOperator(closingSelector) {
            this.closingSelector = closingSelector;
        }
        WindowOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(new WindowSubscriber$1(subscriber, this.closingSelector));
        };
        return WindowOperator;
    }());
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var WindowSubscriber$1 = (function (_super) {
        __extends$27(WindowSubscriber, _super);
        function WindowSubscriber(destination, closingSelector) {
            _super.call(this, destination);
            this.destination = destination;
            this.closingSelector = closingSelector;
            this.openWindow();
        }
        WindowSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
            this.openWindow(innerSub);
        };
        WindowSubscriber.prototype.notifyError = function (error, innerSub) {
            this._error(error);
        };
        WindowSubscriber.prototype.notifyComplete = function (innerSub) {
            this.openWindow(innerSub);
        };
        WindowSubscriber.prototype._next = function (value) {
            this.window.next(value);
        };
        WindowSubscriber.prototype._error = function (err) {
            this.window.error(err);
            this.destination.error(err);
            this.unsubscribeClosingNotification();
        };
        WindowSubscriber.prototype._complete = function () {
            this.window.complete();
            this.destination.complete();
            this.unsubscribeClosingNotification();
        };
        WindowSubscriber.prototype.unsubscribeClosingNotification = function () {
            if (this.closingNotification) {
                this.closingNotification.unsubscribe();
            }
        };
        WindowSubscriber.prototype.openWindow = function (innerSub) {
            if (innerSub === void 0) { innerSub = null; }
            if (innerSub) {
                this.remove(innerSub);
                innerSub.unsubscribe();
            }
            var prevWindow = this.window;
            if (prevWindow) {
                prevWindow.complete();
            }
            var window = this.window = new Subject_1.Subject();
            this.destination.next(window);
            var closingNotifier = tryCatch_1.tryCatch(this.closingSelector)();
            if (closingNotifier === errorObject.errorObject) {
                var err = errorObject.errorObject.e;
                this.destination.error(err);
                this.window.error(err);
            }
            else {
                this.add(this.closingNotification = subscribeToResult_1.subscribeToResult(this, closingNotifier));
            }
        };
        return WindowSubscriber;
    }(OuterSubscriber_1.OuterSubscriber));


    var windowWhen_1 = {
    	windowWhen: windowWhen_2
    };

    /**
     * Branch out the source Observable values as a nested Observable using a
     * factory function of closing Observables to determine when to start a new
     * window.
     *
     * <span class="informal">It's like {@link bufferWhen}, but emits a nested
     * Observable instead of an array.</span>
     *
     * <img src="./img/windowWhen.png" width="100%">
     *
     * Returns an Observable that emits windows of items it collects from the source
     * Observable. The output Observable emits connected, non-overlapping windows.
     * It emits the current window and opens a new one whenever the Observable
     * produced by the specified `closingSelector` function emits an item. The first
     * window is opened immediately when subscribing to the output Observable.
     *
     * @example <caption>Emit only the first two clicks events in every window of [1-5] random seconds</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var result = clicks
     *   .windowWhen(() => Rx.Observable.interval(1000 + Math.random() * 4000))
     *   .map(win => win.take(2)) // each window has at most 2 emissions
     *   .mergeAll(); // flatten the Observable-of-Observables
     * result.subscribe(x => console.log(x));
     *
     * @see {@link window}
     * @see {@link windowCount}
     * @see {@link windowTime}
     * @see {@link windowToggle}
     * @see {@link bufferWhen}
     *
     * @param {function(): Observable} closingSelector A function that takes no
     * arguments and returns an Observable that signals (on either `next` or
     * `complete`) when to close the previous window and start a new one.
     * @return {Observable<Observable<T>>} An observable of windows, which in turn
     * are Observables.
     * @method windowWhen
     * @owner Observable
     */
    function windowWhen$1(closingSelector) {
        return windowWhen_1.windowWhen(closingSelector)(this);
    }
    var windowWhen_3 = windowWhen$1;


    var windowWhen_2$1 = {
    	windowWhen: windowWhen_3
    };

    Observable_1.Observable.prototype.windowWhen = windowWhen_2$1.windowWhen;

    var __extends$28 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };


    /* tslint:enable:max-line-length */
    /**
     * Combines the source Observable with other Observables to create an Observable
     * whose values are calculated from the latest values of each, only when the
     * source emits.
     *
     * <span class="informal">Whenever the source Observable emits a value, it
     * computes a formula using that value plus the latest values from other input
     * Observables, then emits the output of that formula.</span>
     *
     * <img src="./img/withLatestFrom.png" width="100%">
     *
     * `withLatestFrom` combines each value from the source Observable (the
     * instance) with the latest values from the other input Observables only when
     * the source emits a value, optionally using a `project` function to determine
     * the value to be emitted on the output Observable. All input Observables must
     * emit at least one value before the output Observable will emit a value.
     *
     * @example <caption>On every click event, emit an array with the latest timer event plus the click event</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var timer = Rx.Observable.interval(1000);
     * var result = clicks.withLatestFrom(timer);
     * result.subscribe(x => console.log(x));
     *
     * @see {@link combineLatest}
     *
     * @param {ObservableInput} other An input Observable to combine with the source
     * Observable. More than one input Observables may be given as argument.
     * @param {Function} [project] Projection function for combining values
     * together. Receives all values in order of the Observables passed, where the
     * first parameter is a value from the source Observable. (e.g.
     * `a.withLatestFrom(b, c, (a1, b1, c1) => a1 + b1 + c1)`). If this is not
     * passed, arrays will be emitted on the output Observable.
     * @return {Observable} An Observable of projected values from the most recent
     * values from each input Observable, or an array of the most recent values from
     * each input Observable.
     * @method withLatestFrom
     * @owner Observable
     */
    function withLatestFrom() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i - 0] = arguments[_i];
        }
        return function (source) {
            var project;
            if (typeof args[args.length - 1] === 'function') {
                project = args.pop();
            }
            var observables = args;
            return source.lift(new WithLatestFromOperator(observables, project));
        };
    }
    var withLatestFrom_2 = withLatestFrom;
    var WithLatestFromOperator = (function () {
        function WithLatestFromOperator(observables, project) {
            this.observables = observables;
            this.project = project;
        }
        WithLatestFromOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(new WithLatestFromSubscriber(subscriber, this.observables, this.project));
        };
        return WithLatestFromOperator;
    }());
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var WithLatestFromSubscriber = (function (_super) {
        __extends$28(WithLatestFromSubscriber, _super);
        function WithLatestFromSubscriber(destination, observables, project) {
            _super.call(this, destination);
            this.observables = observables;
            this.project = project;
            this.toRespond = [];
            var len = observables.length;
            this.values = new Array(len);
            for (var i = 0; i < len; i++) {
                this.toRespond.push(i);
            }
            for (var i = 0; i < len; i++) {
                var observable = observables[i];
                this.add(subscribeToResult_1.subscribeToResult(this, observable, observable, i));
            }
        }
        WithLatestFromSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
            this.values[outerIndex] = innerValue;
            var toRespond = this.toRespond;
            if (toRespond.length > 0) {
                var found = toRespond.indexOf(outerIndex);
                if (found !== -1) {
                    toRespond.splice(found, 1);
                }
            }
        };
        WithLatestFromSubscriber.prototype.notifyComplete = function () {
            // noop
        };
        WithLatestFromSubscriber.prototype._next = function (value) {
            if (this.toRespond.length === 0) {
                var args = [value].concat(this.values);
                if (this.project) {
                    this._tryProject(args);
                }
                else {
                    this.destination.next(args);
                }
            }
        };
        WithLatestFromSubscriber.prototype._tryProject = function (args) {
            var result;
            try {
                result = this.project.apply(this, args);
            }
            catch (err) {
                this.destination.error(err);
                return;
            }
            this.destination.next(result);
        };
        return WithLatestFromSubscriber;
    }(OuterSubscriber_1.OuterSubscriber));


    var withLatestFrom_1 = {
    	withLatestFrom: withLatestFrom_2
    };

    /* tslint:enable:max-line-length */
    /**
     * Combines the source Observable with other Observables to create an Observable
     * whose values are calculated from the latest values of each, only when the
     * source emits.
     *
     * <span class="informal">Whenever the source Observable emits a value, it
     * computes a formula using that value plus the latest values from other input
     * Observables, then emits the output of that formula.</span>
     *
     * <img src="./img/withLatestFrom.png" width="100%">
     *
     * `withLatestFrom` combines each value from the source Observable (the
     * instance) with the latest values from the other input Observables only when
     * the source emits a value, optionally using a `project` function to determine
     * the value to be emitted on the output Observable. All input Observables must
     * emit at least one value before the output Observable will emit a value.
     *
     * @example <caption>On every click event, emit an array with the latest timer event plus the click event</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * var timer = Rx.Observable.interval(1000);
     * var result = clicks.withLatestFrom(timer);
     * result.subscribe(x => console.log(x));
     *
     * @see {@link combineLatest}
     *
     * @param {ObservableInput} other An input Observable to combine with the source
     * Observable. More than one input Observables may be given as argument.
     * @param {Function} [project] Projection function for combining values
     * together. Receives all values in order of the Observables passed, where the
     * first parameter is a value from the source Observable. (e.g.
     * `a.withLatestFrom(b, c, (a1, b1, c1) => a1 + b1 + c1)`). If this is not
     * passed, arrays will be emitted on the output Observable.
     * @return {Observable} An Observable of projected values from the most recent
     * values from each input Observable, or an array of the most recent values from
     * each input Observable.
     * @method withLatestFrom
     * @owner Observable
     */
    function withLatestFrom$1() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i - 0] = arguments[_i];
        }
        return withLatestFrom_1.withLatestFrom.apply(void 0, args)(this);
    }
    var withLatestFrom_3 = withLatestFrom$1;


    var withLatestFrom_2$1 = {
    	withLatestFrom: withLatestFrom_3
    };

    Observable_1.Observable.prototype.withLatestFrom = withLatestFrom_2$1.withLatestFrom;

    /* tslint:enable:max-line-length */
    /**
     * @param observables
     * @return {Observable<R>}
     * @method zip
     * @owner Observable
     */
    function zipProto() {
        var observables = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            observables[_i - 0] = arguments[_i];
        }
        return zip_1.zip.apply(void 0, observables)(this);
    }
    var zipProto_1 = zipProto;


    var zip$3 = {
    	zipProto: zipProto_1
    };

    Observable_1.Observable.prototype.zip = zip$3.zipProto;

    function zipAll(project) {
        return function (source) { return source.lift(new zip_1.ZipOperator(project)); };
    }
    var zipAll_2 = zipAll;


    var zipAll_1 = {
    	zipAll: zipAll_2
    };

    /**
     * @param project
     * @return {Observable<R>|WebSocketSubject<T>|Observable<T>}
     * @method zipAll
     * @owner Observable
     */
    function zipAll$1(project) {
        return zipAll_1.zipAll(project)(this);
    }
    var zipAll_3 = zipAll$1;


    var zipAll_2$1 = {
    	zipAll: zipAll_3
    };

    Observable_1.Observable.prototype.zipAll = zipAll_2$1.zipAll;

    var SubscriptionLog = (function () {
        function SubscriptionLog(subscribedFrame, unsubscribedFrame) {
            if (unsubscribedFrame === void 0) { unsubscribedFrame = Number.POSITIVE_INFINITY; }
            this.subscribedFrame = subscribedFrame;
            this.unsubscribedFrame = unsubscribedFrame;
        }
        return SubscriptionLog;
    }());
    var SubscriptionLog_2 = SubscriptionLog;


    var SubscriptionLog_1 = {
    	SubscriptionLog: SubscriptionLog_2
    };

    var SubscriptionLoggable = (function () {
        function SubscriptionLoggable() {
            this.subscriptions = [];
        }
        SubscriptionLoggable.prototype.logSubscribedFrame = function () {
            this.subscriptions.push(new SubscriptionLog_1.SubscriptionLog(this.scheduler.now()));
            return this.subscriptions.length - 1;
        };
        SubscriptionLoggable.prototype.logUnsubscribedFrame = function (index) {
            var subscriptionLogs = this.subscriptions;
            var oldSubscriptionLog = subscriptionLogs[index];
            subscriptionLogs[index] = new SubscriptionLog_1.SubscriptionLog(oldSubscriptionLog.subscribedFrame, this.scheduler.now());
        };
        return SubscriptionLoggable;
    }());
    var SubscriptionLoggable_2 = SubscriptionLoggable;


    var SubscriptionLoggable_1 = {
    	SubscriptionLoggable: SubscriptionLoggable_2
    };

    function applyMixins(derivedCtor, baseCtors) {
        for (var i = 0, len = baseCtors.length; i < len; i++) {
            var baseCtor = baseCtors[i];
            var propertyKeys = Object.getOwnPropertyNames(baseCtor.prototype);
            for (var j = 0, len2 = propertyKeys.length; j < len2; j++) {
                var name_1 = propertyKeys[j];
                derivedCtor.prototype[name_1] = baseCtor.prototype[name_1];
            }
        }
    }
    var applyMixins_2 = applyMixins;


    var applyMixins_1 = {
    	applyMixins: applyMixins_2
    };

    var __extends$29 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };




    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var ColdObservable = (function (_super) {
        __extends$29(ColdObservable, _super);
        function ColdObservable(messages, scheduler) {
            _super.call(this, function (subscriber) {
                var observable = this;
                var index = observable.logSubscribedFrame();
                subscriber.add(new Subscription_1.Subscription(function () {
                    observable.logUnsubscribedFrame(index);
                }));
                observable.scheduleMessages(subscriber);
                return subscriber;
            });
            this.messages = messages;
            this.subscriptions = [];
            this.scheduler = scheduler;
        }
        ColdObservable.prototype.scheduleMessages = function (subscriber) {
            var messagesLength = this.messages.length;
            for (var i = 0; i < messagesLength; i++) {
                var message = this.messages[i];
                subscriber.add(this.scheduler.schedule(function (_a) {
                    var message = _a.message, subscriber = _a.subscriber;
                    message.notification.observe(subscriber);
                }, message.frame, { message: message, subscriber: subscriber }));
            }
        };
        return ColdObservable;
    }(Observable_1.Observable));
    var ColdObservable_2 = ColdObservable;
    applyMixins_1.applyMixins(ColdObservable, [SubscriptionLoggable_1.SubscriptionLoggable]);


    var ColdObservable_1 = {
    	ColdObservable: ColdObservable_2
    };

    var __extends$2a = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };




    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var HotObservable = (function (_super) {
        __extends$2a(HotObservable, _super);
        function HotObservable(messages, scheduler) {
            _super.call(this);
            this.messages = messages;
            this.subscriptions = [];
            this.scheduler = scheduler;
        }
        /** @deprecated internal use only */ HotObservable.prototype._subscribe = function (subscriber) {
            var subject = this;
            var index = subject.logSubscribedFrame();
            subscriber.add(new Subscription_1.Subscription(function () {
                subject.logUnsubscribedFrame(index);
            }));
            return _super.prototype._subscribe.call(this, subscriber);
        };
        HotObservable.prototype.setup = function () {
            var subject = this;
            var messagesLength = subject.messages.length;
            /* tslint:disable:no-var-keyword */
            for (var i = 0; i < messagesLength; i++) {
                (function () {
                    var message = subject.messages[i];
                    /* tslint:enable */
                    subject.scheduler.schedule(function () { message.notification.observe(subject); }, message.frame);
                })();
            }
        };
        return HotObservable;
    }(Subject_1.Subject));
    var HotObservable_2 = HotObservable;
    applyMixins_1.applyMixins(HotObservable, [SubscriptionLoggable_1.SubscriptionLoggable]);


    var HotObservable_1 = {
    	HotObservable: HotObservable_2
    };

    var __extends$2b = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };


    var VirtualTimeScheduler = (function (_super) {
        __extends$2b(VirtualTimeScheduler, _super);
        function VirtualTimeScheduler(SchedulerAction, maxFrames) {
            var _this = this;
            if (SchedulerAction === void 0) { SchedulerAction = VirtualAction; }
            if (maxFrames === void 0) { maxFrames = Number.POSITIVE_INFINITY; }
            _super.call(this, SchedulerAction, function () { return _this.frame; });
            this.maxFrames = maxFrames;
            this.frame = 0;
            this.index = -1;
        }
        /**
         * Prompt the Scheduler to execute all of its queued actions, therefore
         * clearing its queue.
         * @return {void}
         */
        VirtualTimeScheduler.prototype.flush = function () {
            var _a = this, actions = _a.actions, maxFrames = _a.maxFrames;
            var error, action;
            while ((action = actions.shift()) && (this.frame = action.delay) <= maxFrames) {
                if (error = action.execute(action.state, action.delay)) {
                    break;
                }
            }
            if (error) {
                while (action = actions.shift()) {
                    action.unsubscribe();
                }
                throw error;
            }
        };
        VirtualTimeScheduler.frameTimeFactor = 10;
        return VirtualTimeScheduler;
    }(AsyncScheduler_1.AsyncScheduler));
    var VirtualTimeScheduler_2 = VirtualTimeScheduler;
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var VirtualAction = (function (_super) {
        __extends$2b(VirtualAction, _super);
        function VirtualAction(scheduler, work, index) {
            if (index === void 0) { index = scheduler.index += 1; }
            _super.call(this, scheduler, work);
            this.scheduler = scheduler;
            this.work = work;
            this.index = index;
            this.active = true;
            this.index = scheduler.index = index;
        }
        VirtualAction.prototype.schedule = function (state, delay) {
            if (delay === void 0) { delay = 0; }
            if (!this.id) {
                return _super.prototype.schedule.call(this, state, delay);
            }
            this.active = false;
            // If an action is rescheduled, we save allocations by mutating its state,
            // pushing it to the end of the scheduler queue, and recycling the action.
            // But since the VirtualTimeScheduler is used for testing, VirtualActions
            // must be immutable so they can be inspected later.
            var action = new VirtualAction(this.scheduler, this.work);
            this.add(action);
            return action.schedule(state, delay);
        };
        VirtualAction.prototype.requestAsyncId = function (scheduler, id, delay) {
            if (delay === void 0) { delay = 0; }
            this.delay = scheduler.frame + delay;
            var actions = scheduler.actions;
            actions.push(this);
            actions.sort(VirtualAction.sortActions);
            return true;
        };
        VirtualAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
            if (delay === void 0) { delay = 0; }
            return undefined;
        };
        VirtualAction.prototype._execute = function (state, delay) {
            if (this.active === true) {
                return _super.prototype._execute.call(this, state, delay);
            }
        };
        VirtualAction.sortActions = function (a, b) {
            if (a.delay === b.delay) {
                if (a.index === b.index) {
                    return 0;
                }
                else if (a.index > b.index) {
                    return 1;
                }
                else {
                    return -1;
                }
            }
            else if (a.delay > b.delay) {
                return 1;
            }
            else {
                return -1;
            }
        };
        return VirtualAction;
    }(AsyncAction_1.AsyncAction));
    var VirtualAction_1 = VirtualAction;


    var VirtualTimeScheduler_1 = {
    	VirtualTimeScheduler: VirtualTimeScheduler_2,
    	VirtualAction: VirtualAction_1
    };

    var __extends$2c = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };






    var defaultMaxFrame = 750;
    var TestScheduler = (function (_super) {
        __extends$2c(TestScheduler, _super);
        function TestScheduler(assertDeepEqual) {
            _super.call(this, VirtualTimeScheduler_1.VirtualAction, defaultMaxFrame);
            this.assertDeepEqual = assertDeepEqual;
            this.hotObservables = [];
            this.coldObservables = [];
            this.flushTests = [];
        }
        TestScheduler.prototype.createTime = function (marbles) {
            var indexOf = marbles.indexOf('|');
            if (indexOf === -1) {
                throw new Error('marble diagram for time should have a completion marker "|"');
            }
            return indexOf * TestScheduler.frameTimeFactor;
        };
        TestScheduler.prototype.createColdObservable = function (marbles, values, error) {
            if (marbles.indexOf('^') !== -1) {
                throw new Error('cold observable cannot have subscription offset "^"');
            }
            if (marbles.indexOf('!') !== -1) {
                throw new Error('cold observable cannot have unsubscription marker "!"');
            }
            var messages = TestScheduler.parseMarbles(marbles, values, error);
            var cold = new ColdObservable_1.ColdObservable(messages, this);
            this.coldObservables.push(cold);
            return cold;
        };
        TestScheduler.prototype.createHotObservable = function (marbles, values, error) {
            if (marbles.indexOf('!') !== -1) {
                throw new Error('hot observable cannot have unsubscription marker "!"');
            }
            var messages = TestScheduler.parseMarbles(marbles, values, error);
            var subject = new HotObservable_1.HotObservable(messages, this);
            this.hotObservables.push(subject);
            return subject;
        };
        TestScheduler.prototype.materializeInnerObservable = function (observable, outerFrame) {
            var _this = this;
            var messages = [];
            observable.subscribe(function (value) {
                messages.push({ frame: _this.frame - outerFrame, notification: Notification_1.Notification.createNext(value) });
            }, function (err) {
                messages.push({ frame: _this.frame - outerFrame, notification: Notification_1.Notification.createError(err) });
            }, function () {
                messages.push({ frame: _this.frame - outerFrame, notification: Notification_1.Notification.createComplete() });
            });
            return messages;
        };
        TestScheduler.prototype.expectObservable = function (observable, unsubscriptionMarbles) {
            var _this = this;
            if (unsubscriptionMarbles === void 0) { unsubscriptionMarbles = null; }
            var actual = [];
            var flushTest = { actual: actual, ready: false };
            var unsubscriptionFrame = TestScheduler
                .parseMarblesAsSubscriptions(unsubscriptionMarbles).unsubscribedFrame;
            var subscription;
            this.schedule(function () {
                subscription = observable.subscribe(function (x) {
                    var value = x;
                    // Support Observable-of-Observables
                    if (x instanceof Observable_1.Observable) {
                        value = _this.materializeInnerObservable(value, _this.frame);
                    }
                    actual.push({ frame: _this.frame, notification: Notification_1.Notification.createNext(value) });
                }, function (err) {
                    actual.push({ frame: _this.frame, notification: Notification_1.Notification.createError(err) });
                }, function () {
                    actual.push({ frame: _this.frame, notification: Notification_1.Notification.createComplete() });
                });
            }, 0);
            if (unsubscriptionFrame !== Number.POSITIVE_INFINITY) {
                this.schedule(function () { return subscription.unsubscribe(); }, unsubscriptionFrame);
            }
            this.flushTests.push(flushTest);
            return {
                toBe: function (marbles, values, errorValue) {
                    flushTest.ready = true;
                    flushTest.expected = TestScheduler.parseMarbles(marbles, values, errorValue, true);
                }
            };
        };
        TestScheduler.prototype.expectSubscriptions = function (actualSubscriptionLogs) {
            var flushTest = { actual: actualSubscriptionLogs, ready: false };
            this.flushTests.push(flushTest);
            return {
                toBe: function (marbles) {
                    var marblesArray = (typeof marbles === 'string') ? [marbles] : marbles;
                    flushTest.ready = true;
                    flushTest.expected = marblesArray.map(function (marbles) {
                        return TestScheduler.parseMarblesAsSubscriptions(marbles);
                    });
                }
            };
        };
        TestScheduler.prototype.flush = function () {
            var hotObservables = this.hotObservables;
            while (hotObservables.length > 0) {
                hotObservables.shift().setup();
            }
            _super.prototype.flush.call(this);
            var readyFlushTests = this.flushTests.filter(function (test) { return test.ready; });
            while (readyFlushTests.length > 0) {
                var test = readyFlushTests.shift();
                this.assertDeepEqual(test.actual, test.expected);
            }
        };
        TestScheduler.parseMarblesAsSubscriptions = function (marbles) {
            if (typeof marbles !== 'string') {
                return new SubscriptionLog_1.SubscriptionLog(Number.POSITIVE_INFINITY);
            }
            var len = marbles.length;
            var groupStart = -1;
            var subscriptionFrame = Number.POSITIVE_INFINITY;
            var unsubscriptionFrame = Number.POSITIVE_INFINITY;
            for (var i = 0; i < len; i++) {
                var frame = i * this.frameTimeFactor;
                var c = marbles[i];
                switch (c) {
                    case '-':
                    case ' ':
                        break;
                    case '(':
                        groupStart = frame;
                        break;
                    case ')':
                        groupStart = -1;
                        break;
                    case '^':
                        if (subscriptionFrame !== Number.POSITIVE_INFINITY) {
                            throw new Error('found a second subscription point \'^\' in a ' +
                                'subscription marble diagram. There can only be one.');
                        }
                        subscriptionFrame = groupStart > -1 ? groupStart : frame;
                        break;
                    case '!':
                        if (unsubscriptionFrame !== Number.POSITIVE_INFINITY) {
                            throw new Error('found a second subscription point \'^\' in a ' +
                                'subscription marble diagram. There can only be one.');
                        }
                        unsubscriptionFrame = groupStart > -1 ? groupStart : frame;
                        break;
                    default:
                        throw new Error('there can only be \'^\' and \'!\' markers in a ' +
                            'subscription marble diagram. Found instead \'' + c + '\'.');
                }
            }
            if (unsubscriptionFrame < 0) {
                return new SubscriptionLog_1.SubscriptionLog(subscriptionFrame);
            }
            else {
                return new SubscriptionLog_1.SubscriptionLog(subscriptionFrame, unsubscriptionFrame);
            }
        };
        TestScheduler.parseMarbles = function (marbles, values, errorValue, materializeInnerObservables) {
            if (materializeInnerObservables === void 0) { materializeInnerObservables = false; }
            if (marbles.indexOf('!') !== -1) {
                throw new Error('conventional marble diagrams cannot have the ' +
                    'unsubscription marker "!"');
            }
            var len = marbles.length;
            var testMessages = [];
            var subIndex = marbles.indexOf('^');
            var frameOffset = subIndex === -1 ? 0 : (subIndex * -this.frameTimeFactor);
            var getValue = typeof values !== 'object' ?
                function (x) { return x; } :
                function (x) {
                    // Support Observable-of-Observables
                    if (materializeInnerObservables && values[x] instanceof ColdObservable_1.ColdObservable) {
                        return values[x].messages;
                    }
                    return values[x];
                };
            var groupStart = -1;
            for (var i = 0; i < len; i++) {
                var frame = i * this.frameTimeFactor + frameOffset;
                var notification = void 0;
                var c = marbles[i];
                switch (c) {
                    case '-':
                    case ' ':
                        break;
                    case '(':
                        groupStart = frame;
                        break;
                    case ')':
                        groupStart = -1;
                        break;
                    case '|':
                        notification = Notification_1.Notification.createComplete();
                        break;
                    case '^':
                        break;
                    case '#':
                        notification = Notification_1.Notification.createError(errorValue || 'error');
                        break;
                    default:
                        notification = Notification_1.Notification.createNext(getValue(c));
                        break;
                }
                if (notification) {
                    testMessages.push({ frame: groupStart > -1 ? groupStart : frame, notification: notification });
                }
            }
            return testMessages;
        };
        return TestScheduler;
    }(VirtualTimeScheduler_1.VirtualTimeScheduler));

    var RequestAnimationFrameDefinition = (function () {
        function RequestAnimationFrameDefinition(root$$1) {
            if (root$$1.requestAnimationFrame) {
                this.cancelAnimationFrame = root$$1.cancelAnimationFrame.bind(root$$1);
                this.requestAnimationFrame = root$$1.requestAnimationFrame.bind(root$$1);
            }
            else if (root$$1.mozRequestAnimationFrame) {
                this.cancelAnimationFrame = root$$1.mozCancelAnimationFrame.bind(root$$1);
                this.requestAnimationFrame = root$$1.mozRequestAnimationFrame.bind(root$$1);
            }
            else if (root$$1.webkitRequestAnimationFrame) {
                this.cancelAnimationFrame = root$$1.webkitCancelAnimationFrame.bind(root$$1);
                this.requestAnimationFrame = root$$1.webkitRequestAnimationFrame.bind(root$$1);
            }
            else if (root$$1.msRequestAnimationFrame) {
                this.cancelAnimationFrame = root$$1.msCancelAnimationFrame.bind(root$$1);
                this.requestAnimationFrame = root$$1.msRequestAnimationFrame.bind(root$$1);
            }
            else if (root$$1.oRequestAnimationFrame) {
                this.cancelAnimationFrame = root$$1.oCancelAnimationFrame.bind(root$$1);
                this.requestAnimationFrame = root$$1.oRequestAnimationFrame.bind(root$$1);
            }
            else {
                this.cancelAnimationFrame = root$$1.clearTimeout.bind(root$$1);
                this.requestAnimationFrame = function (cb) { return root$$1.setTimeout(cb, 1000 / 60); };
            }
        }
        return RequestAnimationFrameDefinition;
    }());
    var RequestAnimationFrameDefinition_1 = RequestAnimationFrameDefinition;
    var AnimationFrame_1 = new RequestAnimationFrameDefinition(root.root);


    var AnimationFrame = {
    	RequestAnimationFrameDefinition: RequestAnimationFrameDefinition_1,
    	AnimationFrame: AnimationFrame_1
    };

    var __extends$2d = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };


    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var AnimationFrameAction = (function (_super) {
        __extends$2d(AnimationFrameAction, _super);
        function AnimationFrameAction(scheduler, work) {
            _super.call(this, scheduler, work);
            this.scheduler = scheduler;
            this.work = work;
        }
        AnimationFrameAction.prototype.requestAsyncId = function (scheduler, id, delay) {
            if (delay === void 0) { delay = 0; }
            // If delay is greater than 0, request as an async action.
            if (delay !== null && delay > 0) {
                return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
            }
            // Push the action to the end of the scheduler queue.
            scheduler.actions.push(this);
            // If an animation frame has already been requested, don't request another
            // one. If an animation frame hasn't been requested yet, request one. Return
            // the current animation frame request id.
            return scheduler.scheduled || (scheduler.scheduled = AnimationFrame.AnimationFrame.requestAnimationFrame(scheduler.flush.bind(scheduler, null)));
        };
        AnimationFrameAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
            if (delay === void 0) { delay = 0; }
            // If delay exists and is greater than 0, or if the delay is null (the
            // action wasn't rescheduled) but was originally scheduled as an async
            // action, then recycle as an async action.
            if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
                return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
            }
            // If the scheduler queue is empty, cancel the requested animation frame and
            // set the scheduled flag to undefined so the next AnimationFrameAction will
            // request its own.
            if (scheduler.actions.length === 0) {
                AnimationFrame.AnimationFrame.cancelAnimationFrame(id);
                scheduler.scheduled = undefined;
            }
            // Return undefined so the action knows to request a new async id if it's rescheduled.
            return undefined;
        };
        return AnimationFrameAction;
    }(AsyncAction_1.AsyncAction));
    var AnimationFrameAction_2 = AnimationFrameAction;


    var AnimationFrameAction_1 = {
    	AnimationFrameAction: AnimationFrameAction_2
    };

    var __extends$2e = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };

    var AnimationFrameScheduler = (function (_super) {
        __extends$2e(AnimationFrameScheduler, _super);
        function AnimationFrameScheduler() {
            _super.apply(this, arguments);
        }
        AnimationFrameScheduler.prototype.flush = function (action) {
            this.active = true;
            this.scheduled = undefined;
            var actions = this.actions;
            var error;
            var index = -1;
            var count = actions.length;
            action = action || actions.shift();
            do {
                if (error = action.execute(action.state, action.delay)) {
                    break;
                }
            } while (++index < count && (action = actions.shift()));
            this.active = false;
            if (error) {
                while (++index < count && (action = actions.shift())) {
                    action.unsubscribe();
                }
                throw error;
            }
        };
        return AnimationFrameScheduler;
    }(AsyncScheduler_1.AsyncScheduler));
    var AnimationFrameScheduler_2 = AnimationFrameScheduler;


    var AnimationFrameScheduler_1 = {
    	AnimationFrameScheduler: AnimationFrameScheduler_2
    };

    /**
     *
     * Animation Frame Scheduler
     *
     * <span class="informal">Perform task when `window.requestAnimationFrame` would fire</span>
     *
     * When `animationFrame` scheduler is used with delay, it will fall back to {@link async} scheduler
     * behaviour.
     *
     * Without delay, `animationFrame` scheduler can be used to create smooth browser animations.
     * It makes sure scheduled task will happen just before next browser content repaint,
     * thus performing animations as efficiently as possible.
     *
     * @example <caption>Schedule div height animation</caption>
     * const div = document.querySelector('.some-div');
     *
     * Rx.Scheduler.schedule(function(height) {
     *   div.style.height = height + "px";
     *
     *   this.schedule(height + 1);  // `this` references currently executing Action,
     *                               // which we reschedule with new state
     * }, 0, 0);
     *
     * // You will see .some-div element growing in height
     *
     *
     * @static true
     * @name animationFrame
     * @owner Scheduler
     */
    var animationFrame_1 = new AnimationFrameScheduler_1.AnimationFrameScheduler(AnimationFrameAction_1.AnimationFrameAction);

    var throttle$2 = throttle_1.throttle;

    /* tslint:disable:no-unused-variable */
    // Subject imported before Observable to bypass circular dependency issue since
    // Subject extends Observable and Observable references Subject in it's
    // definition

    var Subject$1 = Subject_1.Subject;
    /**
     * @typedef {Object} Rx.Symbol
     * @property {Symbol|string} rxSubscriber A symbol to use as a property name to
     * retrieve an "Rx safe" Observer from an object. "Rx safety" can be defined as
     * an object that has all of the traits of an Rx Subscriber, including the
     * ability to add and remove subscriptions to the subscription chain and
     * guarantees involving event triggering (can't "next" after unsubscription,
     * etc).
     * @property {Symbol|string} observable A symbol to use as a property name to
     * retrieve an Observable as defined by the [ECMAScript "Observable" spec](https://github.com/zenparsing/es-observable).
     * @property {Symbol|string} iterator The ES6 symbol to use as a property name
     * to retrieve an iterator from an object.
     */
    var Symbol = {
        rxSubscriber: rxSubscriber.rxSubscriber,
        observable: observable.observable,
        iterator: iterator.iterator
    };

    var __decorate$11 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata$B = (undefined && undefined.__metadata) || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    /**
     * Notification service used to notify user about important events in the application.
     *
     * You may configure the service with: setDelay, setVerbose and setPersist.
     */
    var NotificationService = /** @class */ (function () {
        /**
         * The default constructor
         */
        function NotificationService() {
            var _this = this;
            // time (in ms) the notifications are shown
            this.delay = 8000;
            this.modes = {};
            this.notifications = {};
            this.persist = { 'error': true, 'httpError': true };
            this.verbose = false;
            this._notificationsSubject = new Subject$1();
            this.notifications.data = [];
            this.modes = [
                { info: { type: NotificationType.INFO, header: 'Info!', log: 'info' } },
                { success: { type: NotificationType.SUCCESS, header: 'Success!', log: 'info' } },
                { error: { type: NotificationType.DANGER, header: 'Error!', log: 'error' } },
                { warn: { type: NotificationType.WARNING, header: 'Warning!', log: 'warn' } }
            ];
            this.modes.forEach(function (mode, index) {
                _this.notifications[index] = _this.createNotifyMethod(index);
            });
        }
        /**
         * Get all notifications
         */
        NotificationService.prototype.getNotifications = function () {
            return this.notifications.data;
        };
        Object.defineProperty(NotificationService.prototype, "getNotificationsObserver", {
            /**
             * Allows for interacting with a stream of notifications
             */
            get: function () {
                return this._notificationsSubject.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Generate a notification for the given HTTP Response
         *
         * @param message The notification message
         * @param httpResponse The HTTP Response
         */
        NotificationService.prototype.httpError = function (message, httpResponse) {
            message += ' (' + (httpResponse.data.message || httpResponse.data.cause
                || httpResponse.data.cause || httpResponse.data.errorMessage) + ')';
            this.message('danger', 'Error!', message, this.persist.httpError, null, null);
            if (this.verbose) {
                console.log(message);
            }
        };
        /**
         * Generate a notification message
         *
         * @param type The notification type
         * @param header The notification header
         * @param message The notification message
         * @param isPersistent True if the notification should be persistent
         * @param primaryAction The primary action for the notifiaction
         * @param moreActions More actions for the kebab
         */
        NotificationService.prototype.message = function (type, header, message, isPersistent, primaryAction, moreActions) {
            var _this = this;
            var notification = {
                header: header,
                isPersistent: isPersistent,
                isViewing: false,
                message: message,
                moreActions: moreActions,
                primaryAction: primaryAction,
                showClose: false,
                type: type,
                visible: true
            };
            this.notifications.data.push(notification);
            this.updateNotificationsStream();
            if (notification.isPersistent !== true) {
                notification.isViewing = false;
                setTimeout(function () {
                    notification.visible = false;
                    if (!notification.isViewing) {
                        _this.remove(notification);
                    }
                }, this.delay);
            }
        };
        /**
         * Remove notification
         *
         * @param notification The notification to remove
         */
        NotificationService.prototype.remove = function (notification) {
            var index = this.notifications.data.indexOf(notification);
            if (index !== -1) {
                this.removeIndex(index);
                this.updateNotificationsStream();
            }
        };
        /**
         * Set the delay after which the notification is dismissed. The argument of this method expects miliseconds. Default
         * delay is 8000 ms.
         *
         * @param delay The delay in ms
         */
        NotificationService.prototype.setDelay = function (delay) {
            this.delay = delay;
        };
        /**
         * Sets persist option for particular modes. Notification with persistent mode won't be dismissed after delay, but has
         * to be closed manually with the close button. By default, the "error" and "httpError" modes are set to persistent.
         *
         * @param persist Set to true to persist notifications
         */
        NotificationService.prototype.setPersist = function (persist) {
            this.persist = persist;
        };
        /**
         * Set the verbose mode to on (default) or off. During the verbose mode, each notification is printed in the console.
         *
         * @param verbose Set to true for verbose mode
         */
        NotificationService.prototype.setVerbose = function (verbose) {
            this.verbose = verbose;
        };
        /**
         * Set a flag indicating user is viewing the given notification
         *
         * @param notification The notification currently being viewed
         * @param isViewing True if the notification is being viewed
         */
        NotificationService.prototype.setViewing = function (notification, isViewing) {
            notification.isViewing = isViewing;
            if (isViewing !== true && notification.visible !== true) {
                this.remove(notification);
            }
        };
        // Private
        NotificationService.prototype.createNotifyMethod = function (index) {
            var _this = this;
            return function (message, header, persistent, primaryAction, moreActions) {
                if (header !== undefined) {
                    header = _this.modes[index].header;
                }
                if (persistent !== undefined) {
                    persistent = _this.persist[index];
                }
                _this.notifications.message(_this.modes[index].type, header, message, persistent, primaryAction, moreActions);
                if (_this.verbose) {
                    console.log(message);
                }
            };
        };
        NotificationService.prototype.removeIndex = function (index) {
            this.notifications.data.splice(index, 1);
        };
        NotificationService.prototype.updateNotificationsStream = function () {
            this._notificationsSubject.next(this.getNotifications());
        };
        NotificationService = __decorate$11([
            core.Injectable(),
            __metadata$B("design:paramtypes", [])
        ], NotificationService);
        return NotificationService;
    }());

    /**
     * A config containing properties for Pagination
     */
    var PaginationConfig = /** @class */ (function () {
        function PaginationConfig() {
        }
        return PaginationConfig;
    }());

    var __decorate$12 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata$C = (undefined && undefined.__metadata) || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    /**
     * Component for rendering pagination
     */
    var PaginationComponent = /** @class */ (function () {
        /**
         * The default constructor
         */
        function PaginationComponent() {
            /**
             * The Event is emitted when Page Size is changed
             */
            this.onPageSizeChange = new core.EventEmitter();
            /**
             * The Event is emitted when Page Number is Changed
             */
            this.onPageNumberChange = new core.EventEmitter();
            this.defaultConfig = {
                pageNumber: 1,
                pageSizeIncrements: [5, 10, 20, 40, 80, 100],
                pageSize: 5
            };
        }
        // Initialization
        /**
         * Setup component configuration upon initialization
         */
        PaginationComponent.prototype.ngOnInit = function () {
            this.setupConfig();
            this.lastPageNumber = this.getLastPageNumber();
        };
        /**
         * Check if the component config has changed
         */
        PaginationComponent.prototype.ngDoCheck = function () {
            // Do a deep compare on config
            if (!lodash.isEqual(this.config, this.prevConfig)) {
                this.setupConfig();
            }
        };
        /**
         * Setup default config
         */
        PaginationComponent.prototype.setupConfig = function () {
            if (this.config !== undefined) {
                lodash.defaults(this.config, this.defaultConfig);
            }
            else {
                this.config = lodash.cloneDeep(this.defaultConfig);
            }
            this.lastPageNumber = this.getLastPageNumber();
            this.pageNumber = this.config.pageNumber;
            this.prevConfig = lodash.cloneDeep(this.config);
        };
        Object.defineProperty(PaginationComponent.prototype, "pageNumber", {
            // Accessors
            get: function () {
                return (this.config.totalItems !== undefined && this.config.totalItems > 0) ? this._pageNumber : 0;
            },
            set: function (pageNumber) {
                this._pageNumber = pageNumber;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PaginationComponent.prototype, "lastPageNumber", {
            /**
             * Return last page number
             */
            get: function () {
                return (this.config.totalItems !== undefined && this.config.totalItems > 0) ? this._lastPageNumber : 0;
            },
            /**
             * Update Last page Number
             */
            set: function (value) {
                this._lastPageNumber = value;
            },
            enumerable: true,
            configurable: true
        });
        // Actions
        /**
         * Jump to First Page
         */
        PaginationComponent.prototype.gotoFirstPage = function () {
            if (this.config.pageNumber !== 1) {
                this.updatePageNumber(1);
            }
        };
        /**
         * Go to Previous Page
         */
        PaginationComponent.prototype.gotoPreviousPage = function () {
            if (this.config.pageNumber !== 1) {
                this.updatePageNumber(this.config.pageNumber - 1);
            }
        };
        /**
         * Go to Next Page
         */
        PaginationComponent.prototype.gotoNextPage = function () {
            if (this.config.pageNumber < this.lastPageNumber) {
                this.updatePageNumber(this.config.pageNumber + 1);
            }
        };
        /**
         * Jump to Last Page
         */
        PaginationComponent.prototype.gotoLastPage = function () {
            if (this.config.pageNumber < this.lastPageNumber) {
                this.updatePageNumber(this.lastPageNumber);
            }
        };
        /**
         * Return start index and end index of current page
         */
        PaginationComponent.prototype.getCurrentPage = function () {
            return this.getStartIndex() + ' - ' + this.getEndIndex();
        };
        /**
         * Start Index of Current Page
         */
        PaginationComponent.prototype.getStartIndex = function () {
            return (this.config.totalItems !== undefined && this.config.totalItems > 0)
                ? this.config.pageSize * (this.config.pageNumber - 1) + 1 : 0;
        };
        /**
         * End Index of Current Page
         */
        PaginationComponent.prototype.getEndIndex = function () {
            var numFullPages = Math.floor(this.config.totalItems / this.config.pageSize);
            var numItemsOnLastPage = this.config.totalItems - (numFullPages * this.config.pageSize) || this.config.pageSize;
            var numItemsOnPage = this.isLastPage() ? numItemsOnLastPage : this.config.pageSize;
            return (this.config.totalItems !== undefined && this.config.totalItems > 0)
                ? (this.getStartIndex() + numItemsOnPage - 1) : 0;
        };
        /**
         * Page number is changed via input field's focus event
         */
        PaginationComponent.prototype.onPageNumberBlur = function ($event) {
            var newPageNumber = parseInt(String(this.pageNumber), 10);
            if (isNaN(newPageNumber)) {
                newPageNumber = this.pageNumber = this.config.pageNumber;
            }
            if (newPageNumber > this.lastPageNumber) {
                this.updatePageNumber(this.lastPageNumber);
            }
            else if (newPageNumber < 1) {
                this.updatePageNumber(1);
            }
            else {
                this.updatePageNumber(newPageNumber);
            }
        };
        /**
         * Page number is changed via input field's keyboard event
         */
        PaginationComponent.prototype.onPageNumberKeyup = function ($event) {
            var keycode = $event.keyCode ? $event.keyCode : $event.which;
            if (keycode === 13) {
                this.onPageNumberBlur(null);
            }
        };
        // Private
        /**
         * Page size is changed
         * @param newPageSize new page size
         */
        PaginationComponent.prototype.onPageSizeUpdate = function ($event, newPageSize) {
            this.config.pageSize = newPageSize;
            this.lastPageNumber = this.getLastPageNumber();
            this.gotoFirstPage();
            this.onPageSizeChange.emit({
                pageSize: newPageSize
            });
        };
        /**
         * Update the Page Number
         * @param newPageNumber new page number
         */
        PaginationComponent.prototype.updatePageNumber = function (newPageNumber) {
            this.config.pageNumber = this.pageNumber = newPageNumber;
            this.onPageNumberChange.emit({
                pageNumber: newPageNumber
            });
        };
        /**
         * Get Last Page Number
         */
        PaginationComponent.prototype.getLastPageNumber = function () {
            return Math.ceil(this.config.totalItems / this.config.pageSize);
        };
        /**
         * Check if current Page is Last Page
         */
        PaginationComponent.prototype.isLastPage = function () {
            return (this.config.pageNumber === this.lastPageNumber);
        };
        __decorate$12([
            core.Input(),
            __metadata$C("design:type", PaginationConfig)
        ], PaginationComponent.prototype, "config", void 0);
        __decorate$12([
            core.Output('onPageSizeChange'),
            __metadata$C("design:type", Object)
        ], PaginationComponent.prototype, "onPageSizeChange", void 0);
        __decorate$12([
            core.Output('onPageNumberChange'),
            __metadata$C("design:type", Object)
        ], PaginationComponent.prototype, "onPageNumberChange", void 0);
        PaginationComponent = __decorate$12([
            core.Component({
                encapsulation: core.ViewEncapsulation.None,
                selector: 'pfng-pagination',
                template: "<form class=\"content-view-pf-pagination list-view-pf-pagination clearfix\"><div class=\"form-group\"><div class=\"padding-right-10\"><div class=\"btn-group dropdown\" dropdown><button #pageSizeMenu type=\"button\" class=\"btn btn-default dropdown-toggle\" dropdownToggle>{{config.pageSize}}<span class=\"caret\"></span></button><ul class=\"dropdown-menu\" *dropdownMenu><li class=\"display-length-increment\" [ngClass]=\"{'selected': increment === config?.pageSize}\" *ngFor=\"let increment of config?.pageSizeIncrements\"><a role=\"menuitem\" (click)=\"onPageSizeUpdate($event, increment)\">{{increment}}</a></li></ul></div></div><span for=\"pageSizeMenu\" class=\"per-page-label\">per page</span></div><div class=\"form-group\"><span><span class=\"pagination-pf-item-current\">{{getCurrentPage()}}</span>&nbsp;of&nbsp; <span class=\"pagination-pf-items-total\">{{config.totalItems}}</span></span><ul class=\"pagination pagination-pf-back\"><li [ngClass]=\"{'disabled': config.pageNumber === 1}\"><a class=\"goto-first-page\" title=\"First Page\" (click)=\"gotoFirstPage()\"><span class=\"i fa fa-angle-double-left\"></span></a></li><li [ngClass]=\"{'disabled': config.pageNumber === 1}\"><a class=\"goto-prev-page\" title=\"Previous Page\" (click)=\"gotoPreviousPage()\"><span class=\"i fa fa-angle-left\"></span></a></li></ul><input class=\"pagination-pf-page\" name=\"pageNumber\" type=\"text\" [(ngModel)]=\"pageNumber\" (blur)=\"onPageNumberBlur($event)\" (keyup.enter)=\"onPageNumberKeyup($event)\"> <span>of&nbsp;<span class=\"pagination-pf-pages\">{{lastPageNumber}}</span></span><ul class=\"pagination pagination-pf-forward\"><li [ngClass]=\"{'disabled': config.pageNumber === lastPageNumber}\"><a class=\"goto-next-page\" title=\"Next Page\" (click)=\"gotoNextPage()\"><span class=\"i fa fa-angle-right\"></span></a></li><li [ngClass]=\"{'disabled': config.pageNumber === lastPageNumber}\"><a class=\"goto-last-page\" title=\"Last Page\" (click)=\"gotoLastPage()\"><span class=\"i fa fa-angle-double-right\"></span></a></li></ul></div></form>"
            }),
            __metadata$C("design:paramtypes", [])
        ], PaginationComponent);
        return PaginationComponent;
    }());

    /**
     * An object containing properties for pagination events
     */
    var PaginationEvent = /** @class */ (function () {
        function PaginationEvent() {
        }
        return PaginationEvent;
    }());

    var __decorate$13 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    /**
     * A module containing objects associated with notification components
     */
    var PaginationModule = /** @class */ (function () {
        function PaginationModule() {
        }
        PaginationModule = __decorate$13([
            core.NgModule({
                imports: [
                    BsDropdownModule.forRoot(),
                    common.CommonModule,
                    forms.FormsModule
                ],
                declarations: [PaginationComponent],
                exports: [PaginationComponent],
                providers: [BsDropdownConfig]
            })
        ], PaginationModule);
        return PaginationModule;
    }());

    var __decorate$14 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata$D = (undefined && undefined.__metadata) || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    /**
     * A module containing objects associated with pipes
     *
     * @deprecated Use individual module imports
     *
     * import {
     *   SearchHighlightModule,
     *   SortArrayModule,
     *   TruncateModule
     * } from 'patternfly-ng/pipe';
     */
    var PipeModule = /** @class */ (function () {
        function PipeModule() {
            console.log('patternfly-ng: PipeModule is deprecated; use SearchHighlightModule, ' +
                'SortArrayModule, or TruncateModule');
        }
        PipeModule = __decorate$14([
            core.NgModule({
                imports: [
                    SearchHighlightPipeModule,
                    SortArrayPipeModule,
                    TruncatePipeModule
                ],
                exports: [
                    SearchHighlightPipe,
                    SortArrayPipe,
                    TruncatePipe
                ]
            }),
            __metadata$D("design:paramtypes", [])
        ], PipeModule);
        return PipeModule;
    }());

    var __decorate$15 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata$E = (undefined && undefined.__metadata) || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    /**
     * Remaining Characters directive for showing a characters remaining count and triggering warning and error
     * behavior when passing specified thresholds. When the <code>charsRemainingWarning</code> threshold is passed,
     * the <code>chars-warn-remaining-pf</code> css class is applied to the <code>charsRemainingElement</code>, which by
     * default, turns the remaining count number <font color='red'>red</font>. By default, characters may be entered into
     * the text field after the <code>charsMaxLimit</code> limit has been reached, the remaining count number will become a
     * negative value. Setting the <code>blockInputAtMaxLimit</code> to <em>true</em>, will block additional input into the
     * text field after the max has been reached; additionally a right-click 'paste' will only paste characters until the
     * maximum character limit is reached.
     */
    var RemainingCharsCountDirective = /** @class */ (function () {
        /**
         * Default constructor
         *
         * @param el The element reference for this component
         * @param renderer The renderer service
         */
        function RemainingCharsCountDirective(el, renderer) {
            this.el = el;
            this.renderer = renderer;
            /**
             * Number representing the maximum number of characters allowed. Default is 100
             */
            this.charsMaxLimit = 100;
            /**
             * Number of remaining characters to warn upon. Default is 5
             */
            this.charsRemainingWarning = 5;
            /**
             * The event emitted when a remaining characters is over max limit
             */
            this.onOverCharsMaxLimit = new core.EventEmitter();
            /**
             * The event emitted when a remaining characters is under max limit
             */
            this.onUnderCharsMaxLimit = new core.EventEmitter();
            this.remainingChars = 0;
        }
        // Initialization
        /**
         * Setup component configuration upon initialization
         */
        RemainingCharsCountDirective.prototype.ngOnInit = function () {
            this.remainingChars = this.charsMaxLimit;
            this.checkRemainingChars();
        };
        // Actions
        /**
         * Handle key events
         *
         * Note: Using the keyup event Vs keypress to include backspace/delete
         *
         * @param $event A KeyboardEvent object
         */
        RemainingCharsCountDirective.prototype.handleKeypress = function ($event) {
            // Once the charsMaxLimit has been met or exceeded, prevent all keypresses from working
            if (this.blockInputAtMaxLimit && this.el.nativeElement.value.length >= this.charsMaxLimit) {
                // Except backspace
                if ($event.keyCode !== 8) {
                    $event.preventDefault();
                }
            }
            this.checkRemainingChars();
        };
        /**
         * Helper to check remaining characters
         */
        RemainingCharsCountDirective.prototype.checkRemainingChars = function () {
            this.setRemainingChars();
            this.setRemainingCharsWarning();
            this.emitRemainingCharsEvent();
        };
        /**
         * Emit remaining characters event
         */
        RemainingCharsCountDirective.prototype.emitRemainingCharsEvent = function () {
            if (this.remainingChars <= 0) {
                this.onOverCharsMaxLimit.emit(this.remainingChars);
            }
            else {
                this.onUnderCharsMaxLimit.emit(this.remainingChars);
            }
        };
        /**
         * Set remaining characters
         */
        RemainingCharsCountDirective.prototype.setRemainingChars = function () {
            var charsLength = this.el.nativeElement.value.length;
            // Trim if blockInputAtMaxLimit and over limit
            if (this.blockInputAtMaxLimit && charsLength > this.charsMaxLimit) {
                this.el.nativeElement.value = this.el.nativeElement.value.substring(0, this.charsMaxLimit);
                charsLength = this.el.nativeElement.value.length;
            }
            this.remainingChars = this.charsMaxLimit - charsLength;
        };
        /**
         * Set remaining characters warning
         */
        RemainingCharsCountDirective.prototype.setRemainingCharsWarning = function () {
            if (this.charsRemainingElement !== undefined) {
                this.charsRemainingElement.innerText = this.remainingChars;
                if (this.remainingChars <= this.charsRemainingWarning) {
                    this.renderer.addClass(this.charsRemainingElement, 'chars-warn-remaining-pf');
                }
                else {
                    this.renderer.removeClass(this.charsRemainingElement, 'chars-warn-remaining-pf');
                }
            }
        };
        __decorate$15([
            core.Input(),
            __metadata$E("design:type", Boolean)
        ], RemainingCharsCountDirective.prototype, "blockInputAtMaxLimit", void 0);
        __decorate$15([
            core.Input(),
            __metadata$E("design:type", Number)
        ], RemainingCharsCountDirective.prototype, "charsMaxLimit", void 0);
        __decorate$15([
            core.Input(),
            __metadata$E("design:type", Object)
        ], RemainingCharsCountDirective.prototype, "charsRemainingElement", void 0);
        __decorate$15([
            core.Input(),
            __metadata$E("design:type", Number)
        ], RemainingCharsCountDirective.prototype, "charsRemainingWarning", void 0);
        __decorate$15([
            core.Output('onOverCharsMaxLimit'),
            __metadata$E("design:type", Object)
        ], RemainingCharsCountDirective.prototype, "onOverCharsMaxLimit", void 0);
        __decorate$15([
            core.Output('onUnderCharsMaxLimit'),
            __metadata$E("design:type", Object)
        ], RemainingCharsCountDirective.prototype, "onUnderCharsMaxLimit", void 0);
        __decorate$15([
            core.HostListener('keyup', ['$event']),
            __metadata$E("design:type", Function),
            __metadata$E("design:paramtypes", [KeyboardEvent]),
            __metadata$E("design:returntype", void 0)
        ], RemainingCharsCountDirective.prototype, "handleKeypress", null);
        RemainingCharsCountDirective = __decorate$15([
            core.Directive({
                selector: '[pfng-remaining-chars-count]'
            }),
            __metadata$E("design:paramtypes", [core.ElementRef, core.Renderer2])
        ], RemainingCharsCountDirective);
        return RemainingCharsCountDirective;
    }());

    var __decorate$16 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    /**
     * A module containing objects associated with the remaining characters directive
     */
    var RemainingCharsCountModule = /** @class */ (function () {
        function RemainingCharsCountModule() {
        }
        RemainingCharsCountModule = __decorate$16([
            core.NgModule({
                imports: [common.CommonModule, forms.FormsModule],
                declarations: [RemainingCharsCountDirective],
                exports: [RemainingCharsCountDirective]
            })
        ], RemainingCharsCountModule);
        return RemainingCharsCountModule;
    }());

    var __decorate$17 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata$F = (undefined && undefined.__metadata) || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    /**
     * Sample component
     */
    var SampleComponent = /** @class */ (function () {
        /**
         * The default constructor
         */
        function SampleComponent() {
        }
        __decorate$17([
            core.Input(),
            __metadata$F("design:type", Boolean)
        ], SampleComponent.prototype, "disabled", void 0);
        __decorate$17([
            core.Input(),
            __metadata$F("design:type", String)
        ], SampleComponent.prototype, "label", void 0);
        SampleComponent = __decorate$17([
            core.Component({
                encapsulation: core.ViewEncapsulation.None,
                selector: 'pf-sample-component',
                styles: ["\n    .pfng__samplecomponent { \n      color: blueviolet; \n    }\n    .pfng__samplecomponent--disabled  { \n      color: grey; \n    }\n  "],
                template: "<div class=\"pfng__samplecomponent\" [ngClass]=\"{'pfng__samplecomponent--disabled': disabled}\">{{label}}</div>"
            }),
            __metadata$F("design:paramtypes", [])
        ], SampleComponent);
        return SampleComponent;
    }());

    var __decorate$18 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    /**
     * A module containing objects associated with the sample component
     */
    var SampleModule = /** @class */ (function () {
        function SampleModule() {
        }
        SampleModule = __decorate$18([
            core.NgModule({
                imports: [common.CommonModule],
                declarations: [SampleComponent],
                exports: [SampleComponent]
            })
        ], SampleModule);
        return SampleModule;
    }());

    /**
     * A config containing properties for sort
     */
    var SortConfig = /** @class */ (function () {
        function SortConfig() {
        }
        return SortConfig;
    }());

    var __decorate$19 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata$G = (undefined && undefined.__metadata) || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    /**
     * Sort component
     */
    var SortComponent = /** @class */ (function () {
        /**
         * The default constructor
         */
        function SortComponent() {
            /**
             * The event emitted when the sort has changed
             */
            this.onChange = new core.EventEmitter();
            this.defaultConfig = {
                isAscending: true,
                visible: true
            };
        }
        /**
         * Setup component configuration upon initialization
         */
        SortComponent.prototype.ngOnInit = function () {
            this.setupConfig();
        };
        /**
         * Check if the component config has changed
         */
        SortComponent.prototype.ngDoCheck = function () {
            // Do a deep compare on config
            if (!lodash.isEqual(this.config, this.prevConfig)) {
                this.setupConfig();
            }
        };
        /**
         * Set up default config
         */
        SortComponent.prototype.setupConfig = function () {
            if (this.config !== undefined) {
                lodash.defaults(this.config, this.defaultConfig);
            }
            else {
                this.config = lodash.cloneDeep(this.defaultConfig);
            }
            if (this.config && this.config.fields && this.config.fields.length > 0) {
                if (this.currentField === undefined) {
                    this.currentField = this.config.fields[0];
                }
                if (this.config.isAscending === undefined) {
                    this.config.isAscending = true;
                }
            }
            this.prevConfig = lodash.cloneDeep(this.config);
        };
        // Actions
        SortComponent.prototype.getIconStyleClass = function () {
            var iconStyleClass;
            if (this.currentField && this.currentField.sortType
                && this.currentField.sortType === 'numeric') {
                if (this.config.isAscending) {
                    iconStyleClass = 'fa fa-sort-numeric-asc';
                }
                else {
                    iconStyleClass = 'fa fa-sort-numeric-desc';
                }
            }
            else {
                if (this.config.isAscending) {
                    iconStyleClass = 'fa fa-sort-alpha-asc';
                }
                else {
                    iconStyleClass = 'fa fa-sort-alpha-desc';
                }
            }
            return iconStyleClass;
        };
        SortComponent.prototype.onChangeDirection = function () {
            this.config.isAscending = !this.config.isAscending;
            this.onChange.emit({
                field: this.currentField,
                isAscending: this.config.isAscending
            });
        };
        SortComponent.prototype.selectField = function (field) {
            this.currentField = field;
            this.onChange.emit({
                field: this.currentField,
                isAscending: this.config.isAscending
            });
        };
        __decorate$19([
            core.Input(),
            __metadata$G("design:type", SortConfig)
        ], SortComponent.prototype, "config", void 0);
        __decorate$19([
            core.Output('onChange'),
            __metadata$G("design:type", Object)
        ], SortComponent.prototype, "onChange", void 0);
        SortComponent = __decorate$19([
            core.Component({
                encapsulation: core.ViewEncapsulation.None,
                selector: 'pfng-sort',
                template: "<div class=\"sort-pf\" *ngIf=\"config?.visible !== false\"><div class=\"btn-group dropdown\" dropdown><button type=\"button\" class=\"btn btn-default dropdown-toggle\" dropdownToggle [disabled]=\"config.disabled === true\">{{currentField?.title}} <span class=\"caret\"></span></button><ul class=\"dropdown-menu\" role=\"menu\" *dropdownMenu><li role=\"menuitem\" *ngFor=\"let item of config?.fields\" [ngClass]=\"{'selected': item === currentField}\"><a href=\"javascript:void(0);\" class=\"sortfield sort-field dropdown-item\" tabindex=\"-1\" (click)=\"selectField(item)\">{{item?.title}}</a></li></ul></div><button class=\"btn btn-link\" type=\"button\" [disabled]=\"config.disabled === true\" (click)=\"onChangeDirection()\"><span class=\"sort-direction\" [ngClass]=\"getIconStyleClass()\"></span></button></div>"
            }),
            __metadata$G("design:paramtypes", [])
        ], SortComponent);
        return SortComponent;
    }());

    /**
     * An object containing properties for sort events
     */
    var SortEvent = /** @class */ (function () {
        function SortEvent() {
        }
        return SortEvent;
    }());

    /**
     * An object containing properties for a sortable field, used to select categories of sorting
     */
    var SortField = /** @class */ (function () {
        function SortField() {
        }
        return SortField;
    }());

    var __decorate$1a = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    /**
     * A module containing objects associated with the sort component
     */
    var SortModule = /** @class */ (function () {
        function SortModule() {
        }
        SortModule = __decorate$1a([
            core.NgModule({
                imports: [common.CommonModule, BsDropdownModule.forRoot()],
                declarations: [SortComponent],
                exports: [SortComponent],
                providers: [BsDropdownConfig]
            })
        ], SortModule);
        return SortModule;
    }());

    var __decorate$1b = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata$H = (undefined && undefined.__metadata) || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    /**
     * Table base
     */
    var TableBase = /** @class */ (function () {
        /**
         * The default constructor
         */
        function TableBase() {
            /**
             * The event emitted when a row has been dragged and dropped
             */
            this.onDrop = new core.EventEmitter();
            /**
             * The Event is emitted when Page Size is changed -- requires paginationConfig
             *
             * Not applicable with ngx-datatable page event
             */
            this.onPageSizeChange = new core.EventEmitter();
            /**
             * The Event is emitted when Page Number is Changed -- requires paginationConfig
             *
             * Not applicable with ngx-datatable page event
             */
            this.onPageNumberChange = new core.EventEmitter();
            /**
             * The event emitted when an action (e.g., button, kebab, etc.) has been selected -- requires toolbarConfig
             */
            this.onActionSelect = new core.EventEmitter();
            /**
             * The event emitted when a field menu option is selected -- requires toolbarConfig
             */
            this.onFilterFieldSelect = new core.EventEmitter();
            /**
             * The event emitted when a filter has been changed -- requires toolbarConfig
             */
            this.onFilterChange = new core.EventEmitter();
            /**
             * The event emitted when a filter has been saved -- requires toolbarConfig
             */
            this.onFilterSave = new core.EventEmitter();
            /**
             * The event emitted when the user types ahead in the query input field -- requires toolbarConfig
             */
            this.onFilterTypeAhead = new core.EventEmitter();
            /**
             * The event emitted when an item selection has been changed -- requires showCheckbox
             *
             * Not applicable with ngx-datatable select event
             */
            this.onSelectionChange = new core.EventEmitter();
            /**
             * The event emitted when the sort has changed -- requires toolbarConfig
             *
             * Not applicable with ngx-datatable sort event
             */
            this.onSortChange = new core.EventEmitter();
            /**
             * The event emitted when a view has been selected -- requires toolbarConfig
             */
            this.onViewSelect = new core.EventEmitter();
        }
        // Private
        TableBase.prototype.handleAction = function ($event) {
            this.onActionSelect.emit($event);
        };
        TableBase.prototype.handleFilterChange = function ($event) {
            this.onFilterChange.emit($event);
        };
        TableBase.prototype.handleFilterFieldSelect = function ($event) {
            this.onFilterFieldSelect.emit($event);
        };
        TableBase.prototype.handleFilterTypeAhead = function ($event) {
            this.onFilterTypeAhead.emit($event);
        };
        TableBase.prototype.handleFilterSave = function ($event) {
            this.onFilterSave.emit($event);
        };
        TableBase.prototype.handlePageSize = function ($event) {
            this.onPageSizeChange.emit($event);
        };
        TableBase.prototype.handlePageNumber = function ($event) {
            this.onPageNumberChange.emit($event);
        };
        TableBase.prototype.handleSelectionChange = function ($event) {
            this.onSelectionChange.emit($event);
        };
        TableBase.prototype.handleSortChange = function ($event) {
            this.onSortChange.emit($event);
        };
        TableBase.prototype.handleViewSelect = function ($event) {
            this.onViewSelect.emit($event);
        };
        __decorate$1b([
            core.Input(),
            __metadata$H("design:type", core.TemplateRef)
        ], TableBase.prototype, "actionTemplate", void 0);
        __decorate$1b([
            core.Input(),
            __metadata$H("design:type", core.TemplateRef)
        ], TableBase.prototype, "viewTemplate", void 0);
        __decorate$1b([
            core.Output('onDrop'),
            __metadata$H("design:type", Object)
        ], TableBase.prototype, "onDrop", void 0);
        __decorate$1b([
            core.Output('onPageSizeChange'),
            __metadata$H("design:type", Object)
        ], TableBase.prototype, "onPageSizeChange", void 0);
        __decorate$1b([
            core.Output('onPageNumberChange'),
            __metadata$H("design:type", Object)
        ], TableBase.prototype, "onPageNumberChange", void 0);
        __decorate$1b([
            core.Output('onActionSelect'),
            __metadata$H("design:type", Object)
        ], TableBase.prototype, "onActionSelect", void 0);
        __decorate$1b([
            core.Output('onFilterFieldSelect'),
            __metadata$H("design:type", Object)
        ], TableBase.prototype, "onFilterFieldSelect", void 0);
        __decorate$1b([
            core.Output('onFilterChange'),
            __metadata$H("design:type", Object)
        ], TableBase.prototype, "onFilterChange", void 0);
        __decorate$1b([
            core.Output('onFilterSave'),
            __metadata$H("design:type", Object)
        ], TableBase.prototype, "onFilterSave", void 0);
        __decorate$1b([
            core.Output('onFilterTypeAhead'),
            __metadata$H("design:type", Object)
        ], TableBase.prototype, "onFilterTypeAhead", void 0);
        __decorate$1b([
            core.Output('onSelectionChange'),
            __metadata$H("design:type", Object)
        ], TableBase.prototype, "onSelectionChange", void 0);
        __decorate$1b([
            core.Output('onSortChange'),
            __metadata$H("design:type", Object)
        ], TableBase.prototype, "onSortChange", void 0);
        __decorate$1b([
            core.Output('onViewSelect'),
            __metadata$H("design:type", Object)
        ], TableBase.prototype, "onViewSelect", void 0);
        return TableBase;
    }());

    /**
     * An config containing properties for tables
     */
    var TableConfigBase = /** @class */ (function () {
        function TableConfigBase() {
        }
        return TableConfigBase;
    }());

    /**
     * An object containing properties for table events
     */
    var TableEvent = /** @class */ (function () {
        function TableEvent() {
        }
        return TableEvent;
    }());

    /**
     * An config containing properties for ngx-datatable
     *
     * For ngx-datatable options, see: https://swimlane.gitbooks.io/ngx-datatable/api/table/inputs.html
     */
    var NgxDataTableConfig = /** @class */ (function () {
        function NgxDataTableConfig() {
        }
        return NgxDataTableConfig;
    }());

    var __extends$2f = (undefined && undefined.__extends) || (function () {
        var extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * An config containing properties for table
     */
    var TableConfig = /** @class */ (function (_super) {
        __extends$2f(TableConfig, _super);
        function TableConfig() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return TableConfig;
    }(TableConfigBase));

    var __extends$2g = (undefined && undefined.__extends) || (function () {
        var extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var __decorate$1c = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata$I = (undefined && undefined.__metadata) || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    /**
     * Table component.
     *
     * In order to use drag and drop, please include the following CSS file from ng2-dragula. For example:
     * <code>import 'dragula/dist/dragula.css';</code>
     *
     * For ngx-datatable options, see: https://swimlane.gitbooks.io/ngx-datatable/
     *
     * Note: The underlying ngx-datatable uses ContentChildren to retrieve DataTableColumnDirective (ngx-datatable-column)
     * tags. As a result of wrapping ngx-datatable, these objects are no longer direct descendents and ContentChildren
     * cannot retrieve them. A fix to ContentChildren may be in the works for Angular 5 or later.
     *
     * Instead of using ngx-datatable-column, table cells may be defined using templates, provided as the
     * columns cellTemplate property. For example:
     *
     * <code>
     * this.columns = [{
     *   cellTemplate: this.nameTemplate,
     *   prop: 'name',
     *   name: 'Name'
     * }]
     * </code>
     *
     * and
     *
     * <code>
     * &lt;ng-template #nameTemplate let-row="row"&gt;
     *   &lt;span>{{row.name}}&lt;/span&gt;
     * &lt;/ng-template&gt;
     * </code>
     */
    var TableComponent = /** @class */ (function (_super) {
        __extends$2g(TableComponent, _super);
        /**
         * The default constructor
         */
        function TableComponent(dragulaService) {
            var _this = _super.call(this) || this;
            _this.dragulaService = dragulaService;
            /**
             * The ngx-datatable event emitted when a cell or row was focused via keyboard or mouse click
             */
            _this.onActivate = new core.EventEmitter();
            /**
             * The ngx-datatable event emitted when a row detail row was toggled
             *
             * Not applicable with pfng-table useExpandRows
             */
            _this.onDetailToggle = new core.EventEmitter();
            /**
             * The ngx-datatable event emitted when a row detail row was toggled
             *
             * Not applicable with pfng-table paginationConfig
             */
            _this.onPage = new core.EventEmitter();
            /**
             * The ngx-datatable event emitted when columns are re-ordered
             */
            _this.onReorder = new core.EventEmitter();
            /**
             * The ngx-datatable event emitted when a column is resized
             */
            _this.onResize = new core.EventEmitter();
            /**
             * The ngx-datatable event emitted when a cell or row was selected
             *
             * Not applicable with pfng-table showCheckbox
             */
            _this.onSelect = new core.EventEmitter();
            /**
             * The ngx-datatable event emitted when body was scrolled (e.g., when scrollbarV is true)
             */
            _this.onScroll = new core.EventEmitter();
            /**
             * The ngx-datatable event emitted when a column header is sorted
             */
            _this.onSort = new core.EventEmitter();
            /**
             * The ngx-datatable event emitted when a context menu is invoked on the table
             */
            _this.onTableContextMenu = new core.EventEmitter();
            /**
             * The event emitted when a row has been dragged
             */
            // @Output('onDrag') onDrag = new EventEmitter();
            /**
             * The event emitted when a row has been dropped
             */
            _this.onDrop = new core.EventEmitter();
            _this._allRowsSelected = false;
            _this._showTable = true;
            _this.defaultConfig = {
                dragEnabled: false,
                hideClose: false,
                showCheckbox: false,
                styleClass: 'patternfly',
                useExpandRows: false
            };
            _this.defaultDataTableConfig = {
                columnMode: 'force',
                cssClasses: {
                    sortAscending: 'datatable-icon-up',
                    sortDescending: 'datatable-icon-down',
                    pagerLeftArrow: 'datatable-icon-left',
                    pagerRightArrow: 'datatable-icon-right',
                    pagerPrevious: 'datatable-icon-prev',
                    pagerNext: 'datatable-icon-skip'
                },
                externalPaging: false,
                externalSorting: false,
                headerHeight: 50,
                messages: { emptyMessage: 'No records found' },
                offset: 0,
                reorderable: true,
                rowHeight: 'auto',
                rowIdentity: (function (x) { return x; }),
                scrollbarH: false,
                scrollbarV: false,
                sorts: [],
                sortType: 'multi'
            };
            _this.dragulaName = 'newBag';
            return _this;
        }
        // Initialization
        /**
         * Setup component configuration upon view initialization
         */
        TableComponent.prototype.ngAfterViewInit = function () {
            // Reinitialize to include selection column cell/header templates
            this.setupSelectionCols();
        };
        /**
         *  Setup component configuration upon initialization
         */
        TableComponent.prototype.ngOnInit = function () {
            this.setupConfig();
            this.setupSelectionCols(); // Initialize here for selection column width
            this.setupDataTableConfig();
        };
        /**
         *  Check if the component config has changed
         */
        TableComponent.prototype.ngDoCheck = function () {
            var _this = this;
            // Do a deep compare on config
            if (!lodash.isEqual(this.config, this.prevConfig)) {
                // Skip pagination and toolbar changes
                if (!(this.hasPaginationChanged() || this.hasToolbarChanged())) {
                    this.setupSelectionCols();
                }
                this.setupConfig();
            }
            if (!lodash.isEqual(this.dataTableConfig, this.prevDataTableConfig)) {
                this.setupDataTableConfig();
            }
            if (!lodash.isEqual(this.rows, this.prevRows)) {
                this.rowsModel = this.rows.slice();
                this.initSelectedRows();
                this.initAllRowsSelected();
                // Disable toolbar actions
                if (this.config.toolbarConfig !== undefined) {
                    this.config.toolbarConfig.disabled = !this.hasData;
                }
                // ngx-datatable recommends you force change detection -- issue #337
                if (this.prevRows === undefined || this.prevRows.length === 0) {
                    setTimeout(function () {
                        _this.setupSelectionCols();
                    }, 10);
                }
                this.prevRows = lodash.clone(this.rows); // lodash has issues deep cloning templates
            }
        };
        /**
         * Set up default config
         */
        TableComponent.prototype.setupConfig = function () {
            var _this = this;
            if (this.config !== undefined) {
                lodash.defaults(this.config, this.defaultConfig);
            }
            else {
                this.config = lodash.cloneDeep(this.defaultConfig);
            }
            // Disable toolbar actions
            if (this.config.toolbarConfig !== undefined && !this.hasData) {
                this.showTable = false;
                // Filter and sort don't fully disable without this timeout
                setTimeout(function () {
                    _this.config.toolbarConfig.disabled = !_this.hasData;
                    _this.showTable = true;
                }, 10);
            }
            this.prevConfig = lodash.cloneDeep(this.config);
        };
        /**
         * Set up default ngx-datatable config
         */
        TableComponent.prototype.setupDataTableConfig = function () {
            if (this.dataTableConfig !== undefined) {
                lodash.defaults(this.dataTableConfig, this.defaultDataTableConfig);
            }
            else {
                this.dataTableConfig = lodash.cloneDeep(this.defaultDataTableConfig);
            }
            this.prevDataTableConfig = lodash.cloneDeep(this.dataTableConfig);
        };
        /**
         * Set up selection columns
         */
        TableComponent.prototype.setupSelectionCols = function () {
            var _this = this;
            var cellClass = '';
            if (this.config.dragEnabled === true
                && (this.config.useExpandRows !== true && this.config.showCheckbox !== true)) {
                cellClass = 'pfng-table-dnd-only';
            }
            // ngx-datatable requires width property to become visible
            var width = 0;
            if (this.config.showCheckbox === true && this.config.useExpandRows === true && this.config.dragEnabled === true) {
                width = 57;
            }
            else if (this.config.showCheckbox === true && this.config.useExpandRows === true) {
                width = 52;
            }
            else if (this.config.showCheckbox === true && this.config.dragEnabled === true) {
                width = 36;
            }
            else if (this.config.useExpandRows === true && this.config.dragEnabled === true) {
                width = 32;
            }
            else if (this.config.showCheckbox === true) {
                width = 34;
            }
            else if (this.config.useExpandRows === true) {
                width = 30;
            }
            else if (this.config.dragEnabled === true) {
                width = 10;
            }
            this._cols = [];
            if (width > 0) {
                this._cols.push({
                    canAutoResize: false,
                    cellClass: 'pfng-table-select ' + cellClass,
                    cellTemplate: this.selectCellTemplate,
                    headerClass: 'pfng-table-select ' + cellClass,
                    headerTemplate: this.selectHeadTemplate,
                    resizeable: false,
                    sortable: false,
                    width: width
                });
            }
            this.columns.forEach(function (col) {
                _this._cols.push(col);
            });
        };
        Object.defineProperty(TableComponent.prototype, "allRowsSelected", {
            // Accessors
            /**
             * Returns a flag indicating whether all visible rows are selected
             *
             * @returns {boolean} True if all visible rows are selected
             */
            get: function () {
                return (this.rows !== undefined && this.rows.length > 0) ? this._allRowsSelected : false;
            },
            /**
             * Sets a flag indicating whether all visible rows are selected
             *
             * @param {boolean} selected True if all visible rows are selected
             */
            set: function (selected) {
                this._allRowsSelected = selected;
                if (this.rows !== undefined) {
                    for (var i = 0; i < this.rows.length; i++) {
                        this.rows[i].selected = (selected === true) ? true : false;
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TableComponent.prototype, "cols", {
            /**
             * Returns the columns used by the ngx-datatable component
             *
             * @returns {any[]} The ngx-datatable columns
             */
            get: function () {
                return this._cols;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TableComponent.prototype, "datatable", {
            /**
             * Returns the underlying ngx-datatable component
             *
             * @returns {DatatableComponent}
             */
            get: function () {
                return this._datatable;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TableComponent.prototype, "hasData", {
            /**
             * Get the flag indicating table has data, including filtered rows
             *
             * @returns {boolean} True is the table has data
             */
            get: function () {
                var hasRows = (this.rows !== undefined && this.rows.length > 0);
                var hasFilter = false;
                if (this.config.appliedFilters !== undefined) {
                    hasFilter = (this.config.appliedFilters.length > 0);
                }
                else if (this.config.toolbarConfig !== undefined
                    && this.config.toolbarConfig.filterConfig !== undefined
                    && this.config.toolbarConfig.filterConfig.appliedFilters !== undefined) {
                    hasFilter = (this.config.toolbarConfig.filterConfig.appliedFilters.length > 0);
                }
                return hasRows || hasFilter;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TableComponent.prototype, "selectedRows", {
            /**
             * Returns the currently selected rows
             *
             * @returns {any[]} The selected rows
             */
            get: function () {
                return (this.dataTableConfig.selected !== undefined && this.config.showCheckbox !== true)
                    ? this.dataTableConfig.selected : this._selectedRows;
            },
            /**
             * Sets the currently selected rows
             *
             * @param {any[]} selectedRows The selected rows
             */
            set: function (selectedRows) {
                if (selectedRows !== undefined) {
                    this._selectedRows = selectedRows;
                    if (this.config.toolbarConfig !== undefined && this.config.toolbarConfig.filterConfig !== undefined) {
                        this.config.toolbarConfig.filterConfig.selectedCount = this._selectedRows.length;
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TableComponent.prototype, "showTable", {
            /**
             * Returns flag indicating table is visible
             *
             * @returns {boolean} True if table is visible
             */
            get: function () {
                return this._showTable;
            },
            /**
             * Set the flag indicating table is visible
             *
             * @param {boolean} visible True if table is visible
             */
            set: function (visible) {
                this._showTable = visible;
            },
            enumerable: true,
            configurable: true
        });
        // Private
        /**
         * Helper to generate ngx-datatable activate event
         */
        TableComponent.prototype.handleActivate = function ($event) {
            this.onActivate.emit($event);
        };
        /**
         * Helper to generate ngx-datatable detailToggle event
         */
        TableComponent.prototype.handleDetailToggle = function ($event) {
            this.onDetailToggle.emit($event);
        };
        // Todo: Not implemented yet
        TableComponent.prototype.handleDragulaDrag = function ($event) {
            // this.onDrag.emit($event);
        };
        /**
         * Helper to generate dragula drop event
         *
         * @param {any[]} $event
         */
        TableComponent.prototype.handleDragulaDrop = function ($event) {
            var _this = this;
            // ngx-datatable recommends you force change detection
            this.showTable = false;
            this.rows = $event.slice();
            setTimeout(function () {
                _this.onDrop.emit($event);
                _this.rowsModel = _this.rows.slice();
                _this.showTable = true;
            }, 10);
        };
        /**
         * Helper to generate ngx-datatable page event
         */
        TableComponent.prototype.handlePage = function ($event) {
            this.onPage.emit($event);
        };
        /**
         * Helper to generate ngx-datatable reorder event
         */
        TableComponent.prototype.handleReorder = function ($event) {
            this.onReorder.emit($event);
            // Save new order for drag and drop changes
            var newCols = this.cols.slice();
            newCols.splice($event.prevValue, 1);
            newCols.splice($event.newValue, 0, $event.column);
            this._cols = newCols;
        };
        /**
         * Helper to generate ngx-datatable resize event
         */
        TableComponent.prototype.handleResize = function ($event) {
            this.onResize.emit($event);
        };
        /**
         * Helper to generate ngx-datatable scroll event
         */
        TableComponent.prototype.handleScroll = function ($event) {
            this.onScroll.emit($event);
        };
        /**
         * Helper to generate ngx-datatable select event
         */
        TableComponent.prototype.handleSelect = function ($event) {
            this.onSelect.emit($event);
        };
        /**
         * Helper to generate ngx-datatable sort event
         */
        TableComponent.prototype.handleSort = function ($event) {
            this.onSort.emit($event);
        };
        /**
         * Helper to generate ngx-datatable tableContextmenu event
         */
        TableComponent.prototype.handleTableContextMenu = function ($event) {
            this.onTableContextMenu.emit($event);
        };
        /**
         * Helper to test if pagination config has changed
         *
         * @returns {boolean} True if pagination config has changed
         */
        TableComponent.prototype.hasPaginationChanged = function () {
            var change = (this.config.paginationConfig !== undefined && this.prevConfig.paginationConfig !== undefined
                && !lodash.isEqual(this.config.paginationConfig, this.prevConfig.paginationConfig));
            return change;
        };
        /**
         * Helper to test if toolbar config has changed
         *
         * @returns {boolean} True if toolbar config has changed
         */
        TableComponent.prototype.hasToolbarChanged = function () {
            var change = (this.config.toolbarConfig !== undefined && this.prevConfig.toolbarConfig !== undefined
                && !lodash.isEqual(this.config.toolbarConfig, this.prevConfig.toolbarConfig));
            return change;
        };
        /**
         * Helper to initialize de/select all control
         */
        TableComponent.prototype.initAllRowsSelected = function () {
            this._allRowsSelected = (this.selectedRows !== undefined && this.selectedRows.length === this.rows.length);
        };
        /**
         * Helper to initialize selected rows
         */
        TableComponent.prototype.initSelectedRows = function () {
            var selected = [];
            if (this.rows !== undefined) {
                for (var i = 0; i < this.rows.length; i++) {
                    if (this.rows[i].selected) {
                        selected.push(this.rows[i]);
                    }
                }
            }
            this.selectedRows = selected;
        };
        /**
         * Helper to generate selection change event
         *
         * @param row The selected row
         */
        TableComponent.prototype.selectionChange = function (row) {
            this.initSelectedRows();
            this.initAllRowsSelected();
            this.onSelectionChange.emit({
                row: row,
                selectedRows: this.selectedRows
            });
        };
        /**
         * Helper to generate selection change event when all rows are selected
         */
        TableComponent.prototype.selectionsChange = function () {
            this.selectedRows = (this.allRowsSelected === true) ? this.rows : [];
            this.onSelectionChange.emit({
                selectedRows: this.selectedRows
            });
        };
        /**
         * Helper to expand group
         *
         * @param group The group to expand
         */
        TableComponent.prototype.toggleExpandGroup = function (group) {
            this.datatable.groupHeader.toggleExpandGroup(group);
        };
        /**
         * Helper to expand row
         *
         * @param row The row to expand
         */
        TableComponent.prototype.toggleExpandRow = function (row) {
            if (this.datatable.rowDetail !== undefined) {
                this.datatable.rowDetail.toggleExpandRow(row);
            }
        };
        __decorate$1c([
            core.Input(),
            __metadata$I("design:type", Array)
        ], TableComponent.prototype, "columns", void 0);
        __decorate$1c([
            core.Input(),
            __metadata$I("design:type", TableConfig)
        ], TableComponent.prototype, "config", void 0);
        __decorate$1c([
            core.Input(),
            __metadata$I("design:type", NgxDataTableConfig)
        ], TableComponent.prototype, "dataTableConfig", void 0);
        __decorate$1c([
            core.Input(),
            __metadata$I("design:type", core.TemplateRef)
        ], TableComponent.prototype, "expandRowTemplate", void 0);
        __decorate$1c([
            core.Input(),
            __metadata$I("design:type", core.TemplateRef)
        ], TableComponent.prototype, "groupHeaderTemplate", void 0);
        __decorate$1c([
            core.Input(),
            __metadata$I("design:type", Array)
        ], TableComponent.prototype, "rows", void 0);
        __decorate$1c([
            core.Output('onActivate'),
            __metadata$I("design:type", Object)
        ], TableComponent.prototype, "onActivate", void 0);
        __decorate$1c([
            core.Output('onDetailToggle'),
            __metadata$I("design:type", Object)
        ], TableComponent.prototype, "onDetailToggle", void 0);
        __decorate$1c([
            core.Output('onPage'),
            __metadata$I("design:type", Object)
        ], TableComponent.prototype, "onPage", void 0);
        __decorate$1c([
            core.Output('onReorder'),
            __metadata$I("design:type", Object)
        ], TableComponent.prototype, "onReorder", void 0);
        __decorate$1c([
            core.Output('onResize'),
            __metadata$I("design:type", Object)
        ], TableComponent.prototype, "onResize", void 0);
        __decorate$1c([
            core.Output('onSelect'),
            __metadata$I("design:type", Object)
        ], TableComponent.prototype, "onSelect", void 0);
        __decorate$1c([
            core.Output('onScroll'),
            __metadata$I("design:type", Object)
        ], TableComponent.prototype, "onScroll", void 0);
        __decorate$1c([
            core.Output('onSort'),
            __metadata$I("design:type", Object)
        ], TableComponent.prototype, "onSort", void 0);
        __decorate$1c([
            core.Output('onTableContextMenu'),
            __metadata$I("design:type", Object)
        ], TableComponent.prototype, "onTableContextMenu", void 0);
        __decorate$1c([
            core.Output('onDrop'),
            __metadata$I("design:type", Object)
        ], TableComponent.prototype, "onDrop", void 0);
        __decorate$1c([
            core.ViewChild('datatable'),
            __metadata$I("design:type", ngxDatatable.DatatableComponent)
        ], TableComponent.prototype, "_datatable", void 0);
        __decorate$1c([
            core.ViewChild('selectCellTemplate'),
            __metadata$I("design:type", core.TemplateRef)
        ], TableComponent.prototype, "selectCellTemplate", void 0);
        __decorate$1c([
            core.ViewChild('selectHeadTemplate'),
            __metadata$I("design:type", core.TemplateRef)
        ], TableComponent.prototype, "selectHeadTemplate", void 0);
        TableComponent = __decorate$1c([
            core.Component({
                encapsulation: core.ViewEncapsulation.None,
                selector: 'pfng-table',
                template: "<div class=\"pfng-table\"><pfng-toolbar [config]=\"config.toolbarConfig\" [actionTemplate]=\"actionTemplate\" (onActionSelect)=\"handleAction($event)\" (onFilterChange)=\"handleFilterChange($event)\" (onFilterFieldSelect)=\"handleFilterFieldSelect($event)\" (onFilterTypeAhead)=\"handleFilterTypeAhead($event)\" (onSortChange)=\"handleSortChange($event)\" (onViewSelect)=\"handleViewSelect($event)\" *ngIf=\"config.toolbarConfig !== undefined\"></pfng-toolbar><div *ngIf=\"hasData\"><ngx-datatable #datatable [columns]=\"cols\" [columnMode]=\"dataTableConfig.columnMode\" [count]=\"dataTableConfig.count\" [cssClasses]=\"dataTableConfig.cssClasses\" [displayCheck]=\"dataTableConfig.displayCheck\" [dragulaClassSelector]=\"'pfng-table-dnd-header'\" [dragulaModel]=\"rowsModel\" [dragulaName]=\"dragulaName\" [externalPaging]=\"dataTableConfig.externalPaging\" [externalSorting]=\"dataTableConfig.externalSorting\" [footerHeight]=\"dataTableConfig.footerHeight\" [groupExpansionDefault]=\"dataTableConfig.groupExpansionDefault\" [groupRowsBy]=\"dataTableConfig.groupRowsBy\" [headerHeight]=\"dataTableConfig.headerHeight\" [messages]=\"dataTableConfig.messages\" [ngClass]=\"config.styleClass\" [limit]=\"dataTableConfig.limit\" [loadingIndicator]=\"dataTableConfig.loadingIndicator\" [offset]=\"dataTableConfig.offset\" [reorderable]=\"dataTableConfig.reorderable\" [rowClass]=\"dataTableConfig.rowClass\" [rowHeight]=\"dataTableConfig.rowHeight\" [rowIdentity]=\"dataTableConfig.rowIdentity\" [rows]=\"rows\" [scrollbarH]=\"dataTableConfig.scrollbarH\" [scrollbarV]=\"dataTableConfig.scrollbarV\" [selectAllRowsOnPage]=\"dataTableConfig.selectAllRowsOnPage\" [selectCheck]=\"dataTableConfig.selectCheck\" [selected]=\"selectedRows\" [selectionType]=\"dataTableConfig.selectionType\" [sorts]=\"dataTableConfig.sorts\" [sortType]=\"dataTableConfig.sortType\" [trackByProp]=\"dataTableConfig.trackByProp\" [virtualization]=\"dataTableConfig.virtualization\" (activate)=\"handleActivate($event)\" (detailToggle)=\"handleDetailToggle($event)\" (dragulaDrop)=\"handleDragulaDrop($event)\" (dragulaDrag)=\"handleDragulaDrag($event)\" (page)=\"handlePage($event)\" (reorder)=\"handleReorder($event)\" (resize)=\"handleResize($event)\" (scroll)=\"handleScroll($event)\" (select)=\"handleSelect($event)\" (sort)=\"handleSort($event)\" (tableContextmenu)=\"handleOnTableContextMenu($event)\" *ngIf=\"showTable\"><ng-template #selectHeadTemplate><span class=\"margin-left-5\" *ngIf=\"config.dragEnabled === true\"></span> <span class=\"margin-left-16\" *ngIf=\"config.useExpandRows === true\"><span class=\"pfng-list-expand-placeholder\"></span> </span><input type=\"checkbox\" value=\"allRowsSelected\" title=\"{{(allRowsSelected) ? 'Deselect' : 'Select'}} All Rows\" [disabled]=\"rows === undefined || rows.length === 0\" [(ngModel)]=\"allRowsSelected\" (ngModelChange)=\"selectionsChange()\" *ngIf=\"config.showCheckbox === true\"></ng-template><ng-template #selectCellTemplate let-row=\"row\" let-expanded=\"expanded\"><span class=\"pfng-table-dnd-container\" *ngIf=\"config.dragEnabled === true\"><span class=\"pfng-table-dnd-header\"></span> </span><span [ngClass]=\"{'margin-left-5': config.dragEnabled === true}\" *ngIf=\"config.useExpandRows === true\"><span class=\"pfng-list-expand-placeholder\" *ngIf=\"row.hideExpandToggle === true\"></span> <span class=\"fa\" [ngClass]=\"{'fa-angle-down': expanded, 'fa-angle-right margin-right-4': !expanded}\" (click)=\"toggleExpandRow(row)\" *ngIf=\"row.hideExpandToggle !== true\"></span> </span><span [ngClass]=\"{'margin-left-5': config.dragEnabled === true || config.useExpandRows === true}\" *ngIf=\"config.showCheckbox === true\"><input type=\"checkbox\" value=\"row.selected\" title=\"{{(row.selected) ? 'Deselect' : 'Select'}} Row\" [(ngModel)]=\"row.selected\" (ngModelChange)=\"selectionChange(row)\"></span></ng-template><ngx-datatable-group-header [rowHeight]=\"dataTableConfig.rowHeight\" *ngIf=\"groupHeaderTemplate !== undefined\"><ng-template let-group=\"group\" let-expanded=\"expanded\" ngx-datatable-group-header-template><span class=\"margin-5\"><span class=\"fa\" [ngClass]=\"{'fa-angle-down': expanded, 'fa-angle-right margin-right-4': !expanded}\" (click)=\"toggleExpandGroup(group)\"></span></span><ng-template [ngTemplateOutlet]=\"groupHeaderTemplate\" [ngTemplateOutletContext]=\"{ group: group, expanded: expanded }\"></ng-template></ng-template></ngx-datatable-group-header><ngx-datatable-row-detail [rowHeight]=\"auto\" *ngIf=\"expandRowTemplate !== undefined\"><ng-template let-row=\"row\" let-expanded=\"expanded\" ngx-datatable-row-detail-template><div class=\"pfng-table-expand-container\" tabindex=\"0\"><div class=\"pfng-table-expand-content\" style=\"flex-grow: 1\"><div class=\"close\" *ngIf=\"config.hideClose !== true\"><span class=\"pficon pficon-close\" (click)=\"toggleExpandRow(row)\"></span></div><ng-template [ngTemplateOutlet]=\"expandRowTemplate\" [ngTemplateOutletContext]=\"{ row: row, expanded: expanded }\"></ng-template></div></div></ng-template></ngx-datatable-row-detail></ngx-datatable><pfng-pagination [config]=\"config.paginationConfig\" (onPageNumberChange)=\"handlePageNumber($event)\" (onPageSizeChange)=\"handlePageSize($event)\" *ngIf=\"config.paginationConfig !== undefined\"></pfng-pagination></div><pfng-empty-state [config]=\"config.emptyStateConfig\" (onActionSelect)=\"handleAction($event)\" *ngIf=\"!hasData\"></pfng-empty-state></div>"
            }),
            __metadata$I("design:paramtypes", [ng2Dragula.DragulaService])
        ], TableComponent);
        return TableComponent;
    }(TableBase));

    var __decorate$1d = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata$J = (undefined && undefined.__metadata) || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    /**
     * Drag and drop directive used with the underlying ngx-datatable component.
     *
     * Note: When drag and drop is avaiable upstream, this functionlity will likely be removed
     *
     * See: https://github.com/swimlane/ngx-datatable/issues/411
     */
    var NgxDataTableDndDirective = /** @class */ (function () {
        function NgxDataTableDndDirective(el, dragulaService) {
            this.dragulaClassSelector = 'null';
            this.dragulaDrop = new core.EventEmitter();
            this.dragulaDrag = new core.EventEmitter();
            this.subscriptionDrag = null;
            this.subscriptionDrop = null;
            this.el = el;
            this.dragulaService = dragulaService;
        }
        NgxDataTableDndDirective.prototype.ngOnInit = function () {
        };
        NgxDataTableDndDirective.prototype.ngAfterViewInit = function () {
            if (this.el) {
                var container = this.el;
                // Check for the row's parent node: datatable-scroller
                // This is what you want to bind Dragula to, in order to drag sort
                if (container.nativeElement.querySelector('datatable-scroller')) {
                    var rowParent = container.nativeElement.querySelector('datatable-scroller');
                    // Check if this Dragula already exists
                    if (!this.dragulaService.find(this.dragulaName)) {
                        // Must assign the new rowParent as the container you want to pass to Dragula
                        this.container = rowParent;
                        this.initializeDragula();
                    }
                }
            }
        };
        NgxDataTableDndDirective.prototype.ngOnChanges = function (changes) {
            // Must update model on any changes
            // Otherwise it will fall out of sync with the 'dragulaModel'
            if (changes && changes.dragulaModel) {
                if (this.drake) {
                    if (this.drake.models) {
                        var modelIndex = this.drake.models.indexOf(changes.dragulaModel.previousValue);
                        this.drake.models.splice(modelIndex, 1, changes.dragulaModel.currentValue);
                    }
                    else {
                        this.drake.models = [changes.dragulaModel.currentValue];
                    }
                }
            }
        };
        NgxDataTableDndDirective.prototype.ngOnDestroy = function () {
            // Clear this Dragula always
            // comment out if you want to keep it
            if (this.dragulaService.find(this.dragulaName)) {
                this.dragulaService.destroy(this.dragulaName);
            }
            // Clear DRAG and DROP subscription to prevent duplicates
            if (this.subscriptionDrag) {
                this.subscriptionDrag.unsubscribe();
                this.subscriptionDrag = null;
            }
            if (this.subscriptionDrop) {
                this.subscriptionDrop.unsubscribe();
                this.subscriptionDrop = null;
            }
        };
        NgxDataTableDndDirective.prototype.initializeDragula = function () {
            var _this = this;
            // console.log('initialized');
            // Create new Dragula container
            var bag = this.dragulaService.find(this.dragulaName);
            if (bag) {
                this.drake = bag.drake;
                this.checkModel();
                this.drake.containers.push(this.container);
            }
            else {
                // Check if dragulaClassSelector was specified
                // *true:
                //    - the dragulaClassSelector string will be used to match the class of the element clicked
                //    - the element with the matching class name will be used to drag the row
                // *false:
                //    - no class selector will be used
                //    - the whole row will default back to being draggable
                if (this.dragulaClassSelector !== 'null') {
                    var classSelector_1 = this.dragulaClassSelector;
                    var options = {
                        moves: function (el, container, handle) {
                            return handle.className === classSelector_1;
                        }
                    };
                    this.drake = ng2Dragula.dragula([this.container], options);
                }
                else {
                    this.drake = ng2Dragula.dragula([this.container]);
                }
                this.checkModel();
                this.dragulaService.add(this.dragulaName, this.drake);
            }
            // Set DRAG and DROP subscriptions and callbacks
            this.subscriptionDrag = this.dragulaService.drag.subscribe(function (value) {
                _this.drag(value.slice(1));
            });
            this.subscriptionDrop = this.dragulaService.drop.subscribe(function (value) {
                var bagName = value[0], el = value[1], target = value[2], source = value[3];
                _this.onDropModel(value.slice(1));
            });
        };
        NgxDataTableDndDirective.prototype.checkModel = function () {
            if (this.dragulaModel) {
                if (this.drake.models) {
                    this.drake.models.push(this.dragulaModel);
                }
                else {
                    this.drake.models = [this.dragulaModel];
                }
            }
        };
        NgxDataTableDndDirective.prototype.drag = function (args) {
            var e = args[0], el = args[1];
            // Todo: not implemented
        };
        NgxDataTableDndDirective.prototype.onDropModel = function (args) {
            var el = args[0], target = args[1], source = args[2];
            // Added emitter on any DROP action
            // console.log('EMITTER', args);
            this.dragulaDrop.emit(this.dragulaModel);
        };
        __decorate$1d([
            core.Input(),
            __metadata$J("design:type", String)
        ], NgxDataTableDndDirective.prototype, "dragulaName", void 0);
        __decorate$1d([
            core.Input(),
            __metadata$J("design:type", Object)
        ], NgxDataTableDndDirective.prototype, "dragulaModel", void 0);
        __decorate$1d([
            core.Input(),
            __metadata$J("design:type", String)
        ], NgxDataTableDndDirective.prototype, "dragulaClassSelector", void 0);
        __decorate$1d([
            core.Output(),
            __metadata$J("design:type", core.EventEmitter)
        ], NgxDataTableDndDirective.prototype, "dragulaDrop", void 0);
        __decorate$1d([
            core.Output(),
            __metadata$J("design:type", core.EventEmitter)
        ], NgxDataTableDndDirective.prototype, "dragulaDrag", void 0);
        NgxDataTableDndDirective = __decorate$1d([
            core.Directive({
                selector: 'ngx-datatable[dragulaName]'
            }),
            __metadata$J("design:paramtypes", [core.ElementRef, ng2Dragula.DragulaService])
        ], NgxDataTableDndDirective);
        return NgxDataTableDndDirective;
    }());

    /**
     * A config containing properties for toolbar
     */
    var ToolbarConfig = /** @class */ (function () {
        function ToolbarConfig() {
        }
        return ToolbarConfig;
    }());

    var __decorate$1e = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata$K = (undefined && undefined.__metadata) || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    /**
     * Toolbar component
     */
    var ToolbarComponent = /** @class */ (function () {
        /**
         * The default constructor
         */
        function ToolbarComponent() {
            /**
             * The event emitted when an action (e.g., button, kebab, etc.) has been selected
             */
            this.onActionSelect = new core.EventEmitter();
            /**
             * The event emitted when a field menu option is selected
             */
            this.onFilterFieldSelect = new core.EventEmitter();
            /**
             * The event emitted when a filter has been changed
             */
            this.onFilterChange = new core.EventEmitter();
            /**
             * The event emitted when a filter has been saved
             */
            this.onFilterSave = new core.EventEmitter();
            /**
             * The event emitted when the user types ahead in the query input field
             */
            this.onFilterTypeAhead = new core.EventEmitter();
            /**
             * The event emitted when the sort has changed
             */
            this.onSortChange = new core.EventEmitter();
            /**
             * The event emitted when a view has been selected
             */
            this.onViewSelect = new core.EventEmitter();
            this.defaultConfig = {
                disabled: false
            };
        }
        // Initialization
        /**
         * Setup component configuration upon initialization
         */
        ToolbarComponent.prototype.ngOnInit = function () {
            this.setupConfig();
        };
        /**
         * Check if the component config has changed
         */
        ToolbarComponent.prototype.ngDoCheck = function () {
            // Do a deep compare on config
            if (!lodash.isEqual(this.config, this.prevConfig)) {
                this.setupConfig();
            }
        };
        /**
         * Set up default config
         */
        ToolbarComponent.prototype.setupConfig = function () {
            if (this.config !== undefined) {
                lodash.defaults(this.config, this.defaultConfig);
            }
            else {
                this.config = lodash.cloneDeep(this.defaultConfig);
            }
            if (this.config && this.config.filterConfig) {
                this.config.filterConfig.disabled = this.config.disabled;
                if (this.config.filterConfig.appliedFilters === undefined) {
                    this.config.filterConfig.appliedFilters = [];
                }
            }
            if (this.config && this.config.sortConfig) {
                this.config.sortConfig.disabled = this.config.disabled;
                if (this.config.sortConfig.fields === undefined) {
                    this.config.sortConfig.fields = [];
                }
            }
            if (this.config.sortConfig !== undefined && this.config.sortConfig.visible === undefined) {
                this.config.sortConfig.visible = true;
            }
            if (this.config && this.config.views === undefined) {
                this.config.views = [];
            }
            if (this.config && this.config.view === undefined) {
                this.config.view = this.config.views[0];
            }
            this.prevConfig = lodash.cloneDeep(this.config);
        };
        // Actions
        /**
         * Handle clear filter event
         *
         * @param $event An array of current Filter objects
         */
        ToolbarComponent.prototype.clearFilter = function ($event) {
            this.config.filterConfig.appliedFilters = $event;
            this.onFilterChange.emit({
                appliedFilters: $event
            });
        };
        /**
         * Reset current field and value
         */
        ToolbarComponent.prototype.resetFilterField = function () {
            if (this.filterFields !== undefined) {
                this.filterFields.reset();
            }
        };
        // Private
        ToolbarComponent.prototype.filterAdded = function ($event) {
            var newFilter = {
                field: $event.field,
                query: $event.query,
                value: $event.value
            };
            if (!this.filterExists(newFilter)) {
                if (newFilter.field.type === 'select') {
                    this.enforceSingleSelect(newFilter);
                }
                this.config.filterConfig.appliedFilters.push(newFilter);
                $event.appliedFilters = this.config.filterConfig.appliedFilters;
                this.onFilterChange.emit($event);
            }
        };
        ToolbarComponent.prototype.filterExists = function (filter$$1) {
            var foundFilter = lodash.find(this.config.filterConfig.appliedFilters, {
                field: filter$$1.field,
                query: filter$$1.query,
                value: filter$$1.value
            });
            return foundFilter !== undefined;
        };
        ToolbarComponent.prototype.handleAction = function (action) {
            if (action && action.disabled !== true) {
                this.onActionSelect.emit(action);
            }
        };
        ToolbarComponent.prototype.handleFilterFieldSelect = function ($event) {
            this.onFilterFieldSelect.emit($event);
        };
        ToolbarComponent.prototype.handleFilterSave = function ($event) {
            this.onFilterSave.emit($event);
        };
        ToolbarComponent.prototype.handleFilterTypeAhead = function ($event) {
            this.onFilterTypeAhead.emit($event);
        };
        ToolbarComponent.prototype.sortChange = function ($event) {
            this.onSortChange.emit($event);
        };
        ToolbarComponent.prototype.isViewSelected = function (currentView) {
            return this.config.view && this.config.view.id === currentView.id;
        };
        ToolbarComponent.prototype.viewSelected = function (currentView) {
            this.config.view = currentView;
            if (!currentView.disabled) {
                this.onViewSelect.emit(currentView);
            }
        };
        // Utils
        ToolbarComponent.prototype.enforceSingleSelect = function (filter$$1) {
            lodash.remove(this.config.filterConfig.appliedFilters, { title: filter$$1.field.title });
        };
        __decorate$1e([
            core.Input(),
            __metadata$K("design:type", ToolbarConfig)
        ], ToolbarComponent.prototype, "config", void 0);
        __decorate$1e([
            core.Input(),
            __metadata$K("design:type", core.TemplateRef)
        ], ToolbarComponent.prototype, "actionTemplate", void 0);
        __decorate$1e([
            core.Input(),
            __metadata$K("design:type", core.TemplateRef)
        ], ToolbarComponent.prototype, "viewTemplate", void 0);
        __decorate$1e([
            core.Output('onActionSelect'),
            __metadata$K("design:type", Object)
        ], ToolbarComponent.prototype, "onActionSelect", void 0);
        __decorate$1e([
            core.Output('onFilterFieldSelect'),
            __metadata$K("design:type", Object)
        ], ToolbarComponent.prototype, "onFilterFieldSelect", void 0);
        __decorate$1e([
            core.Output('onFilterChange'),
            __metadata$K("design:type", Object)
        ], ToolbarComponent.prototype, "onFilterChange", void 0);
        __decorate$1e([
            core.Output('onFilterSave'),
            __metadata$K("design:type", Object)
        ], ToolbarComponent.prototype, "onFilterSave", void 0);
        __decorate$1e([
            core.Output('onFilterTypeAhead'),
            __metadata$K("design:type", Object)
        ], ToolbarComponent.prototype, "onFilterTypeAhead", void 0);
        __decorate$1e([
            core.Output('onSortChange'),
            __metadata$K("design:type", Object)
        ], ToolbarComponent.prototype, "onSortChange", void 0);
        __decorate$1e([
            core.Output('onViewSelect'),
            __metadata$K("design:type", Object)
        ], ToolbarComponent.prototype, "onViewSelect", void 0);
        __decorate$1e([
            core.ViewChild('filterFields'),
            __metadata$K("design:type", FilterFieldsComponent)
        ], ToolbarComponent.prototype, "filterFields", void 0);
        ToolbarComponent = __decorate$1e([
            core.Component({
                encapsulation: core.ViewEncapsulation.None,
                selector: 'pfng-toolbar',
                template: "<div class=\"row toolbar-pf\"><div class=\"col-sm-12\"><form class=\"toolbar-pf-actions\" [ngClass]=\"{'no-filter-results': config.filterConfig?.resultsCount === 0 && config.filterConfig?.appliedFilters?.length !== 0}\" (submit)=\"$event.preventDefault()\"><div class=\"form-group toolbar-apf-filter\"><pfng-filter-fields [config]=\"config.filterConfig\" #filterFields (onAdd)=\"filterAdded($event)\" (onFieldSelect)=\"handleFilterFieldSelect($event)\" (onSave)=\"handleFilterSave($event)\" (onTypeAhead)=\"handleFilterTypeAhead($event)\" *ngIf=\"config.filterConfig?.fields\"></pfng-filter-fields></div><div class=\"form-group\" *ngIf=\"config.sortConfig?.fields && config.sortConfig?.visible !== false\"><pfng-sort [config]=\"config.sortConfig\" (onChange)=\"sortChange($event)\"></pfng-sort></div><div class=\"form-group toolbar-actions\" *ngIf=\"config.actionConfig !== undefined || actionTemplate !== undefined\"><pfng-action [config]=\"config.actionConfig\" [template]=\"actionTemplate\" (onActionSelect)=\"handleAction($event)\"></pfng-action></div><div class=\"toolbar-pf-action-right\"><div class=\"form-group toolbar-pf-view-selector\" *ngIf=\"viewTemplate !== undefined || (config.views)\"><ng-template [ngTemplateOutlet]=\"viewTemplate\" [ngTemplateOutletContext]=\"{}\"></ng-template><span *ngIf=\"config.views\"><button *ngFor=\"let view of config.views\" class=\"btn btn-link\" [ngClass]=\"{'active': isViewSelected(view), 'disabled': view.disabled === true}\" title=\"{{view.tooltip}}\" (click)=\"viewSelected(view)\"><i class=\"{{view.iconStyleClass}}\"></i></button></span></div></div></form><pfng-filter-results [config]=\"config.filterConfig\" (onClear)=\"clearFilter($event)\"></pfng-filter-results></div></div>"
            }),
            __metadata$K("design:paramtypes", [])
        ], ToolbarComponent);
        return ToolbarComponent;
    }());

    var __decorate$1f = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    /**
     * A module containing objects associated with the toolbar component
     */
    var ToolbarModule = /** @class */ (function () {
        function ToolbarModule() {
        }
        ToolbarModule = __decorate$1f([
            core.NgModule({
                imports: [
                    ActionModule,
                    BsDropdownModule.forRoot(),
                    common.CommonModule,
                    FilterModule,
                    SortModule
                ],
                declarations: [ToolbarComponent],
                exports: [ToolbarComponent],
                providers: [BsDropdownConfig]
            })
        ], ToolbarModule);
        return ToolbarModule;
    }());

    var __decorate$1g = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    /**
     * A module containing objects associated with table components
     */
    var TableModule = /** @class */ (function () {
        function TableModule() {
        }
        TableModule = __decorate$1g([
            core.NgModule({
                imports: [
                    common.CommonModule,
                    ng2Dragula.DragulaModule,
                    EmptyStateModule,
                    forms.FormsModule,
                    PaginationModule,
                    ngxDatatable.NgxDatatableModule,
                    ToolbarModule
                ],
                declarations: [NgxDataTableDndDirective, TableComponent],
                exports: [TableComponent],
                providers: [ng2Dragula.DragulaService]
            })
        ], TableModule);
        return TableModule;
    }());

    /**
     * An view containing common properties
     */
    var ToolbarView = /** @class */ (function () {
        function ToolbarView() {
        }
        return ToolbarView;
    }());

    /**
     * A base class with common functionality for wizard and wizard-step
     */
    var WizardBase = /** @class */ (function () {
        /**
         * The default constructor
         */
        function WizardBase() {
            this._steps = [];
        }
        Object.defineProperty(WizardBase.prototype, "selectedStep", {
            // Accessors
            /**
             * Returns the selected wizard step or substep
             *
             * @returns {WizardStep} The wizard step or substep
             */
            get: function () {
                return this._selectedStep;
            },
            /**
             * Set the selected wizard step or substep for this component
             *
             * @param {WizardStep} step The wizard step or substep
             */
            set: function (step) {
                this._selectedStep = step;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WizardBase.prototype, "selectedStepIndex", {
            /**
             * Returns the selected wizard step or substep number
             *
             * @returns {number} The step index
             */
            get: function () {
                // Retrieve selected step number
                return this.stepIndex(this.selectedStep) + 1;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WizardBase.prototype, "steps", {
            /**
             * Returns the wizard steps or substeps for this component
             *
             * @returns {WizardStep[]} The wizard steps or substeps
             */
            get: function () {
                return this._steps;
            },
            /**
             * Set the wizard steps or substeps for this component
             *
             * @param {WizardStep[]} steps The wizard steps or substeps
             */
            set: function (steps) {
                this._steps = steps;
            },
            enumerable: true,
            configurable: true
        });
        // Methods
        /**
         * Add a wizard step or substep to this component
         *
         * @param {WizardStep} step The wizard step or substep to add
         */
        WizardBase.prototype.addStep = function (step) {
            // Insert the step into step array
            var insertBefore = lodash.find(this.steps, function (nextStep) {
                return nextStep.config.priority > step.config.priority;
            });
            if (insertBefore) {
                this.steps.splice(this.steps.indexOf(insertBefore), 0, step);
            }
            else {
                this.steps.push(step);
            }
        };
        /**
         * Returns only enabled wizard steps
         *
         * @returns {WizardStep[]} The wizard stepd or substepd
         */
        WizardBase.prototype.getEnabledSteps = function () {
            return this.steps.filter(function (step) {
                return (step.config.disabled !== true);
            });
        };
        /**
         * Returns the step index for the given wizard step or substep
         *
         * @param {WizardStep} step The wizard step or substep
         * @returns {number} The step number
         */
        WizardBase.prototype.getStepIndex = function (step) {
            return this.stepIndex(step) + 1;
        };
        /**
         * Returns the wizard step or substep for the given title
         *
         * @param {string} title The title to find
         * @returns {WizardStep} The wizard step or substep
         */
        WizardBase.prototype.stepByTitle = function (title) {
            var foundStep;
            this.getEnabledSteps().forEach(function (step) {
                if (step.config.title === title) {
                    foundStep = step;
                }
            });
            return foundStep;
        };
        /**
         * Returns the index for the given wizard step or substep
         *
         * @param {WizardStep} step The wizard step or substep
         * @returns {number} The wizard step or substep index
         */
        WizardBase.prototype.stepIndex = function (step) {
            var idx = 0;
            var res = -1;
            this.getEnabledSteps().forEach(function (currStep) {
                if (currStep === step) {
                    res = idx;
                }
                idx++;
            });
            return res;
        };
        /**
         * Unselect all wizard steps and substeps
         */
        WizardBase.prototype.unselectAll = function () {
            // Traverse steps array and set each "selected" property to false
            this.getEnabledSteps().forEach(function (step) {
                step.selected = false;
            });
            // Set selectedStep variable to null
            this.selectedStep = null;
        };
        return WizardBase;
    }());

    /**
     * A config containing properties for wizard
     */
    var WizardConfig = /** @class */ (function () {
        function WizardConfig() {
        }
        return WizardConfig;
    }());

    var __extends$2h = (undefined && undefined.__extends) || (function () {
        var extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var __decorate$1h = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata$L = (undefined && undefined.__metadata) || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    /**
     * Wizard component
     */
    var WizardComponent = /** @class */ (function (_super) {
        __extends$2h(WizardComponent, _super);
        /**
         * The default constructor
         */
        function WizardComponent() {
            var _this = _super.call(this) || this;
            /**
             * The event emitted when the cancel button has been selected
             */
            _this.onCancel = new core.EventEmitter();
            /**
             * The event emitted when all wizard steps and substeps have finished
             */
            _this.onFinish = new core.EventEmitter();
            /**
             * The event emitted when the next button has been selected
             */
            _this.onNext = new core.EventEmitter();
            /**
             * The event emitted when the back button has been selected
             */
            _this.onPrevious = new core.EventEmitter();
            /**
             * The event emitted when a step has changed
             */
            _this.onStepChange = new core.EventEmitter();
            _this.defaultConfig = {
                cancelTitle: 'Cancel',
                done: false,
                contentHeight: '300px',
                embedInPage: false,
                hideIndicators: false,
                hideSidebar: false,
                hideHeader: false,
                hidePreviousButton: false,
                nextTitle: 'Next >',
                previousTitle: '< Back',
                ready: true
            };
            _this.init = true;
            _this._firstStep = false;
            return _this;
        }
        // Initialization
        /**
         * Setup component configuration upon initialization
         */
        WizardComponent.prototype.ngOnInit = function () {
            var _this = this;
            this.setupConfig();
            if (this.init && this.config.ready) {
                setTimeout(function () {
                    _this.initFirstStep();
                }, 10);
            }
        };
        /**
         * Check if the component config has changed
         */
        WizardComponent.prototype.ngDoCheck = function () {
            // Do a deep compare on config
            if (!lodash.isEqual(this.config, this.prevConfig)) {
                this.setupConfig();
            }
        };
        /**
         * Set up default config
         */
        WizardComponent.prototype.setupConfig = function () {
            if (this.config !== undefined) {
                lodash.defaults(this.config, this.defaultConfig);
            }
            else {
                this.config = lodash.cloneDeep(this.defaultConfig);
            }
            // If a step class is given use it for all steps
            if (this.config.stepStyleClass !== undefined) {
                // If a sidebarStyleClass is given, us it for sidebar panel, if not, apply the stepsClass to the sidebar panel
                if (this.config.sidebarStyleClass === undefined) {
                    this.config.sidebarStyleClass = this.config.stepStyleClass;
                }
            }
            else {
                this.contentStyle = {
                    'height': this.config.contentHeight,
                    'max-height': this.config.contentHeight,
                    'overflow-y': 'auto'
                };
            }
            // Ready state changed
            if (this.prevConfig !== undefined && !lodash.isEqual(this.config.ready, this.prevConfig.ready)) {
                this.initFirstStep();
            }
            this.prevConfig = lodash.cloneDeep(this.config);
        };
        Object.defineProperty(WizardComponent.prototype, "firstStep", {
            // Accessors
            /**
             * Indicates that the selected step is also the first wizard step or substep
             *
             * @returns {boolean} True if the selected step is the first wizard step or substep
             */
            get: function () {
                return this._firstStep;
            },
            /**
             * Set a flag indicating that the selected step is also the first wizard step or substep
             *
             * @param {boolean} firstStep True if the selected step is the first wizard step or substep
             */
            set: function (firstStep) {
                this._firstStep = firstStep;
            },
            enumerable: true,
            configurable: true
        });
        // Methods
        /**
         * Add a wizard step or substep to this component
         *
         * @param {WizardStep} step The wizard step or substep
         */
        WizardComponent.prototype.addStep = function (step) {
            _super.prototype.addStep.call(this, step);
            var enabledSteps = this.getEnabledSteps();
            if (this.config.ready && (enabledSteps.length > 0) && (step === enabledSteps[0])) {
                this.goTo(enabledSteps[0], true, false);
            }
        };
        /**
         * Returns only wizard steps with review templates
         *
         * @returns {WizardStep[]} The wizard stepd or substepd
         */
        WizardComponent.prototype.getReviewSteps = function () {
            var reviewSteps = this.getEnabledSteps().filter(function (step) {
                return (step.reviewTemplate !== undefined || step.getReviewSteps().length > 0);
            });
            return reviewSteps;
        };
        /**
         * Navigate to the next wizard step or substep
         */
        WizardComponent.prototype.goToNextStep = function () {
            this.next(false);
        };
        /**
         * Navigate to the previous wizard step or substep
         */
        WizardComponent.prototype.goToPreviousStep = function () {
            this.previous(false);
        };
        /**
         * Navigate to the given wizard step index
         *
         * @param {number} stepIndex The step number to navigate to
         * @param {boolean} resetStepNav True if the first substep (if exists) should be selected
         */
        WizardComponent.prototype.goToStep = function (stepIndex, resetStepNav) {
            var enabledSteps = this.getEnabledSteps();
            if (stepIndex < enabledSteps.length) {
                this.goTo(enabledSteps[stepIndex], resetStepNav, false);
            }
        };
        /**
         * Called when the next button has been selected.
         *
         * @param {boolean} emitEvent True to emit the onNext event
         */
        WizardComponent.prototype.next = function (emitEvent) {
            var enabledSteps = this.getEnabledSteps();
            // Save the step you were on when next() was invoked
            var index = this.stepIndex(this.selectedStep);
            var wizEvent = {
                index: index,
                step: this.selectedStep
            };
            if (this.selectedStep.hasSubsteps) {
                // Handle navigation in substep
                if (this.selectedStep.next(emitEvent)) {
                    return;
                }
            }
            else {
                if (emitEvent !== false) {
                    this.onNext.emit(wizEvent);
                }
            }
            // Set completed property, which may be used to add/remove a style class from progress bar
            this.selectedStep.config.completed = true;
            // Ensure this is not the last step
            if (index === enabledSteps.length - 1) {
                this.finish();
            }
            else {
                this.goTo(enabledSteps[index + 1], true, false);
            }
        };
        /**
         * Called when the previous button has been selected.
         *
         * @param {boolean} emitEvent True to emit the onNext event
         */
        WizardComponent.prototype.previous = function (emitEvent) {
            var index = this.stepIndex(this.selectedStep);
            var wizEvent = {
                index: index,
                step: this.selectedStep
            };
            if (this.selectedStep.hasSubsteps) {
                // Handle navigation in substep
                if (this.selectedStep.previous(emitEvent)) {
                    return;
                }
            }
            else {
                if (emitEvent !== false) {
                    this.onPrevious.emit(wizEvent);
                }
            }
            // Ensure this is not the first step
            if (index === 0) {
                throw new Error("Can't go back. Already at first step");
            }
            else {
                this.goTo(this.getEnabledSteps()[index - 1], false, true);
            }
        };
        /**
         * Emits an event when the wizard step or substep has changed
         *
         * @param {WizardStep} step The wizard step or substep
         * @param {number} index The order of the wizard step of substep within its parent
         */
        WizardComponent.prototype.stepChanged = function (step, index) {
            this.onStepChange.emit({
                index: index,
                step: step
            });
        };
        /**
         * Set a flag indicating that the selected step is also the first wizard step or substep
         *
         * @param {number} stepIndex The step index
         */
        WizardComponent.prototype.updateStepIndex = function (stepIndex) {
            this.firstStep = this.stepIndex(this.selectedStep) === 0 && stepIndex === 0;
        };
        // Private
        // Indicates that the user can click on numeric step indicators to navigate directly to a step
        WizardComponent.prototype.allowStepIndicatorClick = function (step) {
            if (step === undefined || this.selectedStep === undefined) {
                return false;
            }
            return !this.config.done
                && step.config.allowClickNav
                && this.selectedStep.config.allowNavAway
                && (this.selectedStep.config.nextEnabled || (step.config.priority < this.selectedStep.config.priority))
                && (this.selectedStep.config.previousEnabled || (step.config.priority > this.selectedStep.config.priority));
        };
        // Emits an event inidcating that the cancel button has been selected
        WizardComponent.prototype.cancel = function () {
            this.onCancel.emit({
                index: this.stepIndex(this.selectedStep),
                step: this.selectedStep
            });
            this.reset();
        };
        // Emits an event inidcating that all wizard steps and substeps have finished
        WizardComponent.prototype.finish = function () {
            this.onFinish.emit({
                index: this.stepIndex(this.selectedStep),
                step: this.selectedStep
            });
            this.reset();
        };
        // Navigate to the given substep
        WizardComponent.prototype.goTo = function (step, goToFirstSubstep, goToLastSubstep) {
            if (step === undefined || this.config.done
                || (!this.init && this.selectedStep !== undefined && !this.selectedStep.config.allowNavAway)) {
                return;
            }
            if (this.init || (this.getStepIndex(step) < this.selectedStepIndex && this.selectedStep.previousEnabled)
                || this.selectedStep.nextEnabled) {
                this.unselectAll();
                if (step.hasSubsteps && goToFirstSubstep) {
                    step.goToFirstStep();
                }
                else if (step.hasSubsteps && goToLastSubstep) {
                    step.goToLastStep();
                }
                else {
                    step.show(this.stepIndex(step));
                    this.stepChanged(step, this.stepIndex(step));
                }
                this.selectedStep = step;
                step.selected = true;
            }
            if (!this.selectedStep.hasSubsteps) {
                this.firstStep = this.stepIndex(this.selectedStep) === 0;
            }
            else {
                this.firstStep = this.stepIndex(this.selectedStep) === 0 && this.selectedStep.selectedStepIndex === 1;
            }
        };
        // Initializes the first step based on the ready state and whether a current step has been provided
        WizardComponent.prototype.initFirstStep = function () {
            // Set currentStep equal to selected step title
            if (this.config !== undefined && this.config.currentStep !== undefined
                && !lodash.isEqual(this.config.currentStep, this.prevConfig.currentStep)
                && (this.selectedStep !== undefined && this.selectedStep.config.title !== this.config.currentStep)) {
                this.goTo(this.stepByTitle(this.config.currentStep), true, false);
            }
            else {
                var enabledSteps = this.getEnabledSteps();
                this.goTo(enabledSteps[0], true, false);
            }
            this.init = false;
        };
        // Reset wizard state
        WizardComponent.prototype.reset = function () {
            // Traverse steps array and set each "completed" property to false
            this.getEnabledSteps().forEach(function (step) {
                step.config.completed = false;
            });
            // Go to first step
            this.goToStep(0, true);
        };
        // Handle step navigation
        WizardComponent.prototype.stepClick = function (step) {
            if (step.config.allowClickNav) {
                this.goTo(step, true, false);
            }
        };
        __decorate$1h([
            core.Input(),
            __metadata$L("design:type", WizardConfig)
        ], WizardComponent.prototype, "config", void 0);
        __decorate$1h([
            core.Output('onCancel'),
            __metadata$L("design:type", Object)
        ], WizardComponent.prototype, "onCancel", void 0);
        __decorate$1h([
            core.Output('onFinish'),
            __metadata$L("design:type", Object)
        ], WizardComponent.prototype, "onFinish", void 0);
        __decorate$1h([
            core.Output('onNext'),
            __metadata$L("design:type", Object)
        ], WizardComponent.prototype, "onNext", void 0);
        __decorate$1h([
            core.Output('onPrevious'),
            __metadata$L("design:type", Object)
        ], WizardComponent.prototype, "onPrevious", void 0);
        __decorate$1h([
            core.Output('onStepChange'),
            __metadata$L("design:type", Object)
        ], WizardComponent.prototype, "onStepChange", void 0);
        WizardComponent = __decorate$1h([
            core.Component({
                encapsulation: core.ViewEncapsulation.None,
                selector: 'pfng-wizard',
                template: "<div class=\"modal-header\" *ngIf=\"!config?.hideHeader\"><button class=\"close wizard-pf-dismiss\" aria-hidden=\"true\" aria-label=\"Close\" type=\"button\" (click)=\"cancel()\" *ngIf=\"!config?.embedInPage\"><span class=\"pficon pficon-close\"></span></button><h4 class=\"modal-title\">{{config?.title}}</h4></div><div class=\"modal-body wizard-pf-body clearfix\"><div class=\"wizard-pf-steps\" [ngClass]=\"{'invisible': !config?.ready}\" *ngIf=\"config?.ready\"><ul class=\"wizard-pf-steps-indicator\" [ngClass]=\"{'invisible': !config?.ready}\" *ngIf=\"!config?.hideIndicators\"><li class=\"wizard-pf-step\" [ngClass]=\"{'active': step.selected}\" *ngFor=\"let step of getEnabledSteps(); let i = index\"><a (click)=\"stepClick(step)\" [ngClass]=\"{'disabled': !allowStepIndicatorClick(step)}\"><span class=\"wizard-pf-step-number\">{{i + 1}}</span> <span class=\"wizard-pf-step-title\">{{step.config?.title}}</span></a></li></ul></div><div *ngIf=\"!config?.ready\" class=\"wizard-pf-main pfng-wizard-main\"><div class=\"wizard-pf-loading blank-slate-pf\"><div class=\"spinner spinner-lg blank-slate-pf-icon\"></div><h3 class=\"blank-slate-pf-main-action\">{{config?.loadingTitle}}</h3><p class=\"blank-slate-pf-secondary-action\">{{config?.loadingSecondaryInfo}}</p></div></div><div class=\"pfng-wizard-position-override\"><ng-content></ng-content></div></div><div class=\"modal-footer wizard-pf-footer pfng-wizard-position-override\" [ngClass]=\"{'pfng-footer-inline': config?.embedInPage}\"><button class=\"btn btn-default wizard-btn btn-cancel\" type=\"button\" [disabled]=\"config?.done\" (click)=\"cancel()\" *ngIf=\"!config?.embedInPage\">{{config?.cancelTitle}}</button> <button class=\"btn btn-default pfng-wizard-previous-btn\" type=\"button\" tooltip=\"{{selectedStep?.config?.previousTooltip}}\" placement=\"left\" [ngClass]=\"{'pfng-wizard-btn-no-back': config?.hidePreviousButton}\" [disabled]=\"!config?.ready || config?.done || !selectedStep?.previousEnabled || firstStep\" (click)=\"previous(true)\">{{config?.previousTitle}}</button> <button class=\"btn btn-primary wizard-pf-next\" type=\"button\" tooltip=\"{{selectedStep?.config?.nextTooltip}}\" placement=\"left\" [disabled]=\"!config?.ready || !selectedStep?.nextEnabled\" (click)=\"next(true)\">{{config?.nextTitle}}</button> <button class=\"btn btn-default btn-cancel pfng-cancel-inline\" type=\"button\" [disabled]=\"config?.done\" (click)=\"cancel()\" *ngIf=\"config?.embedInPage\">{{config?.cancelTitle}}</button></div>"
            }),
            __metadata$L("design:paramtypes", [])
        ], WizardComponent);
        return WizardComponent;
    }(WizardBase));

    /**
     * An object containing properties for wizard events
     */
    var WizardEvent = /** @class */ (function () {
        function WizardEvent() {
        }
        return WizardEvent;
    }());

    var __decorate$1i = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata$M = (undefined && undefined.__metadata) || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    var __param$1 = (undefined && undefined.__param) || function (paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    };
    /**
     * Wizard review component
     *
     * Note: This component is expected to be direct descendant of wizard-step or wizard-substep.
     */
    var WizardReviewComponent = /** @class */ (function () {
        /**
         * The default constructor
         */
        function WizardReviewComponent(wizard) {
            this.wizard = wizard;
        }
        // Initialization
        /**
         * Setup component configuration upon initialization
         */
        WizardReviewComponent.prototype.ngOnInit = function () {
        };
        // Methods
        /**
         * Returns only wizard steps with review templates
         *
         * @returns {WizardStep[]} The wizard stepd or substepd
         */
        WizardReviewComponent.prototype.getReviewSteps = function () {
            return this.wizard.getReviewSteps();
        };
        // Private
        // Returns the step number for the given wizard step and substep
        WizardReviewComponent.prototype.getSubstepNumber = function (step, substep) {
            return step.getDisplayNumber(substep);
        };
        // Returns only wizard steps with review templates
        WizardReviewComponent.prototype.getReviewSubsteps = function (step) {
            return step.getReviewSteps();
        };
        // Toggles the review step control
        WizardReviewComponent.prototype.toggleReview = function (step) {
            step.config.expandReview = !step.config.expandReview;
        };
        // Toggles the review details control
        WizardReviewComponent.prototype.toggleReviewDetails = function (step) {
            step.config.expandReviewDetails = !step.config.expandReviewDetails;
        };
        WizardReviewComponent = __decorate$1i([
            core.Component({
                encapsulation: core.ViewEncapsulation.None,
                selector: 'pfng-wizard-review',
                template: "<div class=\"wizard-pf-review-page\"><div class=\"wizard-pf-review-steps\"><ul class=\"list-group\"><li class=\"list-group-item\" *ngFor=\"let step of getReviewSteps()\"><a class=\"apf-form-collapse\" [ngClass]=\"{'collapsed': step.config.expandReview !== true}\" (click)=\"toggleReview(step)\">{{step.config.title}}</a><div class=\"wizard-pf-review-substeps\" [ngClass]=\"{'collapse': step.config.expandReview !== true}\"><ul class=\"list-group\" *ngIf=\"step.hasSubsteps\"><li class=\"list-group-item\" *ngFor=\"let substep of getReviewSubsteps(step)\"><a class=\"apf-form-collapse\" [ngClass]=\"{'collapsed': substep.config.expandReviewDetails !== true}\" (click)=\"toggleReviewDetails(substep)\"><span class=\"wizard-pf-substep-number\">{{getSubstepNumber(step, substep)}}</span> <span class=\"wizard-pf-substep-title\">{{substep.config.title}}</span></a><div class=\"wizard-pf-review-content\" [ngClass]=\"{'collapse': substep.config.expandReviewDetails !== true}\"><ng-template [ngTemplateOutlet]=\"substep.reviewTemplate\"></ng-template></div></li></ul><div class=\"wizard-pf-review-content\" [ngClass]=\"{'collapse': step.config.expandReviewDetails !== true}\" *ngIf=\"step.reviewTemplate\"><ng-template [ngTemplateOutlet]=\"step.reviewTemplate\"></ng-template></div></div></li></ul></div></div>"
            }),
            __param$1(0, core.Host()),
            __metadata$M("design:paramtypes", [WizardComponent])
        ], WizardReviewComponent);
        return WizardReviewComponent;
    }());

    /**
     * Wizard step
     */
    var WizardStep = /** @class */ (function () {
        function WizardStep() {
        }
        return WizardStep;
    }());

    /**
     * A config containing properties for wizard steps and substeps
     */
    var WizardStepConfig = /** @class */ (function () {
        function WizardStepConfig() {
        }
        return WizardStepConfig;
    }());

    var __extends$2i = (undefined && undefined.__extends) || (function () {
        var extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var __decorate$1j = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata$N = (undefined && undefined.__metadata) || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    var __param$2 = (undefined && undefined.__param) || function (paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    };
    /**
     * Wizard step component. Each step can stand alone or have substeps.
     *
     * Note: This component is expected to be a child of wizard.
     */
    var WizardStepComponent = /** @class */ (function (_super) {
        __extends$2i(WizardStepComponent, _super);
        /**
         * The default constructor
         */
        function WizardStepComponent(wizard) {
            var _this = _super.call(this) || this;
            /**
             * The event emitted when this wizard step is shown
             */
            _this.onShow = new core.EventEmitter();
            _this.defaultConfig = {
                allowClickNav: true,
                allowNavAway: true,
                completed: false,
                disabled: false,
                expandReview: true,
                expandReviewDetails: false,
                nextEnabled: true,
                previousEnabled: true,
                priority: 999,
                title: ''
            };
            _this.init = true;
            _this.pageIndex = 0;
            _this._selected = false;
            _this.wizard = wizard;
            return _this;
        }
        // Initialization
        /**
         * Setup component configuration upon initialization
         */
        WizardStepComponent.prototype.ngOnInit = function () {
            this.setupConfig();
            if (this.wizard !== undefined && this.selectedStep === undefined) {
                this.wizard.addStep(this);
            }
        };
        /**
         * Check if the component config has changed
         */
        WizardStepComponent.prototype.ngDoCheck = function () {
            // Do a deep compare on config
            if (!lodash.isEqual(this.config, this.prevConfig)) {
                this.setupConfig();
            }
            if (this.wizard !== undefined) {
                this.pageIndex = this.wizard.getStepIndex(this);
            }
        };
        /**
         * Set up default config
         */
        WizardStepComponent.prototype.setupConfig = function () {
            if (this.config !== undefined) {
                lodash.defaults(this.config, this.defaultConfig);
            }
            else {
                this.config = lodash.cloneDeep(this.defaultConfig);
            }
            this.prevConfig = lodash.cloneDeep(this.config);
        };
        Object.defineProperty(WizardStepComponent.prototype, "hasSubsteps", {
            // Accessors
            /**
             * Indicates that this wizard step has substeps
             *
             * @returns {boolean} true if this wizard step has substeps
             */
            get: function () {
                return this.steps.length > 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WizardStepComponent.prototype, "nextEnabled", {
            /**
             * Indicates that the next button is enabled
             *
             * @returns {boolean} true if the next button is enabled
             */
            get: function () {
                var enabled = this.config.nextEnabled;
                if (this.hasSubsteps) {
                    var selectedSubstep = this.getEnabledSteps().filter(function (step) { return step.selected; });
                    if (selectedSubstep && selectedSubstep.length > 0) {
                        enabled = selectedSubstep[0].config.nextEnabled;
                    }
                }
                return enabled;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WizardStepComponent.prototype, "previousEnabled", {
            /**
             * Indicates that the previous button is enabled
             *
             * @returns {boolean} true if the previous button is enabled
             */
            get: function () {
                var enabled = this.config.previousEnabled;
                if (this.hasSubsteps) {
                    var selectedSubstep = this.getEnabledSteps().filter(function (step) { return step.selected; });
                    if (selectedSubstep && selectedSubstep.length > 0) {
                        enabled = selectedSubstep[0].config.previousEnabled;
                    }
                }
                return enabled;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WizardStepComponent.prototype, "selected", {
            /**
             * Indicates that this wizard step is selected
             *
             * @returns {boolean} True if this wizard step is selected
             */
            get: function () {
                return this._selected;
            },
            /**
             * Sets a flag indicating that this wizard step is selected
             *
             * @param {boolean} selected True if this wizard step is selected
             */
            set: function (selected) {
                this._selected = selected;
            },
            enumerable: true,
            configurable: true
        });
        // Methods
        /**
         * Returns the step number to be displayed for the given wizard step or substep
         *
         * @param {WizardStep} step The wizard step or substep
         * @returns {string} The step number to be displayed
         */
        WizardStepComponent.prototype.getDisplayNumber = function (step) {
            return this.pageIndex + String.fromCharCode(65 + this.stepIndex(step)) + '.';
        };
        /**
         * Returns only wizard substeps with review templates
         *
         * @returns {WizardStep[]} The wizard stepd or substepd
         */
        WizardStepComponent.prototype.getReviewSteps = function () {
            var reviewSteps = this.getEnabledSteps().filter(function (step) {
                return (step.reviewTemplate !== undefined);
            });
            return reviewSteps;
        };
        /**
         * Navigate to the first wizard substep
         */
        WizardStepComponent.prototype.goToFirstStep = function () {
            this.goTo(this.getEnabledSteps()[0]);
        };
        /**
         * Navigate to the last wizard substep
         */
        WizardStepComponent.prototype.goToLastStep = function () {
            var enabledSteps = this.getEnabledSteps();
            this.goTo(enabledSteps[enabledSteps.length - 1]);
        };
        /**
         * Navigate to the next wizard step or substep
         */
        WizardStepComponent.prototype.goToNextStep = function () {
            this.next(false);
        };
        /**
         * Navigate to the previous wizard step or substep
         */
        WizardStepComponent.prototype.goToPreviousStep = function () {
            this.previous(false);
        };
        /**
         * Called when the next button has been selected.
         *
         * @param {boolean} emitEvent True to emit the wizard's onNext event
         */
        WizardStepComponent.prototype.next = function (emitEvent) {
            var enabledSteps = this.getEnabledSteps();
            // Save the step you were on when next() was invoked
            var index = this.stepIndex(this.selectedStep);
            var wizEvent = {
                index: index,
                step: this.selectedStep
            };
            if (emitEvent !== false) {
                this.wizard.onNext.emit(wizEvent);
            }
            // Set completed property, which may be used to add/remove a style class from progress bar
            this.selectedStep.config.completed = true;
            // Ensure this is not the last step.
            if (index === enabledSteps.length - 1) {
                return false;
            }
            this.goTo(enabledSteps[index + 1]);
            return true;
        };
        /**
         * Called when the previous button has been selected.
         *
         * @param {boolean} emitEvent True to emit the wizard's onPrevious event
         */
        WizardStepComponent.prototype.previous = function (emitEvent) {
            var index = this.stepIndex(this.selectedStep);
            var wizEvent = {
                index: index,
                step: this.selectedStep
            };
            if (emitEvent !== false) {
                this.wizard.onPrevious.emit(wizEvent);
            }
            // Ensure this is not the first step
            if (index === 0) {
                return false;
            }
            this.goTo(this.getEnabledSteps()[index - 1]);
            return true;
        };
        /**
         * Emits an event when a wizard step or substep is shown
         */
        WizardStepComponent.prototype.show = function (index) {
            this.onShow.emit({
                index: index,
                step: this
            });
        };
        // Private
        // Navigate to the given wizard substep
        WizardStepComponent.prototype.goTo = function (step) {
            if (step === undefined || this.wizard === undefined || this.wizard.config.done
                || (!this.init && this.selectedStep !== undefined && !this.selectedStep.config.allowNavAway)) {
                return;
            }
            if (this.init || this.isPreviousStepsComplete(step)
                || (this.getStepIndex(step) < this.selectedStepIndex && this.selectedStep.config.previousEnabled)) {
                this.unselectAll();
                this.selectedStep = step;
                step.selected = true;
                step.show(this.stepIndex(step));
                this.wizard.stepChanged(step, this.stepIndex(step));
                this.wizard.updateStepIndex(this.stepIndex(this.selectedStep));
                this.init = false;
            }
        };
        // Indicates all previous substeps are complete for this wizard step
        WizardStepComponent.prototype.isPreviousStepsComplete = function (nextStep) {
            var nextIdx = this.stepIndex(nextStep);
            var complete = true;
            this.getEnabledSteps().forEach(function (step, stepIndex) {
                if (stepIndex < nextIdx) {
                    complete = complete && step.config.nextEnabled;
                }
            });
            return complete;
        };
        // Handle step navigation
        WizardStepComponent.prototype.stepClick = function (step) {
            if (step.config.allowClickNav) {
                this.goTo(step);
            }
        };
        __decorate$1j([
            core.Input(),
            __metadata$N("design:type", WizardStepConfig)
        ], WizardStepComponent.prototype, "config", void 0);
        __decorate$1j([
            core.Input(),
            __metadata$N("design:type", core.TemplateRef)
        ], WizardStepComponent.prototype, "reviewTemplate", void 0);
        __decorate$1j([
            core.Output('onShow'),
            __metadata$N("design:type", Object)
        ], WizardStepComponent.prototype, "onShow", void 0);
        WizardStepComponent = __decorate$1j([
            core.Component({
                encapsulation: core.ViewEncapsulation.None,
                selector: 'pfng-wizard-step',
                template: "<section class=\"wizard-pf-row\" *ngIf=\"selected\"><div class=\"wizard-pf-sidebar\" [ngClass]=\"wizard?.config?.sidebarStyleClass\" [ngStyle]=\"wizard?.contentStyle\" *ngIf=\"hasSubsteps && !wizard?.config?.hideSidebar\"><ul class=\"list-group\"><li class=\"list-group-item\" [ngClass]=\"{'active': step.selected}\" *ngFor=\"let step of getEnabledSteps()\"><a (click)=\"stepClick(step)\"><span class=\"wizard-pf-substep-number\">{{getDisplayNumber(step)}}</span> <span class=\"wizard-pf-substep-title\">{{step.config?.title}}</span></a></li></ul></div><div class=\"wizard-pf-main {{wizard.config?.stepStyleClass}}\" [ngClass]=\"{'pfng-wizard-single-step': !hasSubsteps || wizard?.config?.hideSidebar}\" [ngStyle]=\"wizard?.contentStyle\"><div class=\"wizard-pf-contents\"><ng-content></ng-content></div></div></section>"
            }),
            __param$2(0, core.Host()),
            __metadata$N("design:paramtypes", [WizardComponent])
        ], WizardStepComponent);
        return WizardStepComponent;
    }(WizardBase));

    var __decorate$1k = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata$O = (undefined && undefined.__metadata) || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    var __param$3 = (undefined && undefined.__param) || function (paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    };
    /**
     * Wizard substep component.
     *
     * Note: This component is expected to be a child of wizard-step.
     */
    var WizardSubstepComponent = /** @class */ (function () {
        /**
         * The default constructor
         */
        function WizardSubstepComponent(step) {
            /**
             * The event emitted when this wizard substep is shown
             */
            this.onShow = new core.EventEmitter();
            this.defaultConfig = {
                allowClickNav: true,
                allowNavAway: true,
                completed: false,
                data: {},
                disabled: false,
                expandReview: true,
                expandReviewDetails: false,
                priority: 999,
                nextEnabled: true,
                okToNavAway: true,
                previousEnabled: true,
                title: ''
            };
            this._selected = false;
            this.step = step;
        }
        // Initialization
        /**
         * Setup component configuration upon initialization
         */
        WizardSubstepComponent.prototype.ngOnInit = function () {
            this.setupConfig();
            if (this.step !== undefined) {
                this.step.config.allowClickNav = this.config.allowClickNav;
                this.step.config.nextEnabled = this.config.nextEnabled;
                this.step.config.allowNavAway = this.config.allowNavAway;
                this.step.config.previousEnabled = this.config.previousEnabled;
                this.step.addStep(this);
            }
        };
        /**
         * Check if the component config has changed
         */
        WizardSubstepComponent.prototype.ngDoCheck = function () {
            // Do a deep compare on config
            if (!lodash.isEqual(this.config, this.prevConfig)) {
                this.setupConfig();
            }
        };
        /**
         * Set up default config
         */
        WizardSubstepComponent.prototype.setupConfig = function () {
            if (this.config !== undefined) {
                lodash.defaults(this.config, this.defaultConfig);
            }
            else {
                this.config = lodash.cloneDeep(this.defaultConfig);
            }
            this.prevConfig = lodash.cloneDeep(this.config);
        };
        Object.defineProperty(WizardSubstepComponent.prototype, "selected", {
            // Accessors
            /**
             * Indicates that this wizard substep is selected
             *
             * @returns {boolean} True if this wizard substep is selected
             */
            get: function () {
                return this._selected;
            },
            /**
             * Sets a flag indicating that this wizard substep is selected
             *
             * @param {boolean} selected True if this wizard substep is selected
             */
            set: function (selected) {
                this._selected = selected;
            },
            enumerable: true,
            configurable: true
        });
        // Methods
        /**
         * Emits an event when this wizard substep is shown
         */
        WizardSubstepComponent.prototype.show = function (index) {
            this.onShow.emit({
                index: index,
                step: this
            });
        };
        __decorate$1k([
            core.Input(),
            __metadata$O("design:type", WizardStepConfig)
        ], WizardSubstepComponent.prototype, "config", void 0);
        __decorate$1k([
            core.Input(),
            __metadata$O("design:type", core.TemplateRef)
        ], WizardSubstepComponent.prototype, "reviewTemplate", void 0);
        __decorate$1k([
            core.Output('onShow'),
            __metadata$O("design:type", Object)
        ], WizardSubstepComponent.prototype, "onShow", void 0);
        WizardSubstepComponent = __decorate$1k([
            core.Component({
                encapsulation: core.ViewEncapsulation.None,
                selector: 'pfng-wizard-substep',
                template: "<ng-content *ngIf=\"selected\"></ng-content>"
            }),
            __param$3(0, core.Host()),
            __metadata$O("design:paramtypes", [WizardStepComponent])
        ], WizardSubstepComponent);
        return WizardSubstepComponent;
    }());

    var __decorate$1l = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    /**
     * A module containing objects associated with the wizard component
     */
    var WizardModule = /** @class */ (function () {
        function WizardModule() {
        }
        WizardModule = __decorate$1l([
            core.NgModule({
                imports: [
                    common.CommonModule,
                    TooltipModule.forRoot()
                ],
                declarations: [WizardComponent, WizardReviewComponent, WizardStepComponent, WizardSubstepComponent],
                exports: [WizardComponent, WizardReviewComponent, WizardStepComponent, WizardSubstepComponent],
                providers: [TooltipConfig]
            })
        ], WizardModule);
        return WizardModule;
    }());

    exports.Action = Action;
    exports.ActionConfig = ActionConfig;
    exports.ActionComponent = ActionComponent;
    exports.ActionModule = ActionModule;
    exports.CardBase = CardBase;
    exports.CardConfigBase = CardConfigBase;
    exports.CardModule = CardModule$1;
    exports.CardAction = CardAction;
    exports.CardActionComponent = CardActionComponent;
    exports.CardActionModule = CardActionModule;
    exports.CardComponent = CardComponent;
    exports.CardConfig = CardConfig;
    exports.CardFilter = CardFilter;
    exports.CardFilterComponent = CardFilterComponent;
    exports.CardFilterPosition = CardFilterPosition;
    exports.CardFilterModule = CardFilterModule;
    exports.InfoStatusCardComponent = InfoStatusCardComponent;
    exports.InfoStatusCardConfig = InfoStatusCardConfig;
    exports.InfoStatusCardModule = InfoStatusCardModule;
    exports.ChartBase = ChartBase;
    exports.ChartConfigBase = ChartConfigBase;
    exports.ChartDefaults = ChartDefaults;
    exports.ChartConfig = ChartConfig;
    exports.ChartModule = ChartModule;
    exports.DonutComponent = DonutComponent;
    exports.DonutConfig = DonutConfig;
    exports.SparklineComponent = SparklineComponent;
    exports.SparklineConfig = SparklineConfig;
    exports.SparklineData = SparklineData;
    exports.DonutChartBaseComponent = DonutChartBaseComponent;
    exports.DonutChartBaseConfig = DonutChartBaseConfig;
    exports.DonutChartComponent = DonutChartComponent;
    exports.DonutChartConfig = DonutChartConfig;
    exports.DonutChartModule = DonutChartModule;
    exports.UtilizationDonutChartComponent = UtilizationDonutChartComponent;
    exports.UtilizationDonutChartConfig = UtilizationDonutChartConfig;
    exports.UtilizationDonutChartModule = UtilizationDonutChartModule;
    exports.SparklineChartComponent = SparklineChartComponent;
    exports.SparklineChartConfig = SparklineChartConfig;
    exports.SparklineChartData = SparklineChartData;
    exports.SparklineChartModule = SparklineChartModule;
    exports.CopyBase = CopyBase;
    exports.CopyService = CopyService;
    exports.CopyServiceModule = CopyServiceModule;
    exports.InlineCopyComponent = InlineCopyComponent;
    exports.InlineCopyModule = InlineCopyModule;
    exports.BlockCopyComponent = BlockCopyComponent;
    exports.BlockCopyModule = BlockCopyModule;
    exports.EmptyStateComponent = EmptyStateComponent;
    exports.EmptyStateConfig = EmptyStateConfig;
    exports.EmptyStateModule = EmptyStateModule;
    exports.Filter = Filter;
    exports.FilterComponent = FilterComponent;
    exports.FilterConfig = FilterConfig;
    exports.FilterEvent = FilterEvent;
    exports.FilterField = FilterField;
    exports.FilterFieldsComponent = FilterFieldsComponent;
    exports.FilterModule = FilterModule;
    exports.FilterResultsComponent = FilterResultsComponent;
    exports.FilterQuery = FilterQuery;
    exports.FilterType = FilterType;
    exports.ListBase = ListBase;
    exports.ListConfigBase = ListConfigBase;
    exports.ListEvent = ListEvent;
    exports.ListComponent = ListComponent;
    exports.ListConfig = ListConfig;
    exports.ListExpandToggleComponent = ListExpandToggleComponent;
    exports.ListModule = ListModule;
    exports.TreeListComponent = TreeListComponent;
    exports.TreeListConfig = TreeListConfig;
    exports.TreeListModule = TreeListModule;
    exports.AboutModalConfig = AboutModalConfig;
    exports.AboutModalComponent = AboutModalComponent;
    exports.ModalModule = ModalModule;
    exports.NavigationItemConfig = NavigationItemConfig;
    exports.NavigationModule = NavigationModule;
    exports.VerticalNavigationComponent = VerticalNavigationComponent;
    exports.ApplicationLauncherComponent = ApplicationLauncherComponent;
    exports.Notification = Notification;
    exports.NotificationEvent = NotificationEvent;
    exports.NotificaitonGroup = NotificaitonGroup;
    exports.NotificationModule = NotificationModule;
    exports.NotificationType = NotificationType;
    exports.InlineNotificationComponent = InlineNotificationComponent;
    exports.InlineNotificationModule = InlineNotificationModule;
    exports.NotificationDrawerComponent = NotificationDrawerComponent;
    exports.NotificationDrawerModule = NotificationDrawerModule;
    exports.NotificationService = NotificationService;
    exports.ToastNotificationComponent = ToastNotificationComponent;
    exports.ToastNotificationModule = ToastNotificationModule;
    exports.ToastNotificationListComponent = ToastNotificationListComponent;
    exports.ToastNotificationListModule = ToastNotificationListModule;
    exports.PaginationComponent = PaginationComponent;
    exports.PaginationConfig = PaginationConfig;
    exports.PaginationEvent = PaginationEvent;
    exports.PaginationModule = PaginationModule;
    exports.PipeModule = PipeModule;
    exports.SearchHighlightPipeModule = SearchHighlightPipeModule;
    exports.SearchHighlightPipe = SearchHighlightPipe;
    exports.SortArrayPipeModule = SortArrayPipeModule;
    exports.SortArrayPipe = SortArrayPipe;
    exports.TruncatePipeModule = TruncatePipeModule;
    exports.TruncatePipe = TruncatePipe;
    exports.RemainingCharsCountDirective = RemainingCharsCountDirective;
    exports.RemainingCharsCountModule = RemainingCharsCountModule;
    exports.SampleModule = SampleModule;
    exports.SortComponent = SortComponent;
    exports.SortConfig = SortConfig;
    exports.SortEvent = SortEvent;
    exports.SortField = SortField;
    exports.SortModule = SortModule;
    exports.TableBase = TableBase;
    exports.TableConfigBase = TableConfigBase;
    exports.TableEvent = TableEvent;
    exports.NgxDataTableConfig = NgxDataTableConfig;
    exports.TableComponent = TableComponent;
    exports.TableConfig = TableConfig;
    exports.TableModule = TableModule;
    exports.ToolbarConfig = ToolbarConfig;
    exports.ToolbarComponent = ToolbarComponent;
    exports.ToolbarModule = ToolbarModule;
    exports.ToolbarView = ToolbarView;
    exports.WindowReference = WindowReference;
    exports.WizardBase = WizardBase;
    exports.WizardComponent = WizardComponent;
    exports.WizardConfig = WizardConfig;
    exports.WizardEvent = WizardEvent;
    exports.WizardModule = WizardModule;
    exports.WizardReviewComponent = WizardReviewComponent;
    exports.WizardStep = WizardStep;
    exports.WizardStepComponent = WizardStepComponent;
    exports.WizardStepConfig = WizardStepConfig;
    exports.WizardSubstepComponent = WizardSubstepComponent;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=patternfly-ng.umd.js.map
